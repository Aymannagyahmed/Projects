
FreeRTOS_test_4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  00001b82  00001c16  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001b82  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000008d  00800126  00800126  00001c3c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001c3c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001c6c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000428  00000000  00000000  00001cac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005f34  00000000  00000000  000020d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017ca  00000000  00000000  00008008  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e08  00000000  00000000  000097d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d00  00000000  00000000  0000c5dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001cd4  00000000  00000000  0000d2dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000527f  00000000  00000000  0000efb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000510  00000000  00000000  0001422f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__ctors_end>
       4:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       8:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      10:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      14:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      18:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      1c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      20:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      24:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      28:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      2c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      30:	0c 94 8f 02 	jmp	0x51e	; 0x51e <__vector_12>
      34:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      38:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      3c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      40:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      44:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      48:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      4c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      50:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      54:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      58:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      5c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      60:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      64:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      68:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      6c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      70:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      74:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      78:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      7c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      80:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      84:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      88:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      8c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      90:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      94:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      98:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      9c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a0:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a4:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a8:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      ac:	13 0c       	add	r1, r3
      ae:	13 0c       	add	r1, r3
      b0:	13 0c       	add	r1, r3
      b2:	43 0c       	add	r4, r3
      b4:	4b 0c       	add	r4, r11
      b6:	5b 0c       	add	r5, r11
      b8:	13 0c       	add	r1, r3
      ba:	13 0c       	add	r1, r3
      bc:	43 0c       	add	r4, r3
      be:	4b 0c       	add	r4, r11

000000c0 <__ctors_end>:
      c0:	11 24       	eor	r1, r1
      c2:	1f be       	out	0x3f, r1	; 63
      c4:	cf ef       	ldi	r28, 0xFF	; 255
      c6:	da e0       	ldi	r29, 0x0A	; 10
      c8:	de bf       	out	0x3e, r29	; 62
      ca:	cd bf       	out	0x3d, r28	; 61

000000cc <__do_copy_data>:
      cc:	11 e0       	ldi	r17, 0x01	; 1
      ce:	a0 e0       	ldi	r26, 0x00	; 0
      d0:	b1 e0       	ldi	r27, 0x01	; 1
      d2:	e2 e8       	ldi	r30, 0x82	; 130
      d4:	fb e1       	ldi	r31, 0x1B	; 27
      d6:	02 c0       	rjmp	.+4      	; 0xdc <__do_copy_data+0x10>
      d8:	05 90       	lpm	r0, Z+
      da:	0d 92       	st	X+, r0
      dc:	a6 32       	cpi	r26, 0x26	; 38
      de:	b1 07       	cpc	r27, r17
      e0:	d9 f7       	brne	.-10     	; 0xd8 <__do_copy_data+0xc>

000000e2 <__do_clear_bss>:
      e2:	21 e0       	ldi	r18, 0x01	; 1
      e4:	a6 e2       	ldi	r26, 0x26	; 38
      e6:	b1 e0       	ldi	r27, 0x01	; 1
      e8:	01 c0       	rjmp	.+2      	; 0xec <.do_clear_bss_start>

000000ea <.do_clear_bss_loop>:
      ea:	1d 92       	st	X+, r1

000000ec <.do_clear_bss_start>:
      ec:	a3 3b       	cpi	r26, 0xB3	; 179
      ee:	b2 07       	cpc	r27, r18
      f0:	e1 f7       	brne	.-8      	; 0xea <.do_clear_bss_loop>
      f2:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <main>
      f6:	0c 94 bf 0d 	jmp	0x1b7e	; 0x1b7e <_exit>

000000fa <__bad_interrupt>:
      fa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000fe <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      fe:	cf 93       	push	r28
     100:	df 93       	push	r29
     102:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
     104:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
     108:	ce 01       	movw	r24, r28
     10a:	0e 94 8e 0c 	call	0x191c	; 0x191c <malloc>
     10e:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     110:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
     114:	20 97       	sbiw	r28, 0x00	; 0
     116:	11 f4       	brne	.+4      	; 0x11c <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
     118:	0e 94 bb 00 	call	0x176	; 0x176 <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
     11c:	ce 01       	movw	r24, r28
     11e:	df 91       	pop	r29
     120:	cf 91       	pop	r28
     122:	08 95       	ret

00000124 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     124:	cf 93       	push	r28
     126:	df 93       	push	r29
    if( pv )
     128:	00 97       	sbiw	r24, 0x00	; 0
     12a:	41 f0       	breq	.+16     	; 0x13c <vPortFree+0x18>
     12c:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
     12e:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
        {
            free( pv );
     132:	ce 01       	movw	r24, r28
     134:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
     138:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
    }
}
     13c:	df 91       	pop	r29
     13e:	cf 91       	pop	r28
     140:	08 95       	ret

00000142 <vApplicationIdleHook>:

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino with 328p
    DIDR0 = 0x3F;

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DIDR0 = 0xF3;
     142:	83 ef       	ldi	r24, 0xF3	; 243
     144:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
    DIDR2 = 0x3F;
     148:	8f e3       	ldi	r24, 0x3F	; 63
     14a:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7f807d>
    // When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
    // This bit can be set at any time to turn off the Analogue Comparator.
    // This will reduce power consumption in Active and Idle mode.
    // When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
    // Otherwise an interrupt can occur when the ACD bit is changed.
    ACSR &= ~_BV(ACIE);
     14e:	80 b7       	in	r24, 0x30	; 48
     150:	87 7f       	andi	r24, 0xF7	; 247
     152:	80 bf       	out	0x30, r24	; 48
    ACSR |=  _BV(ACD);
     154:	80 b7       	in	r24, 0x30	; 48
     156:	80 68       	ori	r24, 0x80	; 128
     158:	80 bf       	out	0x30, r24	; 48
    // SLEEP_MODE_PWR_DOWN     _BV(SM1)
    // SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
    // SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
    // SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

    set_sleep_mode( SLEEP_MODE_IDLE );
     15a:	83 b7       	in	r24, 0x33	; 51
     15c:	81 7f       	andi	r24, 0xF1	; 241
     15e:	83 bf       	out	0x33, r24	; 51

    portENTER_CRITICAL();
     160:	0f b6       	in	r0, 0x3f	; 63
     162:	f8 94       	cli
     164:	0f 92       	push	r0
    sleep_enable();
     166:	83 b7       	in	r24, 0x33	; 51
     168:	81 60       	ori	r24, 0x01	; 1
     16a:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
    sleep_bod_disable();
#endif

    portEXIT_CRITICAL();
     16c:	0f 90       	pop	r0
     16e:	0f be       	out	0x3f, r0	; 63
    sleep_cpu();            // good night.
     170:	88 95       	sleep

    sleep_reset();          // reset the sleep_mode() faster than sleep_disable();
     172:	13 be       	out	0x33, r1	; 51
     174:	08 95       	ret

00000176 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DDRC  |= _BV(DDC7);
     176:	3f 9a       	sbi	0x07, 7	; 7
    PORTC |= _BV(PORTC7);       // Main (red PC7) LED on. Main LED on.
     178:	47 9a       	sbi	0x08, 7	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     17a:	83 ed       	ldi	r24, 0xD3	; 211
     17c:	90 e3       	ldi	r25, 0x30	; 48
     17e:	01 97       	sbiw	r24, 0x01	; 1
     180:	f1 f7       	brne	.-4      	; 0x17e <vApplicationMallocFailedHook+0x8>
     182:	00 c0       	rjmp	.+0      	; 0x184 <vApplicationMallocFailedHook+0xe>
     184:	00 00       	nop

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
        PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED fast blink.
     186:	37 9a       	sbi	0x06, 7	; 6
     188:	f8 cf       	rjmp	.-16     	; 0x17a <vApplicationMallocFailedHook+0x4>

0000018a <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DDRC  |= _BV(DDC7);
     18a:	3f 9a       	sbi	0x07, 7	; 7
    PORTC |= _BV(PORTC7);       // Main (red PC7) LED on. Main LED on.
     18c:	47 9a       	sbi	0x08, 7	; 8
     18e:	2f e7       	ldi	r18, 0x7F	; 127
     190:	8a e1       	ldi	r24, 0x1A	; 26
     192:	96 e0       	ldi	r25, 0x06	; 6
     194:	21 50       	subi	r18, 0x01	; 1
     196:	80 40       	sbci	r24, 0x00	; 0
     198:	90 40       	sbci	r25, 0x00	; 0
     19a:	e1 f7       	brne	.-8      	; 0x194 <vApplicationStackOverflowHook+0xa>
     19c:	00 c0       	rjmp	.+0      	; 0x19e <vApplicationStackOverflowHook+0x14>
     19e:	00 00       	nop

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
        PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED slow blink.
     1a0:	37 9a       	sbi	0x06, 7	; 6
     1a2:	f5 cf       	rjmp	.-22     	; 0x18e <vApplicationStackOverflowHook+0x4>

000001a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     1a4:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1a6:	03 96       	adiw	r24, 0x03	; 3
     1a8:	92 83       	std	Z+2, r25	; 0x02
     1aa:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     1ac:	2f ef       	ldi	r18, 0xFF	; 255
     1ae:	3f ef       	ldi	r19, 0xFF	; 255
     1b0:	34 83       	std	Z+4, r19	; 0x04
     1b2:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1b4:	96 83       	std	Z+6, r25	; 0x06
     1b6:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1b8:	90 87       	std	Z+8, r25	; 0x08
     1ba:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1bc:	10 82       	st	Z, r1
     1be:	08 95       	ret

000001c0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     1c0:	fc 01       	movw	r30, r24
     1c2:	11 86       	std	Z+9, r1	; 0x09
     1c4:	10 86       	std	Z+8, r1	; 0x08
     1c6:	08 95       	ret

000001c8 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	9c 01       	movw	r18, r24
     1ce:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     1d0:	dc 01       	movw	r26, r24
     1d2:	11 96       	adiw	r26, 0x01	; 1
     1d4:	cd 91       	ld	r28, X+
     1d6:	dc 91       	ld	r29, X
     1d8:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     1da:	d3 83       	std	Z+3, r29	; 0x03
     1dc:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     1de:	8c 81       	ldd	r24, Y+4	; 0x04
     1e0:	9d 81       	ldd	r25, Y+5	; 0x05
     1e2:	95 83       	std	Z+5, r25	; 0x05
     1e4:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     1e6:	8c 81       	ldd	r24, Y+4	; 0x04
     1e8:	9d 81       	ldd	r25, Y+5	; 0x05
     1ea:	dc 01       	movw	r26, r24
     1ec:	13 96       	adiw	r26, 0x03	; 3
     1ee:	7c 93       	st	X, r23
     1f0:	6e 93       	st	-X, r22
     1f2:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
     1f4:	7d 83       	std	Y+5, r23	; 0x05
     1f6:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     1f8:	31 87       	std	Z+9, r19	; 0x09
     1fa:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
     1fc:	f9 01       	movw	r30, r18
     1fe:	80 81       	ld	r24, Z
     200:	8f 5f       	subi	r24, 0xFF	; 255
     202:	80 83       	st	Z, r24
}
     204:	df 91       	pop	r29
     206:	cf 91       	pop	r28
     208:	08 95       	ret

0000020a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     20a:	cf 93       	push	r28
     20c:	df 93       	push	r29
     20e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     210:	48 81       	ld	r20, Y
     212:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     214:	4f 3f       	cpi	r20, 0xFF	; 255
     216:	2f ef       	ldi	r18, 0xFF	; 255
     218:	52 07       	cpc	r21, r18
     21a:	21 f4       	brne	.+8      	; 0x224 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     21c:	fc 01       	movw	r30, r24
     21e:	a7 81       	ldd	r26, Z+7	; 0x07
     220:	b0 85       	ldd	r27, Z+8	; 0x08
     222:	0d c0       	rjmp	.+26     	; 0x23e <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     224:	dc 01       	movw	r26, r24
     226:	13 96       	adiw	r26, 0x03	; 3
     228:	01 c0       	rjmp	.+2      	; 0x22c <vListInsert+0x22>
     22a:	df 01       	movw	r26, r30
     22c:	12 96       	adiw	r26, 0x02	; 2
     22e:	ed 91       	ld	r30, X+
     230:	fc 91       	ld	r31, X
     232:	13 97       	sbiw	r26, 0x03	; 3
     234:	20 81       	ld	r18, Z
     236:	31 81       	ldd	r19, Z+1	; 0x01
     238:	42 17       	cp	r20, r18
     23a:	53 07       	cpc	r21, r19
     23c:	b0 f7       	brcc	.-20     	; 0x22a <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     23e:	12 96       	adiw	r26, 0x02	; 2
     240:	ed 91       	ld	r30, X+
     242:	fc 91       	ld	r31, X
     244:	13 97       	sbiw	r26, 0x03	; 3
     246:	fb 83       	std	Y+3, r31	; 0x03
     248:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     24a:	d5 83       	std	Z+5, r29	; 0x05
     24c:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     24e:	bd 83       	std	Y+5, r27	; 0x05
     250:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
     252:	13 96       	adiw	r26, 0x03	; 3
     254:	dc 93       	st	X, r29
     256:	ce 93       	st	-X, r28
     258:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
     25a:	99 87       	std	Y+9, r25	; 0x09
     25c:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     25e:	fc 01       	movw	r30, r24
     260:	20 81       	ld	r18, Z
     262:	2f 5f       	subi	r18, 0xFF	; 255
     264:	20 83       	st	Z, r18
}
     266:	df 91       	pop	r29
     268:	cf 91       	pop	r28
     26a:	08 95       	ret

0000026c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     272:	a0 85       	ldd	r26, Z+8	; 0x08
     274:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     276:	c2 81       	ldd	r28, Z+2	; 0x02
     278:	d3 81       	ldd	r29, Z+3	; 0x03
     27a:	84 81       	ldd	r24, Z+4	; 0x04
     27c:	95 81       	ldd	r25, Z+5	; 0x05
     27e:	9d 83       	std	Y+5, r25	; 0x05
     280:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     282:	c4 81       	ldd	r28, Z+4	; 0x04
     284:	d5 81       	ldd	r29, Z+5	; 0x05
     286:	82 81       	ldd	r24, Z+2	; 0x02
     288:	93 81       	ldd	r25, Z+3	; 0x03
     28a:	9b 83       	std	Y+3, r25	; 0x03
     28c:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     28e:	11 96       	adiw	r26, 0x01	; 1
     290:	8d 91       	ld	r24, X+
     292:	9c 91       	ld	r25, X
     294:	12 97       	sbiw	r26, 0x02	; 2
     296:	e8 17       	cp	r30, r24
     298:	f9 07       	cpc	r31, r25
     29a:	31 f4       	brne	.+12     	; 0x2a8 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     29c:	84 81       	ldd	r24, Z+4	; 0x04
     29e:	95 81       	ldd	r25, Z+5	; 0x05
     2a0:	12 96       	adiw	r26, 0x02	; 2
     2a2:	9c 93       	st	X, r25
     2a4:	8e 93       	st	-X, r24
     2a6:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     2a8:	11 86       	std	Z+9, r1	; 0x09
     2aa:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
     2ac:	8c 91       	ld	r24, X
     2ae:	81 50       	subi	r24, 0x01	; 1
     2b0:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
     2b2:	8c 91       	ld	r24, X
}
     2b4:	df 91       	pop	r29
     2b6:	cf 91       	pop	r28
     2b8:	08 95       	ret

000002ba <task2_code>:
		*/
	}
}
/*Task2 Code */
void task2_code(void*pvParamter)
{
     2ba:	ff cf       	rjmp	.-2      	; 0x2ba <task2_code>

000002bc <task1_code>:

/*Task1 Code  */
void task1_code(void*pvParamter)
{
	
	mutex_handel_1=xSemaphoreCreateMutex();/****************************************there is a problem*********************/
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	0e 94 6d 04 	call	0x8da	; 0x8da <xQueueCreateMutex>
     2c2:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__data_end+0x1>
     2c6:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__data_end>
	if(mutex_handel_1 !=NULL)
     2ca:	89 2b       	or	r24, r25
     2cc:	11 f0       	breq	.+4      	; 0x2d2 <task1_code+0x16>
	{
		PORTB=0x01;
     2ce:	81 e0       	ldi	r24, 0x01	; 1
     2d0:	85 b9       	out	0x05, r24	; 5
     2d2:	ff cf       	rjmp	.-2      	; 0x2d2 <task1_code+0x16>

000002d4 <main>:
void task1_code(void*pvParamter);
void task2_code(void*pvParamter);

int main(void)
{
	DDRB=0XFF;
     2d4:	8f ef       	ldi	r24, 0xFF	; 255
     2d6:	84 b9       	out	0x04, r24	; 4
	PORTB=0X00;
     2d8:	15 b8       	out	0x05, r1	; 5
	DDRD=0XFF;
     2da:	8a b9       	out	0x0a, r24	; 10
	PORTD=0X00;
     2dc:	1b b8       	out	0x0b, r1	; 11
	xTaskCreate(task1_code,"pcTask1",85,task1_handle,TASK1_PRIORITY,NULL);
     2de:	20 91 2a 01 	lds	r18, 0x012A	; 0x80012a <task1_handle>
     2e2:	30 91 2b 01 	lds	r19, 0x012B	; 0x80012b <task1_handle+0x1>
     2e6:	e1 2c       	mov	r14, r1
     2e8:	f1 2c       	mov	r15, r1
     2ea:	00 91 07 01 	lds	r16, 0x0107	; 0x800107 <TASK1_PRIORITY>
     2ee:	45 e5       	ldi	r20, 0x55	; 85
     2f0:	50 e0       	ldi	r21, 0x00	; 0
     2f2:	68 e0       	ldi	r22, 0x08	; 8
     2f4:	71 e0       	ldi	r23, 0x01	; 1
     2f6:	8e e5       	ldi	r24, 0x5E	; 94
     2f8:	91 e0       	ldi	r25, 0x01	; 1
     2fa:	0e 94 2a 06 	call	0xc54	; 0xc54 <xTaskCreate>
	xTaskCreate(task2_code,"pcTask2",85,task2_handle,TASK2_PRIORITY,NULL);
     2fe:	20 91 28 01 	lds	r18, 0x0128	; 0x800128 <task2_handle>
     302:	30 91 29 01 	lds	r19, 0x0129	; 0x800129 <task2_handle+0x1>
     306:	00 91 06 01 	lds	r16, 0x0106	; 0x800106 <TASK2_PRIORITY>
     30a:	45 e5       	ldi	r20, 0x55	; 85
     30c:	50 e0       	ldi	r21, 0x00	; 0
     30e:	60 e1       	ldi	r22, 0x10	; 16
     310:	71 e0       	ldi	r23, 0x01	; 1
     312:	8d e5       	ldi	r24, 0x5D	; 93
     314:	91 e0       	ldi	r25, 0x01	; 1
     316:	0e 94 2a 06 	call	0xc54	; 0xc54 <xTaskCreate>
	
	vTaskStartScheduler();
     31a:	0e 94 46 07 	call	0xe8c	; 0xe8c <vTaskStartScheduler>
     31e:	ff cf       	rjmp	.-2      	; 0x31e <main+0x4a>

00000320 <pxPortInitialiseStack>:
{
    portSAVE_CONTEXT();
    vTaskSwitchContext();
    portRESTORE_CONTEXT();

    __asm__ __volatile__ ( "reti" );
     320:	fc 01       	movw	r30, r24
     322:	60 83       	st	Z, r22
     324:	31 97       	sbiw	r30, 0x01	; 1
     326:	70 83       	st	Z, r23
     328:	31 97       	sbiw	r30, 0x01	; 1
     32a:	10 82       	st	Z, r1
     32c:	31 97       	sbiw	r30, 0x01	; 1
     32e:	20 e8       	ldi	r18, 0x80	; 128
     330:	20 83       	st	Z, r18
     332:	31 97       	sbiw	r30, 0x01	; 1
     334:	10 82       	st	Z, r1
     336:	77 97       	sbiw	r30, 0x17	; 23
     338:	40 83       	st	Z, r20
     33a:	31 97       	sbiw	r30, 0x01	; 1
     33c:	50 83       	st	Z, r21
     33e:	83 97       	sbiw	r24, 0x23	; 35
     340:	08 95       	ret

00000342 <xPortStartScheduler>:
     342:	a8 95       	wdr
     344:	90 ec       	ldi	r25, 0xC0	; 192
     346:	88 e1       	ldi	r24, 0x18	; 24
     348:	0f b6       	in	r0, 0x3f	; 63
     34a:	f8 94       	cli
     34c:	a8 95       	wdr
     34e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7f8060>
     352:	0f be       	out	0x3f, r0	; 63
     354:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7f8060>
     358:	a0 91 91 01 	lds	r26, 0x0191	; 0x800191 <pxCurrentTCB>
     35c:	b0 91 92 01 	lds	r27, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     360:	cd 91       	ld	r28, X+
     362:	cd bf       	out	0x3d, r28	; 61
     364:	dd 91       	ld	r29, X+
     366:	de bf       	out	0x3e, r29	; 62
     368:	ff 91       	pop	r31
     36a:	ef 91       	pop	r30
     36c:	df 91       	pop	r29
     36e:	cf 91       	pop	r28
     370:	bf 91       	pop	r27
     372:	af 91       	pop	r26
     374:	9f 91       	pop	r25
     376:	8f 91       	pop	r24
     378:	7f 91       	pop	r23
     37a:	6f 91       	pop	r22
     37c:	5f 91       	pop	r21
     37e:	4f 91       	pop	r20
     380:	3f 91       	pop	r19
     382:	2f 91       	pop	r18
     384:	1f 91       	pop	r17
     386:	0f 91       	pop	r16
     388:	ff 90       	pop	r15
     38a:	ef 90       	pop	r14
     38c:	df 90       	pop	r13
     38e:	cf 90       	pop	r12
     390:	bf 90       	pop	r11
     392:	af 90       	pop	r10
     394:	9f 90       	pop	r9
     396:	8f 90       	pop	r8
     398:	7f 90       	pop	r7
     39a:	6f 90       	pop	r6
     39c:	5f 90       	pop	r5
     39e:	4f 90       	pop	r4
     3a0:	3f 90       	pop	r3
     3a2:	2f 90       	pop	r2
     3a4:	1f 90       	pop	r1
     3a6:	0f 90       	pop	r0
     3a8:	0f be       	out	0x3f, r0	; 63
     3aa:	0f 90       	pop	r0
     3ac:	08 95       	ret
     3ae:	81 e0       	ldi	r24, 0x01	; 1
     3b0:	08 95       	ret

000003b2 <vPortYield>:
     3b2:	0f 92       	push	r0
     3b4:	0f b6       	in	r0, 0x3f	; 63
     3b6:	f8 94       	cli
     3b8:	0f 92       	push	r0
     3ba:	1f 92       	push	r1
     3bc:	11 24       	eor	r1, r1
     3be:	2f 92       	push	r2
     3c0:	3f 92       	push	r3
     3c2:	4f 92       	push	r4
     3c4:	5f 92       	push	r5
     3c6:	6f 92       	push	r6
     3c8:	7f 92       	push	r7
     3ca:	8f 92       	push	r8
     3cc:	9f 92       	push	r9
     3ce:	af 92       	push	r10
     3d0:	bf 92       	push	r11
     3d2:	cf 92       	push	r12
     3d4:	df 92       	push	r13
     3d6:	ef 92       	push	r14
     3d8:	ff 92       	push	r15
     3da:	0f 93       	push	r16
     3dc:	1f 93       	push	r17
     3de:	2f 93       	push	r18
     3e0:	3f 93       	push	r19
     3e2:	4f 93       	push	r20
     3e4:	5f 93       	push	r21
     3e6:	6f 93       	push	r22
     3e8:	7f 93       	push	r23
     3ea:	8f 93       	push	r24
     3ec:	9f 93       	push	r25
     3ee:	af 93       	push	r26
     3f0:	bf 93       	push	r27
     3f2:	cf 93       	push	r28
     3f4:	df 93       	push	r29
     3f6:	ef 93       	push	r30
     3f8:	ff 93       	push	r31
     3fa:	a0 91 91 01 	lds	r26, 0x0191	; 0x800191 <pxCurrentTCB>
     3fe:	b0 91 92 01 	lds	r27, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     402:	0d b6       	in	r0, 0x3d	; 61
     404:	0d 92       	st	X+, r0
     406:	0e b6       	in	r0, 0x3e	; 62
     408:	0d 92       	st	X+, r0
     40a:	0e 94 c6 08 	call	0x118c	; 0x118c <vTaskSwitchContext>
     40e:	a0 91 91 01 	lds	r26, 0x0191	; 0x800191 <pxCurrentTCB>
     412:	b0 91 92 01 	lds	r27, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     416:	cd 91       	ld	r28, X+
     418:	cd bf       	out	0x3d, r28	; 61
     41a:	dd 91       	ld	r29, X+
     41c:	de bf       	out	0x3e, r29	; 62
     41e:	ff 91       	pop	r31
     420:	ef 91       	pop	r30
     422:	df 91       	pop	r29
     424:	cf 91       	pop	r28
     426:	bf 91       	pop	r27
     428:	af 91       	pop	r26
     42a:	9f 91       	pop	r25
     42c:	8f 91       	pop	r24
     42e:	7f 91       	pop	r23
     430:	6f 91       	pop	r22
     432:	5f 91       	pop	r21
     434:	4f 91       	pop	r20
     436:	3f 91       	pop	r19
     438:	2f 91       	pop	r18
     43a:	1f 91       	pop	r17
     43c:	0f 91       	pop	r16
     43e:	ff 90       	pop	r15
     440:	ef 90       	pop	r14
     442:	df 90       	pop	r13
     444:	cf 90       	pop	r12
     446:	bf 90       	pop	r11
     448:	af 90       	pop	r10
     44a:	9f 90       	pop	r9
     44c:	8f 90       	pop	r8
     44e:	7f 90       	pop	r7
     450:	6f 90       	pop	r6
     452:	5f 90       	pop	r5
     454:	4f 90       	pop	r4
     456:	3f 90       	pop	r3
     458:	2f 90       	pop	r2
     45a:	1f 90       	pop	r1
     45c:	0f 90       	pop	r0
     45e:	0f be       	out	0x3f, r0	; 63
     460:	0f 90       	pop	r0
     462:	08 95       	ret

00000464 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
     464:	0f 92       	push	r0
     466:	0f b6       	in	r0, 0x3f	; 63
     468:	f8 94       	cli
     46a:	0f 92       	push	r0
     46c:	1f 92       	push	r1
     46e:	11 24       	eor	r1, r1
     470:	2f 92       	push	r2
     472:	3f 92       	push	r3
     474:	4f 92       	push	r4
     476:	5f 92       	push	r5
     478:	6f 92       	push	r6
     47a:	7f 92       	push	r7
     47c:	8f 92       	push	r8
     47e:	9f 92       	push	r9
     480:	af 92       	push	r10
     482:	bf 92       	push	r11
     484:	cf 92       	push	r12
     486:	df 92       	push	r13
     488:	ef 92       	push	r14
     48a:	ff 92       	push	r15
     48c:	0f 93       	push	r16
     48e:	1f 93       	push	r17
     490:	2f 93       	push	r18
     492:	3f 93       	push	r19
     494:	4f 93       	push	r20
     496:	5f 93       	push	r21
     498:	6f 93       	push	r22
     49a:	7f 93       	push	r23
     49c:	8f 93       	push	r24
     49e:	9f 93       	push	r25
     4a0:	af 93       	push	r26
     4a2:	bf 93       	push	r27
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	ef 93       	push	r30
     4aa:	ff 93       	push	r31
     4ac:	a0 91 91 01 	lds	r26, 0x0191	; 0x800191 <pxCurrentTCB>
     4b0:	b0 91 92 01 	lds	r27, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     4b4:	0d b6       	in	r0, 0x3d	; 61
     4b6:	0d 92       	st	X+, r0
     4b8:	0e b6       	in	r0, 0x3e	; 62
     4ba:	0d 92       	st	X+, r0
    sleep_reset();        /* reset the sleep_mode() faster than sleep_disable(); */
     4bc:	13 be       	out	0x33, r1	; 51
    if( xTaskIncrementTick() != pdFALSE )
     4be:	0e 94 84 07 	call	0xf08	; 0xf08 <xTaskIncrementTick>
     4c2:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
     4c4:	0e 94 c6 08 	call	0x118c	; 0x118c <vTaskSwitchContext>
    }
    portRESTORE_CONTEXT();
     4c8:	a0 91 91 01 	lds	r26, 0x0191	; 0x800191 <pxCurrentTCB>
     4cc:	b0 91 92 01 	lds	r27, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     4d0:	cd 91       	ld	r28, X+
     4d2:	cd bf       	out	0x3d, r28	; 61
     4d4:	dd 91       	ld	r29, X+
     4d6:	de bf       	out	0x3e, r29	; 62
     4d8:	ff 91       	pop	r31
     4da:	ef 91       	pop	r30
     4dc:	df 91       	pop	r29
     4de:	cf 91       	pop	r28
     4e0:	bf 91       	pop	r27
     4e2:	af 91       	pop	r26
     4e4:	9f 91       	pop	r25
     4e6:	8f 91       	pop	r24
     4e8:	7f 91       	pop	r23
     4ea:	6f 91       	pop	r22
     4ec:	5f 91       	pop	r21
     4ee:	4f 91       	pop	r20
     4f0:	3f 91       	pop	r19
     4f2:	2f 91       	pop	r18
     4f4:	1f 91       	pop	r17
     4f6:	0f 91       	pop	r16
     4f8:	ff 90       	pop	r15
     4fa:	ef 90       	pop	r14
     4fc:	df 90       	pop	r13
     4fe:	cf 90       	pop	r12
     500:	bf 90       	pop	r11
     502:	af 90       	pop	r10
     504:	9f 90       	pop	r9
     506:	8f 90       	pop	r8
     508:	7f 90       	pop	r7
     50a:	6f 90       	pop	r6
     50c:	5f 90       	pop	r5
     50e:	4f 90       	pop	r4
     510:	3f 90       	pop	r3
     512:	2f 90       	pop	r2
     514:	1f 90       	pop	r1
     516:	0f 90       	pop	r0
     518:	0f be       	out	0x3f, r0	; 63
     51a:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
     51c:	08 95       	ret

0000051e <__vector_12>:
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
/*  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
 */
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
     51e:	0e 94 32 02 	call	0x464	; 0x464 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
     522:	18 95       	reti

00000524 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     524:	0f b6       	in	r0, 0x3f	; 63
     526:	f8 94       	cli
     528:	0f 92       	push	r0
     52a:	fc 01       	movw	r30, r24
     52c:	92 8d       	ldd	r25, Z+26	; 0x1a
     52e:	0f 90       	pop	r0
     530:	0f be       	out	0x3f, r0	; 63
     532:	81 e0       	ldi	r24, 0x01	; 1
     534:	91 11       	cpse	r25, r1
     536:	80 e0       	ldi	r24, 0x00	; 0
     538:	08 95       	ret

0000053a <prvCopyDataToQueue>:
     53a:	0f 93       	push	r16
     53c:	1f 93       	push	r17
     53e:	cf 93       	push	r28
     540:	df 93       	push	r29
     542:	ec 01       	movw	r28, r24
     544:	04 2f       	mov	r16, r20
     546:	1a 8d       	ldd	r17, Y+26	; 0x1a
     548:	4c 8d       	ldd	r20, Y+28	; 0x1c
     54a:	41 11       	cpse	r20, r1
     54c:	0c c0       	rjmp	.+24     	; 0x566 <prvCopyDataToQueue+0x2c>
     54e:	88 81       	ld	r24, Y
     550:	99 81       	ldd	r25, Y+1	; 0x01
     552:	89 2b       	or	r24, r25
     554:	09 f0       	breq	.+2      	; 0x558 <prvCopyDataToQueue+0x1e>
     556:	42 c0       	rjmp	.+132    	; 0x5dc <prvCopyDataToQueue+0xa2>
     558:	8c 81       	ldd	r24, Y+4	; 0x04
     55a:	9d 81       	ldd	r25, Y+5	; 0x05
     55c:	0e 94 0d 0a 	call	0x141a	; 0x141a <xTaskPriorityDisinherit>
     560:	1d 82       	std	Y+5, r1	; 0x05
     562:	1c 82       	std	Y+4, r1	; 0x04
     564:	42 c0       	rjmp	.+132    	; 0x5ea <prvCopyDataToQueue+0xb0>
     566:	01 11       	cpse	r16, r1
     568:	17 c0       	rjmp	.+46     	; 0x598 <prvCopyDataToQueue+0x5e>
     56a:	50 e0       	ldi	r21, 0x00	; 0
     56c:	8a 81       	ldd	r24, Y+2	; 0x02
     56e:	9b 81       	ldd	r25, Y+3	; 0x03
     570:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <memcpy>
     574:	2c 8d       	ldd	r18, Y+28	; 0x1c
     576:	8a 81       	ldd	r24, Y+2	; 0x02
     578:	9b 81       	ldd	r25, Y+3	; 0x03
     57a:	82 0f       	add	r24, r18
     57c:	91 1d       	adc	r25, r1
     57e:	9b 83       	std	Y+3, r25	; 0x03
     580:	8a 83       	std	Y+2, r24	; 0x02
     582:	2c 81       	ldd	r18, Y+4	; 0x04
     584:	3d 81       	ldd	r19, Y+5	; 0x05
     586:	82 17       	cp	r24, r18
     588:	93 07       	cpc	r25, r19
     58a:	50 f1       	brcs	.+84     	; 0x5e0 <prvCopyDataToQueue+0xa6>
     58c:	88 81       	ld	r24, Y
     58e:	99 81       	ldd	r25, Y+1	; 0x01
     590:	9b 83       	std	Y+3, r25	; 0x03
     592:	8a 83       	std	Y+2, r24	; 0x02
     594:	80 e0       	ldi	r24, 0x00	; 0
     596:	29 c0       	rjmp	.+82     	; 0x5ea <prvCopyDataToQueue+0xb0>
     598:	50 e0       	ldi	r21, 0x00	; 0
     59a:	8e 81       	ldd	r24, Y+6	; 0x06
     59c:	9f 81       	ldd	r25, Y+7	; 0x07
     59e:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <memcpy>
     5a2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	91 95       	neg	r25
     5a8:	81 95       	neg	r24
     5aa:	91 09       	sbc	r25, r1
     5ac:	2e 81       	ldd	r18, Y+6	; 0x06
     5ae:	3f 81       	ldd	r19, Y+7	; 0x07
     5b0:	28 0f       	add	r18, r24
     5b2:	39 1f       	adc	r19, r25
     5b4:	3f 83       	std	Y+7, r19	; 0x07
     5b6:	2e 83       	std	Y+6, r18	; 0x06
     5b8:	48 81       	ld	r20, Y
     5ba:	59 81       	ldd	r21, Y+1	; 0x01
     5bc:	24 17       	cp	r18, r20
     5be:	35 07       	cpc	r19, r21
     5c0:	30 f4       	brcc	.+12     	; 0x5ce <prvCopyDataToQueue+0x94>
     5c2:	2c 81       	ldd	r18, Y+4	; 0x04
     5c4:	3d 81       	ldd	r19, Y+5	; 0x05
     5c6:	82 0f       	add	r24, r18
     5c8:	93 1f       	adc	r25, r19
     5ca:	9f 83       	std	Y+7, r25	; 0x07
     5cc:	8e 83       	std	Y+6, r24	; 0x06
     5ce:	02 30       	cpi	r16, 0x02	; 2
     5d0:	49 f4       	brne	.+18     	; 0x5e4 <prvCopyDataToQueue+0xaa>
     5d2:	11 23       	and	r17, r17
     5d4:	49 f0       	breq	.+18     	; 0x5e8 <prvCopyDataToQueue+0xae>
     5d6:	11 50       	subi	r17, 0x01	; 1
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	07 c0       	rjmp	.+14     	; 0x5ea <prvCopyDataToQueue+0xb0>
     5dc:	80 e0       	ldi	r24, 0x00	; 0
     5de:	05 c0       	rjmp	.+10     	; 0x5ea <prvCopyDataToQueue+0xb0>
     5e0:	80 e0       	ldi	r24, 0x00	; 0
     5e2:	03 c0       	rjmp	.+6      	; 0x5ea <prvCopyDataToQueue+0xb0>
     5e4:	80 e0       	ldi	r24, 0x00	; 0
     5e6:	01 c0       	rjmp	.+2      	; 0x5ea <prvCopyDataToQueue+0xb0>
     5e8:	80 e0       	ldi	r24, 0x00	; 0
     5ea:	1f 5f       	subi	r17, 0xFF	; 255
     5ec:	1a 8f       	std	Y+26, r17	; 0x1a
     5ee:	df 91       	pop	r29
     5f0:	cf 91       	pop	r28
     5f2:	1f 91       	pop	r17
     5f4:	0f 91       	pop	r16
     5f6:	08 95       	ret

000005f8 <prvCopyDataFromQueue>:
     5f8:	fc 01       	movw	r30, r24
     5fa:	44 8d       	ldd	r20, Z+28	; 0x1c
     5fc:	44 23       	and	r20, r20
     5fe:	a9 f0       	breq	.+42     	; 0x62a <prvCopyDataFromQueue+0x32>
     600:	50 e0       	ldi	r21, 0x00	; 0
     602:	26 81       	ldd	r18, Z+6	; 0x06
     604:	37 81       	ldd	r19, Z+7	; 0x07
     606:	24 0f       	add	r18, r20
     608:	35 1f       	adc	r19, r21
     60a:	37 83       	std	Z+7, r19	; 0x07
     60c:	26 83       	std	Z+6, r18	; 0x06
     60e:	84 81       	ldd	r24, Z+4	; 0x04
     610:	95 81       	ldd	r25, Z+5	; 0x05
     612:	28 17       	cp	r18, r24
     614:	39 07       	cpc	r19, r25
     616:	20 f0       	brcs	.+8      	; 0x620 <prvCopyDataFromQueue+0x28>
     618:	80 81       	ld	r24, Z
     61a:	91 81       	ldd	r25, Z+1	; 0x01
     61c:	97 83       	std	Z+7, r25	; 0x07
     61e:	86 83       	std	Z+6, r24	; 0x06
     620:	cb 01       	movw	r24, r22
     622:	66 81       	ldd	r22, Z+6	; 0x06
     624:	77 81       	ldd	r23, Z+7	; 0x07
     626:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <memcpy>
     62a:	08 95       	ret

0000062c <prvUnlockQueue>:
     62c:	ef 92       	push	r14
     62e:	ff 92       	push	r15
     630:	0f 93       	push	r16
     632:	1f 93       	push	r17
     634:	cf 93       	push	r28
     636:	8c 01       	movw	r16, r24
     638:	0f b6       	in	r0, 0x3f	; 63
     63a:	f8 94       	cli
     63c:	0f 92       	push	r0
     63e:	fc 01       	movw	r30, r24
     640:	c6 8d       	ldd	r28, Z+30	; 0x1e
     642:	1c 16       	cp	r1, r28
     644:	ac f4       	brge	.+42     	; 0x670 <prvUnlockQueue+0x44>
     646:	81 89       	ldd	r24, Z+17	; 0x11
     648:	81 11       	cpse	r24, r1
     64a:	06 c0       	rjmp	.+12     	; 0x658 <prvUnlockQueue+0x2c>
     64c:	11 c0       	rjmp	.+34     	; 0x670 <prvUnlockQueue+0x44>
     64e:	f8 01       	movw	r30, r16
     650:	81 89       	ldd	r24, Z+17	; 0x11
     652:	81 11       	cpse	r24, r1
     654:	05 c0       	rjmp	.+10     	; 0x660 <prvUnlockQueue+0x34>
     656:	0c c0       	rjmp	.+24     	; 0x670 <prvUnlockQueue+0x44>
     658:	78 01       	movw	r14, r16
     65a:	f1 e1       	ldi	r31, 0x11	; 17
     65c:	ef 0e       	add	r14, r31
     65e:	f1 1c       	adc	r15, r1
     660:	c7 01       	movw	r24, r14
     662:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xTaskRemoveFromEventList>
     666:	81 11       	cpse	r24, r1
     668:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vTaskMissedYield>
     66c:	c1 50       	subi	r28, 0x01	; 1
     66e:	79 f7       	brne	.-34     	; 0x64e <prvUnlockQueue+0x22>
     670:	8f ef       	ldi	r24, 0xFF	; 255
     672:	f8 01       	movw	r30, r16
     674:	86 8f       	std	Z+30, r24	; 0x1e
     676:	0f 90       	pop	r0
     678:	0f be       	out	0x3f, r0	; 63
     67a:	0f b6       	in	r0, 0x3f	; 63
     67c:	f8 94       	cli
     67e:	0f 92       	push	r0
     680:	c5 8d       	ldd	r28, Z+29	; 0x1d
     682:	1c 16       	cp	r1, r28
     684:	ac f4       	brge	.+42     	; 0x6b0 <prvUnlockQueue+0x84>
     686:	80 85       	ldd	r24, Z+8	; 0x08
     688:	81 11       	cpse	r24, r1
     68a:	06 c0       	rjmp	.+12     	; 0x698 <prvUnlockQueue+0x6c>
     68c:	11 c0       	rjmp	.+34     	; 0x6b0 <prvUnlockQueue+0x84>
     68e:	f8 01       	movw	r30, r16
     690:	80 85       	ldd	r24, Z+8	; 0x08
     692:	81 11       	cpse	r24, r1
     694:	05 c0       	rjmp	.+10     	; 0x6a0 <prvUnlockQueue+0x74>
     696:	0c c0       	rjmp	.+24     	; 0x6b0 <prvUnlockQueue+0x84>
     698:	78 01       	movw	r14, r16
     69a:	f8 e0       	ldi	r31, 0x08	; 8
     69c:	ef 0e       	add	r14, r31
     69e:	f1 1c       	adc	r15, r1
     6a0:	c7 01       	movw	r24, r14
     6a2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xTaskRemoveFromEventList>
     6a6:	81 11       	cpse	r24, r1
     6a8:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vTaskMissedYield>
     6ac:	c1 50       	subi	r28, 0x01	; 1
     6ae:	79 f7       	brne	.-34     	; 0x68e <prvUnlockQueue+0x62>
     6b0:	8f ef       	ldi	r24, 0xFF	; 255
     6b2:	f8 01       	movw	r30, r16
     6b4:	85 8f       	std	Z+29, r24	; 0x1d
     6b6:	0f 90       	pop	r0
     6b8:	0f be       	out	0x3f, r0	; 63
     6ba:	cf 91       	pop	r28
     6bc:	1f 91       	pop	r17
     6be:	0f 91       	pop	r16
     6c0:	ff 90       	pop	r15
     6c2:	ef 90       	pop	r14
     6c4:	08 95       	ret

000006c6 <xQueueGenericReset>:
     6c6:	cf 93       	push	r28
     6c8:	df 93       	push	r29
     6ca:	ec 01       	movw	r28, r24
     6cc:	0f b6       	in	r0, 0x3f	; 63
     6ce:	f8 94       	cli
     6d0:	0f 92       	push	r0
     6d2:	e8 81       	ld	r30, Y
     6d4:	f9 81       	ldd	r31, Y+1	; 0x01
     6d6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     6d8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6da:	90 e0       	ldi	r25, 0x00	; 0
     6dc:	30 e0       	ldi	r19, 0x00	; 0
     6de:	82 9f       	mul	r24, r18
     6e0:	a0 01       	movw	r20, r0
     6e2:	83 9f       	mul	r24, r19
     6e4:	50 0d       	add	r21, r0
     6e6:	92 9f       	mul	r25, r18
     6e8:	50 0d       	add	r21, r0
     6ea:	11 24       	eor	r1, r1
     6ec:	4e 0f       	add	r20, r30
     6ee:	5f 1f       	adc	r21, r31
     6f0:	5d 83       	std	Y+5, r21	; 0x05
     6f2:	4c 83       	std	Y+4, r20	; 0x04
     6f4:	1a 8e       	std	Y+26, r1	; 0x1a
     6f6:	fb 83       	std	Y+3, r31	; 0x03
     6f8:	ea 83       	std	Y+2, r30	; 0x02
     6fa:	01 97       	sbiw	r24, 0x01	; 1
     6fc:	82 9f       	mul	r24, r18
     6fe:	a0 01       	movw	r20, r0
     700:	83 9f       	mul	r24, r19
     702:	50 0d       	add	r21, r0
     704:	92 9f       	mul	r25, r18
     706:	50 0d       	add	r21, r0
     708:	11 24       	eor	r1, r1
     70a:	cf 01       	movw	r24, r30
     70c:	84 0f       	add	r24, r20
     70e:	95 1f       	adc	r25, r21
     710:	9f 83       	std	Y+7, r25	; 0x07
     712:	8e 83       	std	Y+6, r24	; 0x06
     714:	8f ef       	ldi	r24, 0xFF	; 255
     716:	8d 8f       	std	Y+29, r24	; 0x1d
     718:	8e 8f       	std	Y+30, r24	; 0x1e
     71a:	61 11       	cpse	r22, r1
     71c:	0c c0       	rjmp	.+24     	; 0x736 <xQueueGenericReset+0x70>
     71e:	88 85       	ldd	r24, Y+8	; 0x08
     720:	88 23       	and	r24, r24
     722:	89 f0       	breq	.+34     	; 0x746 <xQueueGenericReset+0x80>
     724:	ce 01       	movw	r24, r28
     726:	08 96       	adiw	r24, 0x08	; 8
     728:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xTaskRemoveFromEventList>
     72c:	88 23       	and	r24, r24
     72e:	59 f0       	breq	.+22     	; 0x746 <xQueueGenericReset+0x80>
     730:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
     734:	08 c0       	rjmp	.+16     	; 0x746 <xQueueGenericReset+0x80>
     736:	ce 01       	movw	r24, r28
     738:	08 96       	adiw	r24, 0x08	; 8
     73a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     73e:	ce 01       	movw	r24, r28
     740:	41 96       	adiw	r24, 0x11	; 17
     742:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     746:	0f 90       	pop	r0
     748:	0f be       	out	0x3f, r0	; 63
     74a:	81 e0       	ldi	r24, 0x01	; 1
     74c:	df 91       	pop	r29
     74e:	cf 91       	pop	r28
     750:	08 95       	ret

00000752 <xQueueGenericCreate>:
     752:	0f 93       	push	r16
     754:	1f 93       	push	r17
     756:	cf 93       	push	r28
     758:	df 93       	push	r29
     75a:	08 2f       	mov	r16, r24
     75c:	16 2f       	mov	r17, r22
     75e:	86 9f       	mul	r24, r22
     760:	c0 01       	movw	r24, r0
     762:	11 24       	eor	r1, r1
     764:	4f 96       	adiw	r24, 0x1f	; 31
     766:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     76a:	ec 01       	movw	r28, r24
     76c:	00 97       	sbiw	r24, 0x00	; 0
     76e:	71 f0       	breq	.+28     	; 0x78c <xQueueGenericCreate+0x3a>
     770:	11 11       	cpse	r17, r1
     772:	03 c0       	rjmp	.+6      	; 0x77a <xQueueGenericCreate+0x28>
     774:	99 83       	std	Y+1, r25	; 0x01
     776:	88 83       	st	Y, r24
     778:	03 c0       	rjmp	.+6      	; 0x780 <xQueueGenericCreate+0x2e>
     77a:	4f 96       	adiw	r24, 0x1f	; 31
     77c:	99 83       	std	Y+1, r25	; 0x01
     77e:	88 83       	st	Y, r24
     780:	0b 8f       	std	Y+27, r16	; 0x1b
     782:	1c 8f       	std	Y+28, r17	; 0x1c
     784:	61 e0       	ldi	r22, 0x01	; 1
     786:	ce 01       	movw	r24, r28
     788:	0e 94 63 03 	call	0x6c6	; 0x6c6 <xQueueGenericReset>
     78c:	ce 01       	movw	r24, r28
     78e:	df 91       	pop	r29
     790:	cf 91       	pop	r28
     792:	1f 91       	pop	r17
     794:	0f 91       	pop	r16
     796:	08 95       	ret

00000798 <xQueueGenericSend>:
     798:	9f 92       	push	r9
     79a:	af 92       	push	r10
     79c:	bf 92       	push	r11
     79e:	cf 92       	push	r12
     7a0:	df 92       	push	r13
     7a2:	ef 92       	push	r14
     7a4:	ff 92       	push	r15
     7a6:	0f 93       	push	r16
     7a8:	1f 93       	push	r17
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
     7ae:	00 d0       	rcall	.+0      	; 0x7b0 <xQueueGenericSend+0x18>
     7b0:	00 d0       	rcall	.+0      	; 0x7b2 <xQueueGenericSend+0x1a>
     7b2:	1f 92       	push	r1
     7b4:	cd b7       	in	r28, 0x3d	; 61
     7b6:	de b7       	in	r29, 0x3e	; 62
     7b8:	8c 01       	movw	r16, r24
     7ba:	6b 01       	movw	r12, r22
     7bc:	5d 83       	std	Y+5, r21	; 0x05
     7be:	4c 83       	std	Y+4, r20	; 0x04
     7c0:	a2 2e       	mov	r10, r18
     7c2:	b1 2c       	mov	r11, r1
     7c4:	99 24       	eor	r9, r9
     7c6:	93 94       	inc	r9
     7c8:	7c 01       	movw	r14, r24
     7ca:	88 e0       	ldi	r24, 0x08	; 8
     7cc:	e8 0e       	add	r14, r24
     7ce:	f1 1c       	adc	r15, r1
     7d0:	0f b6       	in	r0, 0x3f	; 63
     7d2:	f8 94       	cli
     7d4:	0f 92       	push	r0
     7d6:	f8 01       	movw	r30, r16
     7d8:	92 8d       	ldd	r25, Z+26	; 0x1a
     7da:	83 8d       	ldd	r24, Z+27	; 0x1b
     7dc:	98 17       	cp	r25, r24
     7de:	18 f0       	brcs	.+6      	; 0x7e6 <xQueueGenericSend+0x4e>
     7e0:	f2 e0       	ldi	r31, 0x02	; 2
     7e2:	af 12       	cpse	r10, r31
     7e4:	19 c0       	rjmp	.+50     	; 0x818 <xQueueGenericSend+0x80>
     7e6:	4a 2d       	mov	r20, r10
     7e8:	b6 01       	movw	r22, r12
     7ea:	c8 01       	movw	r24, r16
     7ec:	0e 94 9d 02 	call	0x53a	; 0x53a <prvCopyDataToQueue>
     7f0:	f8 01       	movw	r30, r16
     7f2:	91 89       	ldd	r25, Z+17	; 0x11
     7f4:	99 23       	and	r25, r25
     7f6:	49 f0       	breq	.+18     	; 0x80a <xQueueGenericSend+0x72>
     7f8:	c8 01       	movw	r24, r16
     7fa:	41 96       	adiw	r24, 0x11	; 17
     7fc:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xTaskRemoveFromEventList>
     800:	88 23       	and	r24, r24
     802:	31 f0       	breq	.+12     	; 0x810 <xQueueGenericSend+0x78>
     804:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
     808:	03 c0       	rjmp	.+6      	; 0x810 <xQueueGenericSend+0x78>
     80a:	81 11       	cpse	r24, r1
     80c:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
     810:	0f 90       	pop	r0
     812:	0f be       	out	0x3f, r0	; 63
     814:	81 e0       	ldi	r24, 0x01	; 1
     816:	50 c0       	rjmp	.+160    	; 0x8b8 <xQueueGenericSend+0x120>
     818:	8c 81       	ldd	r24, Y+4	; 0x04
     81a:	9d 81       	ldd	r25, Y+5	; 0x05
     81c:	89 2b       	or	r24, r25
     81e:	21 f4       	brne	.+8      	; 0x828 <xQueueGenericSend+0x90>
     820:	0f 90       	pop	r0
     822:	0f be       	out	0x3f, r0	; 63
     824:	80 e0       	ldi	r24, 0x00	; 0
     826:	48 c0       	rjmp	.+144    	; 0x8b8 <xQueueGenericSend+0x120>
     828:	b1 10       	cpse	r11, r1
     82a:	05 c0       	rjmp	.+10     	; 0x836 <xQueueGenericSend+0x9e>
     82c:	ce 01       	movw	r24, r28
     82e:	01 96       	adiw	r24, 0x01	; 1
     830:	0e 94 ba 09 	call	0x1374	; 0x1374 <vTaskInternalSetTimeOutState>
     834:	b9 2c       	mov	r11, r9
     836:	0f 90       	pop	r0
     838:	0f be       	out	0x3f, r0	; 63
     83a:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
     83e:	0f b6       	in	r0, 0x3f	; 63
     840:	f8 94       	cli
     842:	0f 92       	push	r0
     844:	f8 01       	movw	r30, r16
     846:	85 8d       	ldd	r24, Z+29	; 0x1d
     848:	8f 3f       	cpi	r24, 0xFF	; 255
     84a:	09 f4       	brne	.+2      	; 0x84e <xQueueGenericSend+0xb6>
     84c:	15 8e       	std	Z+29, r1	; 0x1d
     84e:	f8 01       	movw	r30, r16
     850:	86 8d       	ldd	r24, Z+30	; 0x1e
     852:	8f 3f       	cpi	r24, 0xFF	; 255
     854:	09 f4       	brne	.+2      	; 0x858 <xQueueGenericSend+0xc0>
     856:	16 8e       	std	Z+30, r1	; 0x1e
     858:	0f 90       	pop	r0
     85a:	0f be       	out	0x3f, r0	; 63
     85c:	be 01       	movw	r22, r28
     85e:	6c 5f       	subi	r22, 0xFC	; 252
     860:	7f 4f       	sbci	r23, 0xFF	; 255
     862:	ce 01       	movw	r24, r28
     864:	01 96       	adiw	r24, 0x01	; 1
     866:	0e 94 c5 09 	call	0x138a	; 0x138a <xTaskCheckForTimeOut>
     86a:	81 11       	cpse	r24, r1
     86c:	1f c0       	rjmp	.+62     	; 0x8ac <xQueueGenericSend+0x114>
     86e:	0f b6       	in	r0, 0x3f	; 63
     870:	f8 94       	cli
     872:	0f 92       	push	r0
     874:	f8 01       	movw	r30, r16
     876:	92 8d       	ldd	r25, Z+26	; 0x1a
     878:	83 8d       	ldd	r24, Z+27	; 0x1b
     87a:	0f 90       	pop	r0
     87c:	0f be       	out	0x3f, r0	; 63
     87e:	98 13       	cpse	r25, r24
     880:	0f c0       	rjmp	.+30     	; 0x8a0 <xQueueGenericSend+0x108>
     882:	6c 81       	ldd	r22, Y+4	; 0x04
     884:	7d 81       	ldd	r23, Y+5	; 0x05
     886:	c7 01       	movw	r24, r14
     888:	0e 94 47 09 	call	0x128e	; 0x128e <vTaskPlaceOnEventList>
     88c:	c8 01       	movw	r24, r16
     88e:	0e 94 16 03 	call	0x62c	; 0x62c <prvUnlockQueue>
     892:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
     896:	81 11       	cpse	r24, r1
     898:	9b cf       	rjmp	.-202    	; 0x7d0 <xQueueGenericSend+0x38>
     89a:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
     89e:	98 cf       	rjmp	.-208    	; 0x7d0 <xQueueGenericSend+0x38>
     8a0:	c8 01       	movw	r24, r16
     8a2:	0e 94 16 03 	call	0x62c	; 0x62c <prvUnlockQueue>
     8a6:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
     8aa:	92 cf       	rjmp	.-220    	; 0x7d0 <xQueueGenericSend+0x38>
     8ac:	c8 01       	movw	r24, r16
     8ae:	0e 94 16 03 	call	0x62c	; 0x62c <prvUnlockQueue>
     8b2:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
     8b6:	80 e0       	ldi	r24, 0x00	; 0
     8b8:	0f 90       	pop	r0
     8ba:	0f 90       	pop	r0
     8bc:	0f 90       	pop	r0
     8be:	0f 90       	pop	r0
     8c0:	0f 90       	pop	r0
     8c2:	df 91       	pop	r29
     8c4:	cf 91       	pop	r28
     8c6:	1f 91       	pop	r17
     8c8:	0f 91       	pop	r16
     8ca:	ff 90       	pop	r15
     8cc:	ef 90       	pop	r14
     8ce:	df 90       	pop	r13
     8d0:	cf 90       	pop	r12
     8d2:	bf 90       	pop	r11
     8d4:	af 90       	pop	r10
     8d6:	9f 90       	pop	r9
     8d8:	08 95       	ret

000008da <xQueueCreateMutex>:
     8da:	cf 93       	push	r28
     8dc:	df 93       	push	r29
     8de:	48 2f       	mov	r20, r24
     8e0:	60 e0       	ldi	r22, 0x00	; 0
     8e2:	81 e0       	ldi	r24, 0x01	; 1
     8e4:	0e 94 a9 03 	call	0x752	; 0x752 <xQueueGenericCreate>
     8e8:	ec 01       	movw	r28, r24
     8ea:	00 97       	sbiw	r24, 0x00	; 0
     8ec:	61 f0       	breq	.+24     	; 0x906 <xQueueCreateMutex+0x2c>
     8ee:	1d 82       	std	Y+5, r1	; 0x05
     8f0:	1c 82       	std	Y+4, r1	; 0x04
     8f2:	19 82       	std	Y+1, r1	; 0x01
     8f4:	18 82       	st	Y, r1
     8f6:	1e 82       	std	Y+6, r1	; 0x06
     8f8:	20 e0       	ldi	r18, 0x00	; 0
     8fa:	40 e0       	ldi	r20, 0x00	; 0
     8fc:	50 e0       	ldi	r21, 0x00	; 0
     8fe:	60 e0       	ldi	r22, 0x00	; 0
     900:	70 e0       	ldi	r23, 0x00	; 0
     902:	0e 94 cc 03 	call	0x798	; 0x798 <xQueueGenericSend>
     906:	ce 01       	movw	r24, r28
     908:	df 91       	pop	r29
     90a:	cf 91       	pop	r28
     90c:	08 95       	ret

0000090e <xQueueGenericSendFromISR>:
     90e:	ef 92       	push	r14
     910:	ff 92       	push	r15
     912:	0f 93       	push	r16
     914:	1f 93       	push	r17
     916:	cf 93       	push	r28
     918:	df 93       	push	r29
     91a:	8a 01       	movw	r16, r20
     91c:	fc 01       	movw	r30, r24
     91e:	52 8d       	ldd	r21, Z+26	; 0x1a
     920:	33 8d       	ldd	r19, Z+27	; 0x1b
     922:	53 17       	cp	r21, r19
     924:	10 f0       	brcs	.+4      	; 0x92a <xQueueGenericSendFromISR+0x1c>
     926:	22 30       	cpi	r18, 0x02	; 2
     928:	01 f5       	brne	.+64     	; 0x96a <xQueueGenericSendFromISR+0x5c>
     92a:	42 2f       	mov	r20, r18
     92c:	78 01       	movw	r14, r16
     92e:	ec 01       	movw	r28, r24
     930:	1e 8d       	ldd	r17, Y+30	; 0x1e
     932:	8a 8d       	ldd	r24, Y+26	; 0x1a
     934:	ce 01       	movw	r24, r28
     936:	0e 94 9d 02 	call	0x53a	; 0x53a <prvCopyDataToQueue>
     93a:	1f 3f       	cpi	r17, 0xFF	; 255
     93c:	81 f4       	brne	.+32     	; 0x95e <xQueueGenericSendFromISR+0x50>
     93e:	89 89       	ldd	r24, Y+17	; 0x11
     940:	88 23       	and	r24, r24
     942:	a9 f0       	breq	.+42     	; 0x96e <xQueueGenericSendFromISR+0x60>
     944:	ce 01       	movw	r24, r28
     946:	41 96       	adiw	r24, 0x11	; 17
     948:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xTaskRemoveFromEventList>
     94c:	88 23       	and	r24, r24
     94e:	89 f0       	breq	.+34     	; 0x972 <xQueueGenericSendFromISR+0x64>
     950:	e1 14       	cp	r14, r1
     952:	f1 04       	cpc	r15, r1
     954:	81 f0       	breq	.+32     	; 0x976 <xQueueGenericSendFromISR+0x68>
     956:	81 e0       	ldi	r24, 0x01	; 1
     958:	f7 01       	movw	r30, r14
     95a:	80 83       	st	Z, r24
     95c:	0d c0       	rjmp	.+26     	; 0x978 <xQueueGenericSendFromISR+0x6a>
     95e:	ff 24       	eor	r15, r15
     960:	f3 94       	inc	r15
     962:	f1 0e       	add	r15, r17
     964:	fe 8e       	std	Y+30, r15	; 0x1e
     966:	81 e0       	ldi	r24, 0x01	; 1
     968:	07 c0       	rjmp	.+14     	; 0x978 <xQueueGenericSendFromISR+0x6a>
     96a:	80 e0       	ldi	r24, 0x00	; 0
     96c:	05 c0       	rjmp	.+10     	; 0x978 <xQueueGenericSendFromISR+0x6a>
     96e:	81 e0       	ldi	r24, 0x01	; 1
     970:	03 c0       	rjmp	.+6      	; 0x978 <xQueueGenericSendFromISR+0x6a>
     972:	81 e0       	ldi	r24, 0x01	; 1
     974:	01 c0       	rjmp	.+2      	; 0x978 <xQueueGenericSendFromISR+0x6a>
     976:	81 e0       	ldi	r24, 0x01	; 1
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	1f 91       	pop	r17
     97e:	0f 91       	pop	r16
     980:	ff 90       	pop	r15
     982:	ef 90       	pop	r14
     984:	08 95       	ret

00000986 <xQueueReceive>:
     986:	9f 92       	push	r9
     988:	af 92       	push	r10
     98a:	bf 92       	push	r11
     98c:	cf 92       	push	r12
     98e:	df 92       	push	r13
     990:	ef 92       	push	r14
     992:	ff 92       	push	r15
     994:	0f 93       	push	r16
     996:	1f 93       	push	r17
     998:	cf 93       	push	r28
     99a:	df 93       	push	r29
     99c:	00 d0       	rcall	.+0      	; 0x99e <xQueueReceive+0x18>
     99e:	00 d0       	rcall	.+0      	; 0x9a0 <xQueueReceive+0x1a>
     9a0:	1f 92       	push	r1
     9a2:	cd b7       	in	r28, 0x3d	; 61
     9a4:	de b7       	in	r29, 0x3e	; 62
     9a6:	8c 01       	movw	r16, r24
     9a8:	5b 01       	movw	r10, r22
     9aa:	5d 83       	std	Y+5, r21	; 0x05
     9ac:	4c 83       	std	Y+4, r20	; 0x04
     9ae:	e1 2c       	mov	r14, r1
     9b0:	99 24       	eor	r9, r9
     9b2:	93 94       	inc	r9
     9b4:	6c 01       	movw	r12, r24
     9b6:	81 e1       	ldi	r24, 0x11	; 17
     9b8:	c8 0e       	add	r12, r24
     9ba:	d1 1c       	adc	r13, r1
     9bc:	0f b6       	in	r0, 0x3f	; 63
     9be:	f8 94       	cli
     9c0:	0f 92       	push	r0
     9c2:	f8 01       	movw	r30, r16
     9c4:	f2 8c       	ldd	r15, Z+26	; 0x1a
     9c6:	ff 20       	and	r15, r15
     9c8:	a9 f0       	breq	.+42     	; 0x9f4 <xQueueReceive+0x6e>
     9ca:	b5 01       	movw	r22, r10
     9cc:	c8 01       	movw	r24, r16
     9ce:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <prvCopyDataFromQueue>
     9d2:	fa 94       	dec	r15
     9d4:	f8 01       	movw	r30, r16
     9d6:	f2 8e       	std	Z+26, r15	; 0x1a
     9d8:	80 85       	ldd	r24, Z+8	; 0x08
     9da:	88 23       	and	r24, r24
     9dc:	39 f0       	breq	.+14     	; 0x9ec <xQueueReceive+0x66>
     9de:	c8 01       	movw	r24, r16
     9e0:	08 96       	adiw	r24, 0x08	; 8
     9e2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xTaskRemoveFromEventList>
     9e6:	81 11       	cpse	r24, r1
     9e8:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
     9ec:	0f 90       	pop	r0
     9ee:	0f be       	out	0x3f, r0	; 63
     9f0:	81 e0       	ldi	r24, 0x01	; 1
     9f2:	51 c0       	rjmp	.+162    	; 0xa96 <__DATA_REGION_LENGTH__+0x96>
     9f4:	8c 81       	ldd	r24, Y+4	; 0x04
     9f6:	9d 81       	ldd	r25, Y+5	; 0x05
     9f8:	89 2b       	or	r24, r25
     9fa:	21 f4       	brne	.+8      	; 0xa04 <__DATA_REGION_LENGTH__+0x4>
     9fc:	0f 90       	pop	r0
     9fe:	0f be       	out	0x3f, r0	; 63
     a00:	80 e0       	ldi	r24, 0x00	; 0
     a02:	49 c0       	rjmp	.+146    	; 0xa96 <__DATA_REGION_LENGTH__+0x96>
     a04:	e1 10       	cpse	r14, r1
     a06:	05 c0       	rjmp	.+10     	; 0xa12 <__DATA_REGION_LENGTH__+0x12>
     a08:	ce 01       	movw	r24, r28
     a0a:	01 96       	adiw	r24, 0x01	; 1
     a0c:	0e 94 ba 09 	call	0x1374	; 0x1374 <vTaskInternalSetTimeOutState>
     a10:	e9 2c       	mov	r14, r9
     a12:	0f 90       	pop	r0
     a14:	0f be       	out	0x3f, r0	; 63
     a16:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
     a1a:	0f b6       	in	r0, 0x3f	; 63
     a1c:	f8 94       	cli
     a1e:	0f 92       	push	r0
     a20:	f8 01       	movw	r30, r16
     a22:	85 8d       	ldd	r24, Z+29	; 0x1d
     a24:	8f 3f       	cpi	r24, 0xFF	; 255
     a26:	09 f4       	brne	.+2      	; 0xa2a <__DATA_REGION_LENGTH__+0x2a>
     a28:	15 8e       	std	Z+29, r1	; 0x1d
     a2a:	f8 01       	movw	r30, r16
     a2c:	86 8d       	ldd	r24, Z+30	; 0x1e
     a2e:	8f 3f       	cpi	r24, 0xFF	; 255
     a30:	09 f4       	brne	.+2      	; 0xa34 <__DATA_REGION_LENGTH__+0x34>
     a32:	16 8e       	std	Z+30, r1	; 0x1e
     a34:	0f 90       	pop	r0
     a36:	0f be       	out	0x3f, r0	; 63
     a38:	be 01       	movw	r22, r28
     a3a:	6c 5f       	subi	r22, 0xFC	; 252
     a3c:	7f 4f       	sbci	r23, 0xFF	; 255
     a3e:	ce 01       	movw	r24, r28
     a40:	01 96       	adiw	r24, 0x01	; 1
     a42:	0e 94 c5 09 	call	0x138a	; 0x138a <xTaskCheckForTimeOut>
     a46:	81 11       	cpse	r24, r1
     a48:	1a c0       	rjmp	.+52     	; 0xa7e <__DATA_REGION_LENGTH__+0x7e>
     a4a:	c8 01       	movw	r24, r16
     a4c:	0e 94 92 02 	call	0x524	; 0x524 <prvIsQueueEmpty>
     a50:	88 23       	and	r24, r24
     a52:	79 f0       	breq	.+30     	; 0xa72 <__DATA_REGION_LENGTH__+0x72>
     a54:	6c 81       	ldd	r22, Y+4	; 0x04
     a56:	7d 81       	ldd	r23, Y+5	; 0x05
     a58:	c6 01       	movw	r24, r12
     a5a:	0e 94 47 09 	call	0x128e	; 0x128e <vTaskPlaceOnEventList>
     a5e:	c8 01       	movw	r24, r16
     a60:	0e 94 16 03 	call	0x62c	; 0x62c <prvUnlockQueue>
     a64:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
     a68:	81 11       	cpse	r24, r1
     a6a:	a8 cf       	rjmp	.-176    	; 0x9bc <xQueueReceive+0x36>
     a6c:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
     a70:	a5 cf       	rjmp	.-182    	; 0x9bc <xQueueReceive+0x36>
     a72:	c8 01       	movw	r24, r16
     a74:	0e 94 16 03 	call	0x62c	; 0x62c <prvUnlockQueue>
     a78:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
     a7c:	9f cf       	rjmp	.-194    	; 0x9bc <xQueueReceive+0x36>
     a7e:	c8 01       	movw	r24, r16
     a80:	0e 94 16 03 	call	0x62c	; 0x62c <prvUnlockQueue>
     a84:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
     a88:	c8 01       	movw	r24, r16
     a8a:	0e 94 92 02 	call	0x524	; 0x524 <prvIsQueueEmpty>
     a8e:	88 23       	and	r24, r24
     a90:	09 f4       	brne	.+2      	; 0xa94 <__DATA_REGION_LENGTH__+0x94>
     a92:	94 cf       	rjmp	.-216    	; 0x9bc <xQueueReceive+0x36>
     a94:	80 e0       	ldi	r24, 0x00	; 0
     a96:	0f 90       	pop	r0
     a98:	0f 90       	pop	r0
     a9a:	0f 90       	pop	r0
     a9c:	0f 90       	pop	r0
     a9e:	0f 90       	pop	r0
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28
     aa4:	1f 91       	pop	r17
     aa6:	0f 91       	pop	r16
     aa8:	ff 90       	pop	r15
     aaa:	ef 90       	pop	r14
     aac:	df 90       	pop	r13
     aae:	cf 90       	pop	r12
     ab0:	bf 90       	pop	r11
     ab2:	af 90       	pop	r10
     ab4:	9f 90       	pop	r9
     ab6:	08 95       	ret

00000ab8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
     abc:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
     abe:	0f b6       	in	r0, 0x3f	; 63
     ac0:	f8 94       	cli
     ac2:	0f 92       	push	r0
     ac4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ac6:	8f 3f       	cpi	r24, 0xFF	; 255
     ac8:	09 f4       	brne	.+2      	; 0xacc <vQueueWaitForMessageRestricted+0x14>
     aca:	1d 8e       	std	Y+29, r1	; 0x1d
     acc:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ace:	8f 3f       	cpi	r24, 0xFF	; 255
     ad0:	09 f4       	brne	.+2      	; 0xad4 <vQueueWaitForMessageRestricted+0x1c>
     ad2:	1e 8e       	std	Y+30, r1	; 0x1e
     ad4:	0f 90       	pop	r0
     ad6:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     ad8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ada:	81 11       	cpse	r24, r1
     adc:	04 c0       	rjmp	.+8      	; 0xae6 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     ade:	ce 01       	movw	r24, r28
     ae0:	41 96       	adiw	r24, 0x11	; 17
     ae2:	0e 94 59 09 	call	0x12b2	; 0x12b2 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
     ae6:	ce 01       	movw	r24, r28
     ae8:	0e 94 16 03 	call	0x62c	; 0x62c <prvUnlockQueue>
    }
     aec:	df 91       	pop	r29
     aee:	cf 91       	pop	r28
     af0:	08 95       	ret

00000af2 <prvResetNextTaskUnblockTime>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     af2:	e0 91 59 01 	lds	r30, 0x0159	; 0x800159 <pxDelayedTaskList>
     af6:	f0 91 5a 01 	lds	r31, 0x015A	; 0x80015a <pxDelayedTaskList+0x1>
     afa:	80 81       	ld	r24, Z
     afc:	81 11       	cpse	r24, r1
     afe:	07 c0       	rjmp	.+14     	; 0xb0e <__stack+0xf>
     b00:	8f ef       	ldi	r24, 0xFF	; 255
     b02:	9f ef       	ldi	r25, 0xFF	; 255
     b04:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <xNextTaskUnblockTime+0x1>
     b08:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xNextTaskUnblockTime>
     b0c:	08 95       	ret
     b0e:	e0 91 59 01 	lds	r30, 0x0159	; 0x800159 <pxDelayedTaskList>
     b12:	f0 91 5a 01 	lds	r31, 0x015A	; 0x80015a <pxDelayedTaskList+0x1>
     b16:	05 80       	ldd	r0, Z+5	; 0x05
     b18:	f6 81       	ldd	r31, Z+6	; 0x06
     b1a:	e0 2d       	mov	r30, r0
     b1c:	06 80       	ldd	r0, Z+6	; 0x06
     b1e:	f7 81       	ldd	r31, Z+7	; 0x07
     b20:	e0 2d       	mov	r30, r0
     b22:	82 81       	ldd	r24, Z+2	; 0x02
     b24:	93 81       	ldd	r25, Z+3	; 0x03
     b26:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <xNextTaskUnblockTime+0x1>
     b2a:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xNextTaskUnblockTime>
     b2e:	08 95       	ret

00000b30 <prvAddCurrentTaskToDelayedList>:
     b30:	ff 92       	push	r15
     b32:	0f 93       	push	r16
     b34:	1f 93       	push	r17
     b36:	cf 93       	push	r28
     b38:	df 93       	push	r29
     b3a:	ec 01       	movw	r28, r24
     b3c:	f6 2e       	mov	r15, r22
     b3e:	00 91 38 01 	lds	r16, 0x0138	; 0x800138 <xTickCount>
     b42:	10 91 39 01 	lds	r17, 0x0139	; 0x800139 <xTickCount+0x1>
     b46:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <pxCurrentTCB>
     b4a:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     b4e:	02 96       	adiw	r24, 0x02	; 2
     b50:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
     b54:	cf 3f       	cpi	r28, 0xFF	; 255
     b56:	8f ef       	ldi	r24, 0xFF	; 255
     b58:	d8 07       	cpc	r29, r24
     b5a:	69 f4       	brne	.+26     	; 0xb76 <prvAddCurrentTaskToDelayedList+0x46>
     b5c:	ff 20       	and	r15, r15
     b5e:	59 f0       	breq	.+22     	; 0xb76 <prvAddCurrentTaskToDelayedList+0x46>
     b60:	60 91 91 01 	lds	r22, 0x0191	; 0x800191 <pxCurrentTCB>
     b64:	70 91 92 01 	lds	r23, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     b68:	6e 5f       	subi	r22, 0xFE	; 254
     b6a:	7f 4f       	sbci	r23, 0xFF	; 255
     b6c:	8b e3       	ldi	r24, 0x3B	; 59
     b6e:	91 e0       	ldi	r25, 0x01	; 1
     b70:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
     b74:	2f c0       	rjmp	.+94     	; 0xbd4 <prvAddCurrentTaskToDelayedList+0xa4>
     b76:	c0 0f       	add	r28, r16
     b78:	d1 1f       	adc	r29, r17
     b7a:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <pxCurrentTCB>
     b7e:	f0 91 92 01 	lds	r31, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     b82:	d3 83       	std	Z+3, r29	; 0x03
     b84:	c2 83       	std	Z+2, r28	; 0x02
     b86:	c0 17       	cp	r28, r16
     b88:	d1 07       	cpc	r29, r17
     b8a:	68 f4       	brcc	.+26     	; 0xba6 <prvAddCurrentTaskToDelayedList+0x76>
     b8c:	60 91 91 01 	lds	r22, 0x0191	; 0x800191 <pxCurrentTCB>
     b90:	70 91 92 01 	lds	r23, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     b94:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <pxOverflowDelayedTaskList>
     b98:	90 91 58 01 	lds	r25, 0x0158	; 0x800158 <pxOverflowDelayedTaskList+0x1>
     b9c:	6e 5f       	subi	r22, 0xFE	; 254
     b9e:	7f 4f       	sbci	r23, 0xFF	; 255
     ba0:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
     ba4:	17 c0       	rjmp	.+46     	; 0xbd4 <prvAddCurrentTaskToDelayedList+0xa4>
     ba6:	60 91 91 01 	lds	r22, 0x0191	; 0x800191 <pxCurrentTCB>
     baa:	70 91 92 01 	lds	r23, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     bae:	80 91 59 01 	lds	r24, 0x0159	; 0x800159 <pxDelayedTaskList>
     bb2:	90 91 5a 01 	lds	r25, 0x015A	; 0x80015a <pxDelayedTaskList+0x1>
     bb6:	6e 5f       	subi	r22, 0xFE	; 254
     bb8:	7f 4f       	sbci	r23, 0xFF	; 255
     bba:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
     bbe:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <xNextTaskUnblockTime>
     bc2:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <xNextTaskUnblockTime+0x1>
     bc6:	c8 17       	cp	r28, r24
     bc8:	d9 07       	cpc	r29, r25
     bca:	20 f4       	brcc	.+8      	; 0xbd4 <prvAddCurrentTaskToDelayedList+0xa4>
     bcc:	d0 93 30 01 	sts	0x0130, r29	; 0x800130 <xNextTaskUnblockTime+0x1>
     bd0:	c0 93 2f 01 	sts	0x012F, r28	; 0x80012f <xNextTaskUnblockTime>
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	1f 91       	pop	r17
     bda:	0f 91       	pop	r16
     bdc:	ff 90       	pop	r15
     bde:	08 95       	ret

00000be0 <prvIdleTask>:
     be0:	05 e4       	ldi	r16, 0x45	; 69
     be2:	11 e0       	ldi	r17, 0x01	; 1
     be4:	0f 2e       	mov	r0, r31
     be6:	fd e6       	ldi	r31, 0x6D	; 109
     be8:	ef 2e       	mov	r14, r31
     bea:	f1 e0       	ldi	r31, 0x01	; 1
     bec:	ff 2e       	mov	r15, r31
     bee:	f0 2d       	mov	r31, r0
     bf0:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <uxDeletedTasksWaitingCleanUp>
     bf4:	88 23       	and	r24, r24
     bf6:	29 f1       	breq	.+74     	; 0xc42 <prvIdleTask+0x62>
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	0f 92       	push	r0
     bfe:	d8 01       	movw	r26, r16
     c00:	15 96       	adiw	r26, 0x05	; 5
     c02:	ed 91       	ld	r30, X+
     c04:	fc 91       	ld	r31, X
     c06:	16 97       	sbiw	r26, 0x06	; 6
     c08:	c6 81       	ldd	r28, Z+6	; 0x06
     c0a:	d7 81       	ldd	r29, Z+7	; 0x07
     c0c:	ce 01       	movw	r24, r28
     c0e:	02 96       	adiw	r24, 0x02	; 2
     c10:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
     c14:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <uxCurrentNumberOfTasks>
     c18:	81 50       	subi	r24, 0x01	; 1
     c1a:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxCurrentNumberOfTasks>
     c1e:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <uxDeletedTasksWaitingCleanUp>
     c22:	81 50       	subi	r24, 0x01	; 1
     c24:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <uxDeletedTasksWaitingCleanUp>
     c28:	0f 90       	pop	r0
     c2a:	0f be       	out	0x3f, r0	; 63
     c2c:	8f 89       	ldd	r24, Y+23	; 0x17
     c2e:	98 8d       	ldd	r25, Y+24	; 0x18
     c30:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     c34:	ce 01       	movw	r24, r28
     c36:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     c3a:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <uxDeletedTasksWaitingCleanUp>
     c3e:	81 11       	cpse	r24, r1
     c40:	db cf       	rjmp	.-74     	; 0xbf8 <prvIdleTask+0x18>
     c42:	f7 01       	movw	r30, r14
     c44:	80 81       	ld	r24, Z
     c46:	82 30       	cpi	r24, 0x02	; 2
     c48:	10 f0       	brcs	.+4      	; 0xc4e <prvIdleTask+0x6e>
     c4a:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
     c4e:	0e 94 a1 00 	call	0x142	; 0x142 <vApplicationIdleHook>
     c52:	ce cf       	rjmp	.-100    	; 0xbf0 <prvIdleTask+0x10>

00000c54 <xTaskCreate>:
     c54:	4f 92       	push	r4
     c56:	5f 92       	push	r5
     c58:	6f 92       	push	r6
     c5a:	7f 92       	push	r7
     c5c:	8f 92       	push	r8
     c5e:	9f 92       	push	r9
     c60:	af 92       	push	r10
     c62:	bf 92       	push	r11
     c64:	cf 92       	push	r12
     c66:	df 92       	push	r13
     c68:	ef 92       	push	r14
     c6a:	ff 92       	push	r15
     c6c:	0f 93       	push	r16
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
     c72:	4c 01       	movw	r8, r24
     c74:	6b 01       	movw	r12, r22
     c76:	5a 01       	movw	r10, r20
     c78:	29 01       	movw	r4, r18
     c7a:	ca 01       	movw	r24, r20
     c7c:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     c80:	3c 01       	movw	r6, r24
     c82:	89 2b       	or	r24, r25
     c84:	09 f4       	brne	.+2      	; 0xc88 <xTaskCreate+0x34>
     c86:	f1 c0       	rjmp	.+482    	; 0xe6a <xTaskCreate+0x216>
     c88:	88 e2       	ldi	r24, 0x28	; 40
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     c90:	ec 01       	movw	r28, r24
     c92:	89 2b       	or	r24, r25
     c94:	99 f0       	breq	.+38     	; 0xcbc <xTaskCreate+0x68>
     c96:	78 8e       	std	Y+24, r7	; 0x18
     c98:	6f 8a       	std	Y+23, r6	; 0x17
     c9a:	a5 01       	movw	r20, r10
     c9c:	65 ea       	ldi	r22, 0xA5	; 165
     c9e:	70 e0       	ldi	r23, 0x00	; 0
     ca0:	c3 01       	movw	r24, r6
     ca2:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <memset>
     ca6:	81 e0       	ldi	r24, 0x01	; 1
     ca8:	a8 1a       	sub	r10, r24
     caa:	b1 08       	sbc	r11, r1
     cac:	8f 89       	ldd	r24, Y+23	; 0x17
     cae:	98 8d       	ldd	r25, Y+24	; 0x18
     cb0:	a8 0e       	add	r10, r24
     cb2:	b9 1e       	adc	r11, r25
     cb4:	c1 14       	cp	r12, r1
     cb6:	d1 04       	cpc	r13, r1
     cb8:	29 f4       	brne	.+10     	; 0xcc4 <xTaskCreate+0x70>
     cba:	20 c0       	rjmp	.+64     	; 0xcfc <xTaskCreate+0xa8>
     cbc:	c3 01       	movw	r24, r6
     cbe:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     cc2:	d3 c0       	rjmp	.+422    	; 0xe6a <xTaskCreate+0x216>
     cc4:	d6 01       	movw	r26, r12
     cc6:	8c 91       	ld	r24, X
     cc8:	89 8f       	std	Y+25, r24	; 0x19
     cca:	8c 91       	ld	r24, X
     ccc:	88 23       	and	r24, r24
     cce:	a1 f0       	breq	.+40     	; 0xcf8 <xTaskCreate+0xa4>
     cd0:	ae 01       	movw	r20, r28
     cd2:	46 5e       	subi	r20, 0xE6	; 230
     cd4:	5f 4f       	sbci	r21, 0xFF	; 255
     cd6:	f6 01       	movw	r30, r12
     cd8:	31 96       	adiw	r30, 0x01	; 1
     cda:	b8 e0       	ldi	r27, 0x08	; 8
     cdc:	cb 0e       	add	r12, r27
     cde:	d1 1c       	adc	r13, r1
     ce0:	cf 01       	movw	r24, r30
     ce2:	21 91       	ld	r18, Z+
     ce4:	da 01       	movw	r26, r20
     ce6:	2d 93       	st	X+, r18
     ce8:	ad 01       	movw	r20, r26
     cea:	dc 01       	movw	r26, r24
     cec:	8c 91       	ld	r24, X
     cee:	88 23       	and	r24, r24
     cf0:	19 f0       	breq	.+6      	; 0xcf8 <xTaskCreate+0xa4>
     cf2:	ec 15       	cp	r30, r12
     cf4:	fd 05       	cpc	r31, r13
     cf6:	a1 f7       	brne	.-24     	; 0xce0 <xTaskCreate+0x8c>
     cf8:	18 a2       	std	Y+32, r1	; 0x20
     cfa:	01 c0       	rjmp	.+2      	; 0xcfe <xTaskCreate+0xaa>
     cfc:	19 8e       	std	Y+25, r1	; 0x19
     cfe:	04 30       	cpi	r16, 0x04	; 4
     d00:	08 f0       	brcs	.+2      	; 0xd04 <xTaskCreate+0xb0>
     d02:	03 e0       	ldi	r16, 0x03	; 3
     d04:	0e 8b       	std	Y+22, r16	; 0x16
     d06:	09 a3       	std	Y+33, r16	; 0x21
     d08:	1a a2       	std	Y+34, r1	; 0x22
     d0a:	6e 01       	movw	r12, r28
     d0c:	b2 e0       	ldi	r27, 0x02	; 2
     d0e:	cb 0e       	add	r12, r27
     d10:	d1 1c       	adc	r13, r1
     d12:	c6 01       	movw	r24, r12
     d14:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vListInitialiseItem>
     d18:	ce 01       	movw	r24, r28
     d1a:	0c 96       	adiw	r24, 0x0c	; 12
     d1c:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vListInitialiseItem>
     d20:	d9 87       	std	Y+9, r29	; 0x09
     d22:	c8 87       	std	Y+8, r28	; 0x08
     d24:	84 e0       	ldi	r24, 0x04	; 4
     d26:	90 e0       	ldi	r25, 0x00	; 0
     d28:	80 1b       	sub	r24, r16
     d2a:	91 09       	sbc	r25, r1
     d2c:	9d 87       	std	Y+13, r25	; 0x0d
     d2e:	8c 87       	std	Y+12, r24	; 0x0c
     d30:	db 8b       	std	Y+19, r29	; 0x13
     d32:	ca 8b       	std	Y+18, r28	; 0x12
     d34:	1b a2       	std	Y+35, r1	; 0x23
     d36:	1c a2       	std	Y+36, r1	; 0x24
     d38:	1d a2       	std	Y+37, r1	; 0x25
     d3a:	1e a2       	std	Y+38, r1	; 0x26
     d3c:	1f a2       	std	Y+39, r1	; 0x27
     d3e:	a2 01       	movw	r20, r4
     d40:	b4 01       	movw	r22, r8
     d42:	c5 01       	movw	r24, r10
     d44:	0e 94 90 01 	call	0x320	; 0x320 <pxPortInitialiseStack>
     d48:	99 83       	std	Y+1, r25	; 0x01
     d4a:	88 83       	st	Y, r24
     d4c:	e1 14       	cp	r14, r1
     d4e:	f1 04       	cpc	r15, r1
     d50:	19 f0       	breq	.+6      	; 0xd58 <xTaskCreate+0x104>
     d52:	f7 01       	movw	r30, r14
     d54:	d1 83       	std	Z+1, r29	; 0x01
     d56:	c0 83       	st	Z, r28
     d58:	0f b6       	in	r0, 0x3f	; 63
     d5a:	f8 94       	cli
     d5c:	0f 92       	push	r0
     d5e:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <uxCurrentNumberOfTasks>
     d62:	8f 5f       	subi	r24, 0xFF	; 255
     d64:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxCurrentNumberOfTasks>
     d68:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <pxCurrentTCB>
     d6c:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     d70:	89 2b       	or	r24, r25
     d72:	d1 f5       	brne	.+116    	; 0xde8 <xTaskCreate+0x194>
     d74:	d0 93 92 01 	sts	0x0192, r29	; 0x800192 <pxCurrentTCB+0x1>
     d78:	c0 93 91 01 	sts	0x0191, r28	; 0x800191 <pxCurrentTCB>
     d7c:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <uxCurrentNumberOfTasks>
     d80:	81 30       	cpi	r24, 0x01	; 1
     d82:	09 f0       	breq	.+2      	; 0xd86 <xTaskCreate+0x132>
     d84:	41 c0       	rjmp	.+130    	; 0xe08 <xTaskCreate+0x1b4>
     d86:	8d e6       	ldi	r24, 0x6D	; 109
     d88:	91 e0       	ldi	r25, 0x01	; 1
     d8a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     d8e:	86 e7       	ldi	r24, 0x76	; 118
     d90:	91 e0       	ldi	r25, 0x01	; 1
     d92:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     d96:	8f e7       	ldi	r24, 0x7F	; 127
     d98:	91 e0       	ldi	r25, 0x01	; 1
     d9a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     d9e:	88 e8       	ldi	r24, 0x88	; 136
     da0:	91 e0       	ldi	r25, 0x01	; 1
     da2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     da6:	84 e6       	ldi	r24, 0x64	; 100
     da8:	91 e0       	ldi	r25, 0x01	; 1
     daa:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     dae:	8b e5       	ldi	r24, 0x5B	; 91
     db0:	91 e0       	ldi	r25, 0x01	; 1
     db2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     db6:	8e e4       	ldi	r24, 0x4E	; 78
     db8:	91 e0       	ldi	r25, 0x01	; 1
     dba:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     dbe:	85 e4       	ldi	r24, 0x45	; 69
     dc0:	91 e0       	ldi	r25, 0x01	; 1
     dc2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     dc6:	8b e3       	ldi	r24, 0x3B	; 59
     dc8:	91 e0       	ldi	r25, 0x01	; 1
     dca:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     dce:	84 e6       	ldi	r24, 0x64	; 100
     dd0:	91 e0       	ldi	r25, 0x01	; 1
     dd2:	90 93 5a 01 	sts	0x015A, r25	; 0x80015a <pxDelayedTaskList+0x1>
     dd6:	80 93 59 01 	sts	0x0159, r24	; 0x800159 <pxDelayedTaskList>
     dda:	8b e5       	ldi	r24, 0x5B	; 91
     ddc:	91 e0       	ldi	r25, 0x01	; 1
     dde:	90 93 58 01 	sts	0x0158, r25	; 0x800158 <pxOverflowDelayedTaskList+0x1>
     de2:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <pxOverflowDelayedTaskList>
     de6:	10 c0       	rjmp	.+32     	; 0xe08 <xTaskCreate+0x1b4>
     de8:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <xSchedulerRunning>
     dec:	81 11       	cpse	r24, r1
     dee:	0c c0       	rjmp	.+24     	; 0xe08 <xTaskCreate+0x1b4>
     df0:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <pxCurrentTCB>
     df4:	f0 91 92 01 	lds	r31, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     df8:	96 89       	ldd	r25, Z+22	; 0x16
     dfa:	8e 89       	ldd	r24, Y+22	; 0x16
     dfc:	89 17       	cp	r24, r25
     dfe:	20 f0       	brcs	.+8      	; 0xe08 <xTaskCreate+0x1b4>
     e00:	d0 93 92 01 	sts	0x0192, r29	; 0x800192 <pxCurrentTCB+0x1>
     e04:	c0 93 91 01 	sts	0x0191, r28	; 0x800191 <pxCurrentTCB>
     e08:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <uxTaskNumber>
     e0c:	8f 5f       	subi	r24, 0xFF	; 255
     e0e:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <uxTaskNumber>
     e12:	8e 89       	ldd	r24, Y+22	; 0x16
     e14:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <uxTopReadyPriority>
     e18:	98 17       	cp	r25, r24
     e1a:	10 f4       	brcc	.+4      	; 0xe20 <xTaskCreate+0x1cc>
     e1c:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <uxTopReadyPriority>
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	9c 01       	movw	r18, r24
     e24:	22 0f       	add	r18, r18
     e26:	33 1f       	adc	r19, r19
     e28:	22 0f       	add	r18, r18
     e2a:	33 1f       	adc	r19, r19
     e2c:	22 0f       	add	r18, r18
     e2e:	33 1f       	adc	r19, r19
     e30:	82 0f       	add	r24, r18
     e32:	93 1f       	adc	r25, r19
     e34:	b6 01       	movw	r22, r12
     e36:	83 59       	subi	r24, 0x93	; 147
     e38:	9e 4f       	sbci	r25, 0xFE	; 254
     e3a:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
     e3e:	0f 90       	pop	r0
     e40:	0f be       	out	0x3f, r0	; 63
     e42:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <xSchedulerRunning>
     e46:	88 23       	and	r24, r24
     e48:	61 f0       	breq	.+24     	; 0xe62 <xTaskCreate+0x20e>
     e4a:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <pxCurrentTCB>
     e4e:	f0 91 92 01 	lds	r31, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
     e52:	96 89       	ldd	r25, Z+22	; 0x16
     e54:	8e 89       	ldd	r24, Y+22	; 0x16
     e56:	98 17       	cp	r25, r24
     e58:	30 f4       	brcc	.+12     	; 0xe66 <xTaskCreate+0x212>
     e5a:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
     e5e:	81 e0       	ldi	r24, 0x01	; 1
     e60:	05 c0       	rjmp	.+10     	; 0xe6c <xTaskCreate+0x218>
     e62:	81 e0       	ldi	r24, 0x01	; 1
     e64:	03 c0       	rjmp	.+6      	; 0xe6c <xTaskCreate+0x218>
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	01 c0       	rjmp	.+2      	; 0xe6c <xTaskCreate+0x218>
     e6a:	8f ef       	ldi	r24, 0xFF	; 255
     e6c:	df 91       	pop	r29
     e6e:	cf 91       	pop	r28
     e70:	0f 91       	pop	r16
     e72:	ff 90       	pop	r15
     e74:	ef 90       	pop	r14
     e76:	df 90       	pop	r13
     e78:	cf 90       	pop	r12
     e7a:	bf 90       	pop	r11
     e7c:	af 90       	pop	r10
     e7e:	9f 90       	pop	r9
     e80:	8f 90       	pop	r8
     e82:	7f 90       	pop	r7
     e84:	6f 90       	pop	r6
     e86:	5f 90       	pop	r5
     e88:	4f 90       	pop	r4
     e8a:	08 95       	ret

00000e8c <vTaskStartScheduler>:
     e8c:	ef 92       	push	r14
     e8e:	ff 92       	push	r15
     e90:	0f 93       	push	r16
     e92:	0f 2e       	mov	r0, r31
     e94:	fd e2       	ldi	r31, 0x2D	; 45
     e96:	ef 2e       	mov	r14, r31
     e98:	f1 e0       	ldi	r31, 0x01	; 1
     e9a:	ff 2e       	mov	r15, r31
     e9c:	f0 2d       	mov	r31, r0
     e9e:	00 e0       	ldi	r16, 0x00	; 0
     ea0:	20 e0       	ldi	r18, 0x00	; 0
     ea2:	30 e0       	ldi	r19, 0x00	; 0
     ea4:	45 e5       	ldi	r20, 0x55	; 85
     ea6:	50 e0       	ldi	r21, 0x00	; 0
     ea8:	68 e1       	ldi	r22, 0x18	; 24
     eaa:	71 e0       	ldi	r23, 0x01	; 1
     eac:	80 ef       	ldi	r24, 0xF0	; 240
     eae:	95 e0       	ldi	r25, 0x05	; 5
     eb0:	0e 94 2a 06 	call	0xc54	; 0xc54 <xTaskCreate>
     eb4:	81 30       	cpi	r24, 0x01	; 1
     eb6:	a1 f4       	brne	.+40     	; 0xee0 <vTaskStartScheduler+0x54>
     eb8:	0e 94 a5 0a 	call	0x154a	; 0x154a <xTimerCreateTimerTask>
     ebc:	81 30       	cpi	r24, 0x01	; 1
     ebe:	81 f4       	brne	.+32     	; 0xee0 <vTaskStartScheduler+0x54>
     ec0:	f8 94       	cli
     ec2:	8f ef       	ldi	r24, 0xFF	; 255
     ec4:	9f ef       	ldi	r25, 0xFF	; 255
     ec6:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <xNextTaskUnblockTime+0x1>
     eca:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xNextTaskUnblockTime>
     ece:	81 e0       	ldi	r24, 0x01	; 1
     ed0:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <xSchedulerRunning>
     ed4:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <xTickCount+0x1>
     ed8:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <xTickCount>
     edc:	0e 94 a1 01 	call	0x342	; 0x342 <xPortStartScheduler>
     ee0:	0f 91       	pop	r16
     ee2:	ff 90       	pop	r15
     ee4:	ef 90       	pop	r14
     ee6:	08 95       	ret

00000ee8 <vTaskSuspendAll>:
     ee8:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxSchedulerSuspended>
     eec:	8f 5f       	subi	r24, 0xFF	; 255
     eee:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxSchedulerSuspended>
     ef2:	08 95       	ret

00000ef4 <xTaskGetTickCount>:
     ef4:	0f b6       	in	r0, 0x3f	; 63
     ef6:	f8 94       	cli
     ef8:	0f 92       	push	r0
     efa:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <xTickCount>
     efe:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <xTickCount+0x1>
     f02:	0f 90       	pop	r0
     f04:	0f be       	out	0x3f, r0	; 63
     f06:	08 95       	ret

00000f08 <xTaskIncrementTick>:
     f08:	cf 92       	push	r12
     f0a:	df 92       	push	r13
     f0c:	ef 92       	push	r14
     f0e:	ff 92       	push	r15
     f10:	0f 93       	push	r16
     f12:	1f 93       	push	r17
     f14:	cf 93       	push	r28
     f16:	df 93       	push	r29
     f18:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxSchedulerSuspended>
     f1c:	81 11       	cpse	r24, r1
     f1e:	9f c0       	rjmp	.+318    	; 0x105e <xTaskIncrementTick+0x156>
     f20:	e0 90 38 01 	lds	r14, 0x0138	; 0x800138 <xTickCount>
     f24:	f0 90 39 01 	lds	r15, 0x0139	; 0x800139 <xTickCount+0x1>
     f28:	8f ef       	ldi	r24, 0xFF	; 255
     f2a:	e8 1a       	sub	r14, r24
     f2c:	f8 0a       	sbc	r15, r24
     f2e:	f0 92 39 01 	sts	0x0139, r15	; 0x800139 <xTickCount+0x1>
     f32:	e0 92 38 01 	sts	0x0138, r14	; 0x800138 <xTickCount>
     f36:	e1 14       	cp	r14, r1
     f38:	f1 04       	cpc	r15, r1
     f3a:	b9 f4       	brne	.+46     	; 0xf6a <xTaskIncrementTick+0x62>
     f3c:	80 91 59 01 	lds	r24, 0x0159	; 0x800159 <pxDelayedTaskList>
     f40:	90 91 5a 01 	lds	r25, 0x015A	; 0x80015a <pxDelayedTaskList+0x1>
     f44:	20 91 57 01 	lds	r18, 0x0157	; 0x800157 <pxOverflowDelayedTaskList>
     f48:	30 91 58 01 	lds	r19, 0x0158	; 0x800158 <pxOverflowDelayedTaskList+0x1>
     f4c:	30 93 5a 01 	sts	0x015A, r19	; 0x80015a <pxDelayedTaskList+0x1>
     f50:	20 93 59 01 	sts	0x0159, r18	; 0x800159 <pxDelayedTaskList>
     f54:	90 93 58 01 	sts	0x0158, r25	; 0x800158 <pxOverflowDelayedTaskList+0x1>
     f58:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <pxOverflowDelayedTaskList>
     f5c:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xNumOfOverflows>
     f60:	8f 5f       	subi	r24, 0xFF	; 255
     f62:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNumOfOverflows>
     f66:	0e 94 79 05 	call	0xaf2	; 0xaf2 <prvResetNextTaskUnblockTime>
     f6a:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <xNextTaskUnblockTime>
     f6e:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <xNextTaskUnblockTime+0x1>
     f72:	e8 16       	cp	r14, r24
     f74:	f9 06       	cpc	r15, r25
     f76:	10 f4       	brcc	.+4      	; 0xf7c <xTaskIncrementTick+0x74>
     f78:	d1 2c       	mov	r13, r1
     f7a:	53 c0       	rjmp	.+166    	; 0x1022 <xTaskIncrementTick+0x11a>
     f7c:	d1 2c       	mov	r13, r1
     f7e:	cc 24       	eor	r12, r12
     f80:	c3 94       	inc	r12
     f82:	e0 91 59 01 	lds	r30, 0x0159	; 0x800159 <pxDelayedTaskList>
     f86:	f0 91 5a 01 	lds	r31, 0x015A	; 0x80015a <pxDelayedTaskList+0x1>
     f8a:	80 81       	ld	r24, Z
     f8c:	81 11       	cpse	r24, r1
     f8e:	07 c0       	rjmp	.+14     	; 0xf9e <xTaskIncrementTick+0x96>
     f90:	8f ef       	ldi	r24, 0xFF	; 255
     f92:	9f ef       	ldi	r25, 0xFF	; 255
     f94:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <xNextTaskUnblockTime+0x1>
     f98:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xNextTaskUnblockTime>
     f9c:	42 c0       	rjmp	.+132    	; 0x1022 <xTaskIncrementTick+0x11a>
     f9e:	e0 91 59 01 	lds	r30, 0x0159	; 0x800159 <pxDelayedTaskList>
     fa2:	f0 91 5a 01 	lds	r31, 0x015A	; 0x80015a <pxDelayedTaskList+0x1>
     fa6:	05 80       	ldd	r0, Z+5	; 0x05
     fa8:	f6 81       	ldd	r31, Z+6	; 0x06
     faa:	e0 2d       	mov	r30, r0
     fac:	c6 81       	ldd	r28, Z+6	; 0x06
     fae:	d7 81       	ldd	r29, Z+7	; 0x07
     fb0:	8a 81       	ldd	r24, Y+2	; 0x02
     fb2:	9b 81       	ldd	r25, Y+3	; 0x03
     fb4:	e8 16       	cp	r14, r24
     fb6:	f9 06       	cpc	r15, r25
     fb8:	28 f4       	brcc	.+10     	; 0xfc4 <xTaskIncrementTick+0xbc>
     fba:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <xNextTaskUnblockTime+0x1>
     fbe:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xNextTaskUnblockTime>
     fc2:	2f c0       	rjmp	.+94     	; 0x1022 <xTaskIncrementTick+0x11a>
     fc4:	8e 01       	movw	r16, r28
     fc6:	0e 5f       	subi	r16, 0xFE	; 254
     fc8:	1f 4f       	sbci	r17, 0xFF	; 255
     fca:	c8 01       	movw	r24, r16
     fcc:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
     fd0:	8c 89       	ldd	r24, Y+20	; 0x14
     fd2:	9d 89       	ldd	r25, Y+21	; 0x15
     fd4:	89 2b       	or	r24, r25
     fd6:	21 f0       	breq	.+8      	; 0xfe0 <xTaskIncrementTick+0xd8>
     fd8:	ce 01       	movw	r24, r28
     fda:	0c 96       	adiw	r24, 0x0c	; 12
     fdc:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
     fe0:	8e 89       	ldd	r24, Y+22	; 0x16
     fe2:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <uxTopReadyPriority>
     fe6:	98 17       	cp	r25, r24
     fe8:	10 f4       	brcc	.+4      	; 0xfee <xTaskIncrementTick+0xe6>
     fea:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <uxTopReadyPriority>
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	9c 01       	movw	r18, r24
     ff2:	22 0f       	add	r18, r18
     ff4:	33 1f       	adc	r19, r19
     ff6:	22 0f       	add	r18, r18
     ff8:	33 1f       	adc	r19, r19
     ffa:	22 0f       	add	r18, r18
     ffc:	33 1f       	adc	r19, r19
     ffe:	82 0f       	add	r24, r18
    1000:	93 1f       	adc	r25, r19
    1002:	b8 01       	movw	r22, r16
    1004:	83 59       	subi	r24, 0x93	; 147
    1006:	9e 4f       	sbci	r25, 0xFE	; 254
    1008:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    100c:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <pxCurrentTCB>
    1010:	f0 91 92 01 	lds	r31, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    1014:	9e 89       	ldd	r25, Y+22	; 0x16
    1016:	86 89       	ldd	r24, Z+22	; 0x16
    1018:	98 17       	cp	r25, r24
    101a:	08 f4       	brcc	.+2      	; 0x101e <xTaskIncrementTick+0x116>
    101c:	b2 cf       	rjmp	.-156    	; 0xf82 <xTaskIncrementTick+0x7a>
    101e:	dc 2c       	mov	r13, r12
    1020:	b0 cf       	rjmp	.-160    	; 0xf82 <xTaskIncrementTick+0x7a>
    1022:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <pxCurrentTCB>
    1026:	f0 91 92 01 	lds	r31, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    102a:	86 89       	ldd	r24, Z+22	; 0x16
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	fc 01       	movw	r30, r24
    1030:	ee 0f       	add	r30, r30
    1032:	ff 1f       	adc	r31, r31
    1034:	ee 0f       	add	r30, r30
    1036:	ff 1f       	adc	r31, r31
    1038:	ee 0f       	add	r30, r30
    103a:	ff 1f       	adc	r31, r31
    103c:	8e 0f       	add	r24, r30
    103e:	9f 1f       	adc	r25, r31
    1040:	fc 01       	movw	r30, r24
    1042:	e3 59       	subi	r30, 0x93	; 147
    1044:	fe 4f       	sbci	r31, 0xFE	; 254
    1046:	80 81       	ld	r24, Z
    1048:	82 30       	cpi	r24, 0x02	; 2
    104a:	10 f0       	brcs	.+4      	; 0x1050 <xTaskIncrementTick+0x148>
    104c:	dd 24       	eor	r13, r13
    104e:	d3 94       	inc	r13
    1050:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xYieldPending>
    1054:	88 23       	and	r24, r24
    1056:	69 f0       	breq	.+26     	; 0x1072 <xTaskIncrementTick+0x16a>
    1058:	dd 24       	eor	r13, r13
    105a:	d3 94       	inc	r13
    105c:	0a c0       	rjmp	.+20     	; 0x1072 <xTaskIncrementTick+0x16a>
    105e:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <xPendedTicks>
    1062:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <xPendedTicks+0x1>
    1066:	01 96       	adiw	r24, 0x01	; 1
    1068:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <xPendedTicks+0x1>
    106c:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <xPendedTicks>
    1070:	d1 2c       	mov	r13, r1
    1072:	8d 2d       	mov	r24, r13
    1074:	df 91       	pop	r29
    1076:	cf 91       	pop	r28
    1078:	1f 91       	pop	r17
    107a:	0f 91       	pop	r16
    107c:	ff 90       	pop	r15
    107e:	ef 90       	pop	r14
    1080:	df 90       	pop	r13
    1082:	cf 90       	pop	r12
    1084:	08 95       	ret

00001086 <xTaskResumeAll>:
    1086:	df 92       	push	r13
    1088:	ef 92       	push	r14
    108a:	ff 92       	push	r15
    108c:	0f 93       	push	r16
    108e:	1f 93       	push	r17
    1090:	cf 93       	push	r28
    1092:	df 93       	push	r29
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	0f 92       	push	r0
    109a:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxSchedulerSuspended>
    109e:	81 50       	subi	r24, 0x01	; 1
    10a0:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxSchedulerSuspended>
    10a4:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxSchedulerSuspended>
    10a8:	81 11       	cpse	r24, r1
    10aa:	63 c0       	rjmp	.+198    	; 0x1172 <xTaskResumeAll+0xec>
    10ac:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <uxCurrentNumberOfTasks>
    10b0:	81 11       	cpse	r24, r1
    10b2:	33 c0       	rjmp	.+102    	; 0x111a <xTaskResumeAll+0x94>
    10b4:	61 c0       	rjmp	.+194    	; 0x1178 <xTaskResumeAll+0xf2>
    10b6:	d7 01       	movw	r26, r14
    10b8:	15 96       	adiw	r26, 0x05	; 5
    10ba:	ed 91       	ld	r30, X+
    10bc:	fc 91       	ld	r31, X
    10be:	16 97       	sbiw	r26, 0x06	; 6
    10c0:	c6 81       	ldd	r28, Z+6	; 0x06
    10c2:	d7 81       	ldd	r29, Z+7	; 0x07
    10c4:	ce 01       	movw	r24, r28
    10c6:	0c 96       	adiw	r24, 0x0c	; 12
    10c8:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    10cc:	8e 01       	movw	r16, r28
    10ce:	0e 5f       	subi	r16, 0xFE	; 254
    10d0:	1f 4f       	sbci	r17, 0xFF	; 255
    10d2:	c8 01       	movw	r24, r16
    10d4:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    10d8:	8e 89       	ldd	r24, Y+22	; 0x16
    10da:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <uxTopReadyPriority>
    10de:	98 17       	cp	r25, r24
    10e0:	10 f4       	brcc	.+4      	; 0x10e6 <xTaskResumeAll+0x60>
    10e2:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <uxTopReadyPriority>
    10e6:	90 e0       	ldi	r25, 0x00	; 0
    10e8:	9c 01       	movw	r18, r24
    10ea:	22 0f       	add	r18, r18
    10ec:	33 1f       	adc	r19, r19
    10ee:	22 0f       	add	r18, r18
    10f0:	33 1f       	adc	r19, r19
    10f2:	22 0f       	add	r18, r18
    10f4:	33 1f       	adc	r19, r19
    10f6:	82 0f       	add	r24, r18
    10f8:	93 1f       	adc	r25, r19
    10fa:	b8 01       	movw	r22, r16
    10fc:	83 59       	subi	r24, 0x93	; 147
    10fe:	9e 4f       	sbci	r25, 0xFE	; 254
    1100:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1104:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <pxCurrentTCB>
    1108:	f0 91 92 01 	lds	r31, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    110c:	9e 89       	ldd	r25, Y+22	; 0x16
    110e:	86 89       	ldd	r24, Z+22	; 0x16
    1110:	98 17       	cp	r25, r24
    1112:	68 f0       	brcs	.+26     	; 0x112e <xTaskResumeAll+0xa8>
    1114:	d0 92 33 01 	sts	0x0133, r13	; 0x800133 <xYieldPending>
    1118:	0a c0       	rjmp	.+20     	; 0x112e <xTaskResumeAll+0xa8>
    111a:	c0 e0       	ldi	r28, 0x00	; 0
    111c:	d0 e0       	ldi	r29, 0x00	; 0
    111e:	0f 2e       	mov	r0, r31
    1120:	fe e4       	ldi	r31, 0x4E	; 78
    1122:	ef 2e       	mov	r14, r31
    1124:	f1 e0       	ldi	r31, 0x01	; 1
    1126:	ff 2e       	mov	r15, r31
    1128:	f0 2d       	mov	r31, r0
    112a:	dd 24       	eor	r13, r13
    112c:	d3 94       	inc	r13
    112e:	f7 01       	movw	r30, r14
    1130:	80 81       	ld	r24, Z
    1132:	81 11       	cpse	r24, r1
    1134:	c0 cf       	rjmp	.-128    	; 0x10b6 <xTaskResumeAll+0x30>
    1136:	cd 2b       	or	r28, r29
    1138:	11 f0       	breq	.+4      	; 0x113e <xTaskResumeAll+0xb8>
    113a:	0e 94 79 05 	call	0xaf2	; 0xaf2 <prvResetNextTaskUnblockTime>
    113e:	c0 91 34 01 	lds	r28, 0x0134	; 0x800134 <xPendedTicks>
    1142:	d0 91 35 01 	lds	r29, 0x0135	; 0x800135 <xPendedTicks+0x1>
    1146:	20 97       	sbiw	r28, 0x00	; 0
    1148:	61 f0       	breq	.+24     	; 0x1162 <xTaskResumeAll+0xdc>
    114a:	11 e0       	ldi	r17, 0x01	; 1
    114c:	0e 94 84 07 	call	0xf08	; 0xf08 <xTaskIncrementTick>
    1150:	81 11       	cpse	r24, r1
    1152:	10 93 33 01 	sts	0x0133, r17	; 0x800133 <xYieldPending>
    1156:	21 97       	sbiw	r28, 0x01	; 1
    1158:	c9 f7       	brne	.-14     	; 0x114c <xTaskResumeAll+0xc6>
    115a:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <xPendedTicks+0x1>
    115e:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <xPendedTicks>
    1162:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xYieldPending>
    1166:	88 23       	and	r24, r24
    1168:	31 f0       	breq	.+12     	; 0x1176 <xTaskResumeAll+0xf0>
    116a:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
    116e:	81 e0       	ldi	r24, 0x01	; 1
    1170:	03 c0       	rjmp	.+6      	; 0x1178 <xTaskResumeAll+0xf2>
    1172:	80 e0       	ldi	r24, 0x00	; 0
    1174:	01 c0       	rjmp	.+2      	; 0x1178 <xTaskResumeAll+0xf2>
    1176:	80 e0       	ldi	r24, 0x00	; 0
    1178:	0f 90       	pop	r0
    117a:	0f be       	out	0x3f, r0	; 63
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	1f 91       	pop	r17
    1182:	0f 91       	pop	r16
    1184:	ff 90       	pop	r15
    1186:	ef 90       	pop	r14
    1188:	df 90       	pop	r13
    118a:	08 95       	ret

0000118c <vTaskSwitchContext>:
    118c:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxSchedulerSuspended>
    1190:	88 23       	and	r24, r24
    1192:	21 f0       	breq	.+8      	; 0x119c <vTaskSwitchContext+0x10>
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <xYieldPending>
    119a:	08 95       	ret
    119c:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <xYieldPending>
    11a0:	a0 91 91 01 	lds	r26, 0x0191	; 0x800191 <pxCurrentTCB>
    11a4:	b0 91 92 01 	lds	r27, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    11a8:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <pxCurrentTCB>
    11ac:	f0 91 92 01 	lds	r31, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    11b0:	2d 91       	ld	r18, X+
    11b2:	3c 91       	ld	r19, X
    11b4:	87 89       	ldd	r24, Z+23	; 0x17
    11b6:	90 8d       	ldd	r25, Z+24	; 0x18
    11b8:	82 17       	cp	r24, r18
    11ba:	93 07       	cpc	r25, r19
    11bc:	60 f0       	brcs	.+24     	; 0x11d6 <vTaskSwitchContext+0x4a>
    11be:	60 91 91 01 	lds	r22, 0x0191	; 0x800191 <pxCurrentTCB>
    11c2:	70 91 92 01 	lds	r23, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    11c6:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <pxCurrentTCB>
    11ca:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    11ce:	67 5e       	subi	r22, 0xE7	; 231
    11d0:	7f 4f       	sbci	r23, 0xFF	; 255
    11d2:	0e 94 c5 00 	call	0x18a	; 0x18a <vApplicationStackOverflowHook>
    11d6:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <uxTopReadyPriority>
    11da:	82 2f       	mov	r24, r18
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	fc 01       	movw	r30, r24
    11e0:	ee 0f       	add	r30, r30
    11e2:	ff 1f       	adc	r31, r31
    11e4:	ee 0f       	add	r30, r30
    11e6:	ff 1f       	adc	r31, r31
    11e8:	ee 0f       	add	r30, r30
    11ea:	ff 1f       	adc	r31, r31
    11ec:	e8 0f       	add	r30, r24
    11ee:	f9 1f       	adc	r31, r25
    11f0:	e3 59       	subi	r30, 0x93	; 147
    11f2:	fe 4f       	sbci	r31, 0xFE	; 254
    11f4:	30 81       	ld	r19, Z
    11f6:	31 11       	cpse	r19, r1
    11f8:	11 c0       	rjmp	.+34     	; 0x121c <vTaskSwitchContext+0x90>
    11fa:	21 50       	subi	r18, 0x01	; 1
    11fc:	82 2f       	mov	r24, r18
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	fc 01       	movw	r30, r24
    1202:	ee 0f       	add	r30, r30
    1204:	ff 1f       	adc	r31, r31
    1206:	ee 0f       	add	r30, r30
    1208:	ff 1f       	adc	r31, r31
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	e8 0f       	add	r30, r24
    1210:	f9 1f       	adc	r31, r25
    1212:	e3 59       	subi	r30, 0x93	; 147
    1214:	fe 4f       	sbci	r31, 0xFE	; 254
    1216:	30 81       	ld	r19, Z
    1218:	33 23       	and	r19, r19
    121a:	79 f3       	breq	.-34     	; 0x11fa <vTaskSwitchContext+0x6e>
    121c:	ac 01       	movw	r20, r24
    121e:	44 0f       	add	r20, r20
    1220:	55 1f       	adc	r21, r21
    1222:	44 0f       	add	r20, r20
    1224:	55 1f       	adc	r21, r21
    1226:	44 0f       	add	r20, r20
    1228:	55 1f       	adc	r21, r21
    122a:	48 0f       	add	r20, r24
    122c:	59 1f       	adc	r21, r25
    122e:	da 01       	movw	r26, r20
    1230:	a3 59       	subi	r26, 0x93	; 147
    1232:	be 4f       	sbci	r27, 0xFE	; 254
    1234:	11 96       	adiw	r26, 0x01	; 1
    1236:	ed 91       	ld	r30, X+
    1238:	fc 91       	ld	r31, X
    123a:	12 97       	sbiw	r26, 0x02	; 2
    123c:	02 80       	ldd	r0, Z+2	; 0x02
    123e:	f3 81       	ldd	r31, Z+3	; 0x03
    1240:	e0 2d       	mov	r30, r0
    1242:	12 96       	adiw	r26, 0x02	; 2
    1244:	fc 93       	st	X, r31
    1246:	ee 93       	st	-X, r30
    1248:	11 97       	sbiw	r26, 0x01	; 1
    124a:	40 59       	subi	r20, 0x90	; 144
    124c:	5e 4f       	sbci	r21, 0xFE	; 254
    124e:	e4 17       	cp	r30, r20
    1250:	f5 07       	cpc	r31, r21
    1252:	29 f4       	brne	.+10     	; 0x125e <vTaskSwitchContext+0xd2>
    1254:	42 81       	ldd	r20, Z+2	; 0x02
    1256:	53 81       	ldd	r21, Z+3	; 0x03
    1258:	fd 01       	movw	r30, r26
    125a:	52 83       	std	Z+2, r21	; 0x02
    125c:	41 83       	std	Z+1, r20	; 0x01
    125e:	fc 01       	movw	r30, r24
    1260:	ee 0f       	add	r30, r30
    1262:	ff 1f       	adc	r31, r31
    1264:	ee 0f       	add	r30, r30
    1266:	ff 1f       	adc	r31, r31
    1268:	ee 0f       	add	r30, r30
    126a:	ff 1f       	adc	r31, r31
    126c:	8e 0f       	add	r24, r30
    126e:	9f 1f       	adc	r25, r31
    1270:	fc 01       	movw	r30, r24
    1272:	e3 59       	subi	r30, 0x93	; 147
    1274:	fe 4f       	sbci	r31, 0xFE	; 254
    1276:	01 80       	ldd	r0, Z+1	; 0x01
    1278:	f2 81       	ldd	r31, Z+2	; 0x02
    127a:	e0 2d       	mov	r30, r0
    127c:	86 81       	ldd	r24, Z+6	; 0x06
    127e:	97 81       	ldd	r25, Z+7	; 0x07
    1280:	90 93 92 01 	sts	0x0192, r25	; 0x800192 <pxCurrentTCB+0x1>
    1284:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <pxCurrentTCB>
    1288:	20 93 37 01 	sts	0x0137, r18	; 0x800137 <uxTopReadyPriority>
    128c:	08 95       	ret

0000128e <vTaskPlaceOnEventList>:
    128e:	cf 93       	push	r28
    1290:	df 93       	push	r29
    1292:	eb 01       	movw	r28, r22
    1294:	60 91 91 01 	lds	r22, 0x0191	; 0x800191 <pxCurrentTCB>
    1298:	70 91 92 01 	lds	r23, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    129c:	64 5f       	subi	r22, 0xF4	; 244
    129e:	7f 4f       	sbci	r23, 0xFF	; 255
    12a0:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    12a4:	61 e0       	ldi	r22, 0x01	; 1
    12a6:	ce 01       	movw	r24, r28
    12a8:	0e 94 98 05 	call	0xb30	; 0xb30 <prvAddCurrentTaskToDelayedList>
    12ac:	df 91       	pop	r29
    12ae:	cf 91       	pop	r28
    12b0:	08 95       	ret

000012b2 <vTaskPlaceOnEventListRestricted>:
    12b2:	0f 93       	push	r16
    12b4:	1f 93       	push	r17
    12b6:	cf 93       	push	r28
    12b8:	8b 01       	movw	r16, r22
    12ba:	c4 2f       	mov	r28, r20
    12bc:	60 91 91 01 	lds	r22, 0x0191	; 0x800191 <pxCurrentTCB>
    12c0:	70 91 92 01 	lds	r23, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    12c4:	64 5f       	subi	r22, 0xF4	; 244
    12c6:	7f 4f       	sbci	r23, 0xFF	; 255
    12c8:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    12cc:	cc 23       	and	r28, r28
    12ce:	11 f0       	breq	.+4      	; 0x12d4 <vTaskPlaceOnEventListRestricted+0x22>
    12d0:	0f ef       	ldi	r16, 0xFF	; 255
    12d2:	1f ef       	ldi	r17, 0xFF	; 255
    12d4:	6c 2f       	mov	r22, r28
    12d6:	c8 01       	movw	r24, r16
    12d8:	0e 94 98 05 	call	0xb30	; 0xb30 <prvAddCurrentTaskToDelayedList>
    12dc:	cf 91       	pop	r28
    12de:	1f 91       	pop	r17
    12e0:	0f 91       	pop	r16
    12e2:	08 95       	ret

000012e4 <xTaskRemoveFromEventList>:
    12e4:	0f 93       	push	r16
    12e6:	1f 93       	push	r17
    12e8:	cf 93       	push	r28
    12ea:	df 93       	push	r29
    12ec:	dc 01       	movw	r26, r24
    12ee:	15 96       	adiw	r26, 0x05	; 5
    12f0:	ed 91       	ld	r30, X+
    12f2:	fc 91       	ld	r31, X
    12f4:	16 97       	sbiw	r26, 0x06	; 6
    12f6:	c6 81       	ldd	r28, Z+6	; 0x06
    12f8:	d7 81       	ldd	r29, Z+7	; 0x07
    12fa:	8e 01       	movw	r16, r28
    12fc:	04 5f       	subi	r16, 0xF4	; 244
    12fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1300:	c8 01       	movw	r24, r16
    1302:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    1306:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxSchedulerSuspended>
    130a:	81 11       	cpse	r24, r1
    130c:	1c c0       	rjmp	.+56     	; 0x1346 <xTaskRemoveFromEventList+0x62>
    130e:	0a 50       	subi	r16, 0x0A	; 10
    1310:	11 09       	sbc	r17, r1
    1312:	c8 01       	movw	r24, r16
    1314:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    1318:	8e 89       	ldd	r24, Y+22	; 0x16
    131a:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <uxTopReadyPriority>
    131e:	98 17       	cp	r25, r24
    1320:	10 f4       	brcc	.+4      	; 0x1326 <xTaskRemoveFromEventList+0x42>
    1322:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <uxTopReadyPriority>
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	9c 01       	movw	r18, r24
    132a:	22 0f       	add	r18, r18
    132c:	33 1f       	adc	r19, r19
    132e:	22 0f       	add	r18, r18
    1330:	33 1f       	adc	r19, r19
    1332:	22 0f       	add	r18, r18
    1334:	33 1f       	adc	r19, r19
    1336:	82 0f       	add	r24, r18
    1338:	93 1f       	adc	r25, r19
    133a:	b8 01       	movw	r22, r16
    133c:	83 59       	subi	r24, 0x93	; 147
    133e:	9e 4f       	sbci	r25, 0xFE	; 254
    1340:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1344:	05 c0       	rjmp	.+10     	; 0x1350 <xTaskRemoveFromEventList+0x6c>
    1346:	b8 01       	movw	r22, r16
    1348:	8e e4       	ldi	r24, 0x4E	; 78
    134a:	91 e0       	ldi	r25, 0x01	; 1
    134c:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1350:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <pxCurrentTCB>
    1354:	f0 91 92 01 	lds	r31, 0x0192	; 0x800192 <pxCurrentTCB+0x1>
    1358:	9e 89       	ldd	r25, Y+22	; 0x16
    135a:	86 89       	ldd	r24, Z+22	; 0x16
    135c:	89 17       	cp	r24, r25
    135e:	20 f4       	brcc	.+8      	; 0x1368 <xTaskRemoveFromEventList+0x84>
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <xYieldPending>
    1366:	01 c0       	rjmp	.+2      	; 0x136a <xTaskRemoveFromEventList+0x86>
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	df 91       	pop	r29
    136c:	cf 91       	pop	r28
    136e:	1f 91       	pop	r17
    1370:	0f 91       	pop	r16
    1372:	08 95       	ret

00001374 <vTaskInternalSetTimeOutState>:
    1374:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <xNumOfOverflows>
    1378:	fc 01       	movw	r30, r24
    137a:	20 83       	st	Z, r18
    137c:	20 91 38 01 	lds	r18, 0x0138	; 0x800138 <xTickCount>
    1380:	30 91 39 01 	lds	r19, 0x0139	; 0x800139 <xTickCount+0x1>
    1384:	32 83       	std	Z+2, r19	; 0x02
    1386:	21 83       	std	Z+1, r18	; 0x01
    1388:	08 95       	ret

0000138a <xTaskCheckForTimeOut>:
    138a:	cf 93       	push	r28
    138c:	df 93       	push	r29
    138e:	0f b6       	in	r0, 0x3f	; 63
    1390:	f8 94       	cli
    1392:	0f 92       	push	r0
    1394:	20 91 38 01 	lds	r18, 0x0138	; 0x800138 <xTickCount>
    1398:	30 91 39 01 	lds	r19, 0x0139	; 0x800139 <xTickCount+0x1>
    139c:	db 01       	movw	r26, r22
    139e:	4d 91       	ld	r20, X+
    13a0:	5c 91       	ld	r21, X
    13a2:	4f 3f       	cpi	r20, 0xFF	; 255
    13a4:	bf ef       	ldi	r27, 0xFF	; 255
    13a6:	5b 07       	cpc	r21, r27
    13a8:	f1 f0       	breq	.+60     	; 0x13e6 <xTaskCheckForTimeOut+0x5c>
    13aa:	ec 01       	movw	r28, r24
    13ac:	e9 81       	ldd	r30, Y+1	; 0x01
    13ae:	fa 81       	ldd	r31, Y+2	; 0x02
    13b0:	a0 91 32 01 	lds	r26, 0x0132	; 0x800132 <xNumOfOverflows>
    13b4:	b8 81       	ld	r27, Y
    13b6:	ba 17       	cp	r27, r26
    13b8:	19 f0       	breq	.+6      	; 0x13c0 <xTaskCheckForTimeOut+0x36>
    13ba:	2e 17       	cp	r18, r30
    13bc:	3f 07       	cpc	r19, r31
    13be:	a8 f4       	brcc	.+42     	; 0x13ea <xTaskCheckForTimeOut+0x60>
    13c0:	2e 1b       	sub	r18, r30
    13c2:	3f 0b       	sbc	r19, r31
    13c4:	24 17       	cp	r18, r20
    13c6:	35 07       	cpc	r19, r21
    13c8:	48 f4       	brcc	.+18     	; 0x13dc <xTaskCheckForTimeOut+0x52>
    13ca:	fb 01       	movw	r30, r22
    13cc:	42 1b       	sub	r20, r18
    13ce:	53 0b       	sbc	r21, r19
    13d0:	51 83       	std	Z+1, r21	; 0x01
    13d2:	40 83       	st	Z, r20
    13d4:	0e 94 ba 09 	call	0x1374	; 0x1374 <vTaskInternalSetTimeOutState>
    13d8:	80 e0       	ldi	r24, 0x00	; 0
    13da:	08 c0       	rjmp	.+16     	; 0x13ec <xTaskCheckForTimeOut+0x62>
    13dc:	fb 01       	movw	r30, r22
    13de:	11 82       	std	Z+1, r1	; 0x01
    13e0:	10 82       	st	Z, r1
    13e2:	81 e0       	ldi	r24, 0x01	; 1
    13e4:	03 c0       	rjmp	.+6      	; 0x13ec <xTaskCheckForTimeOut+0x62>
    13e6:	80 e0       	ldi	r24, 0x00	; 0
    13e8:	01 c0       	rjmp	.+2      	; 0x13ec <xTaskCheckForTimeOut+0x62>
    13ea:	81 e0       	ldi	r24, 0x01	; 1
    13ec:	0f 90       	pop	r0
    13ee:	0f be       	out	0x3f, r0	; 63
    13f0:	df 91       	pop	r29
    13f2:	cf 91       	pop	r28
    13f4:	08 95       	ret

000013f6 <vTaskMissedYield>:
    13f6:	81 e0       	ldi	r24, 0x01	; 1
    13f8:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <xYieldPending>
    13fc:	08 95       	ret

000013fe <xTaskGetSchedulerState>:
    13fe:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <xSchedulerRunning>
    1402:	88 23       	and	r24, r24
    1404:	31 f0       	breq	.+12     	; 0x1412 <xTaskGetSchedulerState+0x14>
    1406:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxSchedulerSuspended>
    140a:	88 23       	and	r24, r24
    140c:	21 f0       	breq	.+8      	; 0x1416 <xTaskGetSchedulerState+0x18>
    140e:	80 e0       	ldi	r24, 0x00	; 0
    1410:	08 95       	ret
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	08 95       	ret
    1416:	82 e0       	ldi	r24, 0x02	; 2
    1418:	08 95       	ret

0000141a <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    141a:	0f 93       	push	r16
    141c:	1f 93       	push	r17
    141e:	cf 93       	push	r28
    1420:	df 93       	push	r29
    1422:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    1424:	89 2b       	or	r24, r25
    1426:	79 f1       	breq	.+94     	; 0x1486 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    1428:	82 a1       	ldd	r24, Z+34	; 0x22
    142a:	81 50       	subi	r24, 0x01	; 1
    142c:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    142e:	26 89       	ldd	r18, Z+22	; 0x16
    1430:	91 a1       	ldd	r25, Z+33	; 0x21
    1432:	29 17       	cp	r18, r25
    1434:	51 f1       	breq	.+84     	; 0x148a <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1436:	81 11       	cpse	r24, r1
    1438:	2a c0       	rjmp	.+84     	; 0x148e <xTaskPriorityDisinherit+0x74>
    143a:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready/delayed list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    143c:	8f 01       	movw	r16, r30
    143e:	0e 5f       	subi	r16, 0xFE	; 254
    1440:	1f 4f       	sbci	r17, 0xFF	; 255
    1442:	c8 01       	movw	r24, r16
    1444:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    1448:	89 a1       	ldd	r24, Y+33	; 0x21
    144a:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    144c:	24 e0       	ldi	r18, 0x04	; 4
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	28 1b       	sub	r18, r24
    1452:	31 09       	sbc	r19, r1
    1454:	3d 87       	std	Y+13, r19	; 0x0d
    1456:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    1458:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <uxTopReadyPriority>
    145c:	98 17       	cp	r25, r24
    145e:	10 f4       	brcc	.+4      	; 0x1464 <xTaskPriorityDisinherit+0x4a>
    1460:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <uxTopReadyPriority>
    1464:	90 e0       	ldi	r25, 0x00	; 0
    1466:	9c 01       	movw	r18, r24
    1468:	22 0f       	add	r18, r18
    146a:	33 1f       	adc	r19, r19
    146c:	22 0f       	add	r18, r18
    146e:	33 1f       	adc	r19, r19
    1470:	22 0f       	add	r18, r18
    1472:	33 1f       	adc	r19, r19
    1474:	82 0f       	add	r24, r18
    1476:	93 1f       	adc	r25, r19
    1478:	b8 01       	movw	r22, r16
    147a:	83 59       	subi	r24, 0x93	; 147
    147c:	9e 4f       	sbci	r25, 0xFE	; 254
    147e:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    1482:	81 e0       	ldi	r24, 0x01	; 1
    1484:	05 c0       	rjmp	.+10     	; 0x1490 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    1486:	80 e0       	ldi	r24, 0x00	; 0
    1488:	03 c0       	rjmp	.+6      	; 0x1490 <xTaskPriorityDisinherit+0x76>
    148a:	80 e0       	ldi	r24, 0x00	; 0
    148c:	01 c0       	rjmp	.+2      	; 0x1490 <xTaskPriorityDisinherit+0x76>
    148e:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1490:	df 91       	pop	r29
    1492:	cf 91       	pop	r28
    1494:	1f 91       	pop	r17
    1496:	0f 91       	pop	r16
    1498:	08 95       	ret

0000149a <prvInsertTimerInActiveList>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    149a:	fc 01       	movw	r30, r24
    149c:	73 83       	std	Z+3, r23	; 0x03
    149e:	62 83       	std	Z+2, r22	; 0x02
    14a0:	91 87       	std	Z+9, r25	; 0x09
    14a2:	80 87       	std	Z+8, r24	; 0x08
    14a4:	46 17       	cp	r20, r22
    14a6:	57 07       	cpc	r21, r23
    14a8:	90 f0       	brcs	.+36     	; 0x14ce <prvInsertTimerInActiveList+0x34>
    14aa:	42 1b       	sub	r20, r18
    14ac:	53 0b       	sbc	r21, r19
    14ae:	84 85       	ldd	r24, Z+12	; 0x0c
    14b0:	95 85       	ldd	r25, Z+13	; 0x0d
    14b2:	48 17       	cp	r20, r24
    14b4:	59 07       	cpc	r21, r25
    14b6:	e0 f4       	brcc	.+56     	; 0x14f0 <prvInsertTimerInActiveList+0x56>
    14b8:	bf 01       	movw	r22, r30
    14ba:	6e 5f       	subi	r22, 0xFE	; 254
    14bc:	7f 4f       	sbci	r23, 0xFF	; 255
    14be:	80 91 99 01 	lds	r24, 0x0199	; 0x800199 <pxOverflowTimerList>
    14c2:	90 91 9a 01 	lds	r25, 0x019A	; 0x80019a <pxOverflowTimerList+0x1>
    14c6:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	08 95       	ret
    14ce:	42 17       	cp	r20, r18
    14d0:	53 07       	cpc	r21, r19
    14d2:	18 f4       	brcc	.+6      	; 0x14da <prvInsertTimerInActiveList+0x40>
    14d4:	62 17       	cp	r22, r18
    14d6:	73 07       	cpc	r23, r19
    14d8:	68 f4       	brcc	.+26     	; 0x14f4 <prvInsertTimerInActiveList+0x5a>
    14da:	bf 01       	movw	r22, r30
    14dc:	6e 5f       	subi	r22, 0xFE	; 254
    14de:	7f 4f       	sbci	r23, 0xFF	; 255
    14e0:	80 91 9b 01 	lds	r24, 0x019B	; 0x80019b <pxCurrentTimerList>
    14e4:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <pxCurrentTimerList+0x1>
    14e8:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    14ec:	80 e0       	ldi	r24, 0x00	; 0
    14ee:	08 95       	ret
    14f0:	81 e0       	ldi	r24, 0x01	; 1
    14f2:	08 95       	ret
    14f4:	81 e0       	ldi	r24, 0x01	; 1
    14f6:	08 95       	ret

000014f8 <prvCheckForValidListAndQueue>:
    14f8:	0f b6       	in	r0, 0x3f	; 63
    14fa:	f8 94       	cli
    14fc:	0f 92       	push	r0
    14fe:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <xTimerQueue>
    1502:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <xTimerQueue+0x1>
    1506:	89 2b       	or	r24, r25
    1508:	e9 f4       	brne	.+58     	; 0x1544 <prvCheckForValidListAndQueue+0x4c>
    150a:	86 ea       	ldi	r24, 0xA6	; 166
    150c:	91 e0       	ldi	r25, 0x01	; 1
    150e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
    1512:	8d e9       	ldi	r24, 0x9D	; 157
    1514:	91 e0       	ldi	r25, 0x01	; 1
    1516:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
    151a:	86 ea       	ldi	r24, 0xA6	; 166
    151c:	91 e0       	ldi	r25, 0x01	; 1
    151e:	90 93 9c 01 	sts	0x019C, r25	; 0x80019c <pxCurrentTimerList+0x1>
    1522:	80 93 9b 01 	sts	0x019B, r24	; 0x80019b <pxCurrentTimerList>
    1526:	8d e9       	ldi	r24, 0x9D	; 157
    1528:	91 e0       	ldi	r25, 0x01	; 1
    152a:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <pxOverflowTimerList+0x1>
    152e:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <pxOverflowTimerList>
    1532:	40 e0       	ldi	r20, 0x00	; 0
    1534:	65 e0       	ldi	r22, 0x05	; 5
    1536:	8a e0       	ldi	r24, 0x0A	; 10
    1538:	0e 94 a9 03 	call	0x752	; 0x752 <xQueueGenericCreate>
    153c:	90 93 98 01 	sts	0x0198, r25	; 0x800198 <xTimerQueue+0x1>
    1540:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <xTimerQueue>
    1544:	0f 90       	pop	r0
    1546:	0f be       	out	0x3f, r0	; 63
    1548:	08 95       	ret

0000154a <xTimerCreateTimerTask>:
    154a:	ef 92       	push	r14
    154c:	ff 92       	push	r15
    154e:	0f 93       	push	r16
    1550:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvCheckForValidListAndQueue>
    1554:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <xTimerQueue>
    1558:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <xTimerQueue+0x1>
    155c:	89 2b       	or	r24, r25
    155e:	91 f0       	breq	.+36     	; 0x1584 <xTimerCreateTimerTask+0x3a>
    1560:	0f 2e       	mov	r0, r31
    1562:	f5 e9       	ldi	r31, 0x95	; 149
    1564:	ef 2e       	mov	r14, r31
    1566:	f1 e0       	ldi	r31, 0x01	; 1
    1568:	ff 2e       	mov	r15, r31
    156a:	f0 2d       	mov	r31, r0
    156c:	03 e0       	ldi	r16, 0x03	; 3
    156e:	20 e0       	ldi	r18, 0x00	; 0
    1570:	30 e0       	ldi	r19, 0x00	; 0
    1572:	45 e5       	ldi	r20, 0x55	; 85
    1574:	50 e0       	ldi	r21, 0x00	; 0
    1576:	6d e1       	ldi	r22, 0x1D	; 29
    1578:	71 e0       	ldi	r23, 0x01	; 1
    157a:	8f e7       	ldi	r24, 0x7F	; 127
    157c:	9b e0       	ldi	r25, 0x0B	; 11
    157e:	0e 94 2a 06 	call	0xc54	; 0xc54 <xTaskCreate>
    1582:	01 c0       	rjmp	.+2      	; 0x1586 <xTimerCreateTimerTask+0x3c>
    1584:	80 e0       	ldi	r24, 0x00	; 0
    1586:	0f 91       	pop	r16
    1588:	ff 90       	pop	r15
    158a:	ef 90       	pop	r14
    158c:	08 95       	ret

0000158e <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    158e:	0f 93       	push	r16
    1590:	1f 93       	push	r17
    1592:	cf 93       	push	r28
    1594:	df 93       	push	r29
    1596:	00 d0       	rcall	.+0      	; 0x1598 <xTimerGenericCommand+0xa>
    1598:	00 d0       	rcall	.+0      	; 0x159a <xTimerGenericCommand+0xc>
    159a:	1f 92       	push	r1
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    15a0:	e0 91 97 01 	lds	r30, 0x0197	; 0x800197 <xTimerQueue>
    15a4:	f0 91 98 01 	lds	r31, 0x0198	; 0x800198 <xTimerQueue+0x1>
    15a8:	30 97       	sbiw	r30, 0x00	; 0
    15aa:	71 f1       	breq	.+92     	; 0x1608 <xTimerGenericCommand+0x7a>
    15ac:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    15ae:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    15b0:	5b 83       	std	Y+3, r21	; 0x03
    15b2:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    15b4:	9d 83       	std	Y+5, r25	; 0x05
    15b6:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    15b8:	66 30       	cpi	r22, 0x06	; 6
    15ba:	ec f4       	brge	.+58     	; 0x15f6 <xTimerGenericCommand+0x68>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    15bc:	0e 94 ff 09 	call	0x13fe	; 0x13fe <xTaskGetSchedulerState>
    15c0:	82 30       	cpi	r24, 0x02	; 2
    15c2:	61 f4       	brne	.+24     	; 0x15dc <xTimerGenericCommand+0x4e>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    15c4:	20 e0       	ldi	r18, 0x00	; 0
    15c6:	a8 01       	movw	r20, r16
    15c8:	be 01       	movw	r22, r28
    15ca:	6f 5f       	subi	r22, 0xFF	; 255
    15cc:	7f 4f       	sbci	r23, 0xFF	; 255
    15ce:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <xTimerQueue>
    15d2:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <xTimerQueue+0x1>
    15d6:	0e 94 cc 03 	call	0x798	; 0x798 <xQueueGenericSend>
    15da:	17 c0       	rjmp	.+46     	; 0x160a <xTimerGenericCommand+0x7c>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    15dc:	20 e0       	ldi	r18, 0x00	; 0
    15de:	40 e0       	ldi	r20, 0x00	; 0
    15e0:	50 e0       	ldi	r21, 0x00	; 0
    15e2:	be 01       	movw	r22, r28
    15e4:	6f 5f       	subi	r22, 0xFF	; 255
    15e6:	7f 4f       	sbci	r23, 0xFF	; 255
    15e8:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <xTimerQueue>
    15ec:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <xTimerQueue+0x1>
    15f0:	0e 94 cc 03 	call	0x798	; 0x798 <xQueueGenericSend>
    15f4:	0a c0       	rjmp	.+20     	; 0x160a <xTimerGenericCommand+0x7c>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    15f6:	20 e0       	ldi	r18, 0x00	; 0
    15f8:	ad 01       	movw	r20, r26
    15fa:	be 01       	movw	r22, r28
    15fc:	6f 5f       	subi	r22, 0xFF	; 255
    15fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1600:	cf 01       	movw	r24, r30
    1602:	0e 94 87 04 	call	0x90e	; 0x90e <xQueueGenericSendFromISR>
    1606:	01 c0       	rjmp	.+2      	; 0x160a <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    1608:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    160a:	0f 90       	pop	r0
    160c:	0f 90       	pop	r0
    160e:	0f 90       	pop	r0
    1610:	0f 90       	pop	r0
    1612:	0f 90       	pop	r0
    1614:	df 91       	pop	r29
    1616:	cf 91       	pop	r28
    1618:	1f 91       	pop	r17
    161a:	0f 91       	pop	r16
    161c:	08 95       	ret

0000161e <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    161e:	af 92       	push	r10
    1620:	bf 92       	push	r11
    1622:	cf 92       	push	r12
    1624:	df 92       	push	r13
    1626:	ef 92       	push	r14
    1628:	ff 92       	push	r15
    162a:	0f 93       	push	r16
    162c:	1f 93       	push	r17
    162e:	cf 93       	push	r28
    1630:	df 93       	push	r29
    1632:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    1634:	0e 94 7a 07 	call	0xef4	; 0xef4 <xTaskGetTickCount>
    1638:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    163a:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <xLastTime.2416>
    163e:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <xLastTime.2416+0x1>
    1642:	e8 16       	cp	r14, r24
    1644:	f9 06       	cpc	r15, r25
    1646:	08 f0       	brcs	.+2      	; 0x164a <prvSampleTimeNow+0x2c>
    1648:	48 c0       	rjmp	.+144    	; 0x16da <prvSampleTimeNow+0xbc>
    164a:	30 c0       	rjmp	.+96     	; 0x16ac <prvSampleTimeNow+0x8e>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    164c:	05 80       	ldd	r0, Z+5	; 0x05
    164e:	f6 81       	ldd	r31, Z+6	; 0x06
    1650:	e0 2d       	mov	r30, r0
    1652:	a0 80       	ld	r10, Z
    1654:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1656:	c6 81       	ldd	r28, Z+6	; 0x06
    1658:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    165a:	8e 01       	movw	r16, r28
    165c:	0e 5f       	subi	r16, 0xFE	; 254
    165e:	1f 4f       	sbci	r17, 0xFF	; 255
    1660:	c8 01       	movw	r24, r16
    1662:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1666:	e8 89       	ldd	r30, Y+16	; 0x10
    1668:	f9 89       	ldd	r31, Y+17	; 0x11
    166a:	ce 01       	movw	r24, r28
    166c:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    166e:	8a 89       	ldd	r24, Y+18	; 0x12
    1670:	82 ff       	sbrs	r24, 2
    1672:	1c c0       	rjmp	.+56     	; 0x16ac <prvSampleTimeNow+0x8e>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1674:	8c 85       	ldd	r24, Y+12	; 0x0c
    1676:	9d 85       	ldd	r25, Y+13	; 0x0d
    1678:	8a 0d       	add	r24, r10
    167a:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    167c:	a8 16       	cp	r10, r24
    167e:	b9 06       	cpc	r11, r25
    1680:	60 f4       	brcc	.+24     	; 0x169a <prvSampleTimeNow+0x7c>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1682:	9b 83       	std	Y+3, r25	; 0x03
    1684:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1686:	d9 87       	std	Y+9, r29	; 0x09
    1688:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    168a:	b8 01       	movw	r22, r16
    168c:	80 91 9b 01 	lds	r24, 0x019B	; 0x80019b <pxCurrentTimerList>
    1690:	90 91 9c 01 	lds	r25, 0x019C	; 0x80019c <pxCurrentTimerList+0x1>
    1694:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    1698:	09 c0       	rjmp	.+18     	; 0x16ac <prvSampleTimeNow+0x8e>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    169a:	00 e0       	ldi	r16, 0x00	; 0
    169c:	10 e0       	ldi	r17, 0x00	; 0
    169e:	20 e0       	ldi	r18, 0x00	; 0
    16a0:	30 e0       	ldi	r19, 0x00	; 0
    16a2:	a5 01       	movw	r20, r10
    16a4:	60 e0       	ldi	r22, 0x00	; 0
    16a6:	ce 01       	movw	r24, r28
    16a8:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    16ac:	e0 91 9b 01 	lds	r30, 0x019B	; 0x80019b <pxCurrentTimerList>
    16b0:	f0 91 9c 01 	lds	r31, 0x019C	; 0x80019c <pxCurrentTimerList+0x1>
    16b4:	80 81       	ld	r24, Z
    16b6:	81 11       	cpse	r24, r1
    16b8:	c9 cf       	rjmp	.-110    	; 0x164c <prvSampleTimeNow+0x2e>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    16ba:	80 91 99 01 	lds	r24, 0x0199	; 0x800199 <pxOverflowTimerList>
    16be:	90 91 9a 01 	lds	r25, 0x019A	; 0x80019a <pxOverflowTimerList+0x1>
    16c2:	90 93 9c 01 	sts	0x019C, r25	; 0x80019c <pxCurrentTimerList+0x1>
    16c6:	80 93 9b 01 	sts	0x019B, r24	; 0x80019b <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    16ca:	f0 93 9a 01 	sts	0x019A, r31	; 0x80019a <pxOverflowTimerList+0x1>
    16ce:	e0 93 99 01 	sts	0x0199, r30	; 0x800199 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	f6 01       	movw	r30, r12
    16d6:	80 83       	st	Z, r24
    16d8:	02 c0       	rjmp	.+4      	; 0x16de <prvSampleTimeNow+0xc0>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    16da:	f6 01       	movw	r30, r12
    16dc:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    16de:	f0 92 94 01 	sts	0x0194, r15	; 0x800194 <xLastTime.2416+0x1>
    16e2:	e0 92 93 01 	sts	0x0193, r14	; 0x800193 <xLastTime.2416>

    return xTimeNow;
}
    16e6:	c7 01       	movw	r24, r14
    16e8:	df 91       	pop	r29
    16ea:	cf 91       	pop	r28
    16ec:	1f 91       	pop	r17
    16ee:	0f 91       	pop	r16
    16f0:	ff 90       	pop	r15
    16f2:	ef 90       	pop	r14
    16f4:	df 90       	pop	r13
    16f6:	cf 90       	pop	r12
    16f8:	bf 90       	pop	r11
    16fa:	af 90       	pop	r10
    16fc:	08 95       	ret

000016fe <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
    1702:	00 d0       	rcall	.+0      	; 0x1704 <prvTimerTask+0x6>
    1704:	00 d0       	rcall	.+0      	; 0x1706 <prvTimerTask+0x8>
    1706:	00 d0       	rcall	.+0      	; 0x1708 <prvTimerTask+0xa>
    1708:	cd b7       	in	r28, 0x3d	; 61
    170a:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    170c:	ce 01       	movw	r24, r28
    170e:	01 96       	adiw	r24, 0x01	; 1
    1710:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1712:	44 24       	eor	r4, r4
    1714:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    1716:	e1 2c       	mov	r14, r1
    1718:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    171a:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    171c:	c8 2e       	mov	r12, r24
    171e:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1720:	e0 91 9b 01 	lds	r30, 0x019B	; 0x80019b <pxCurrentTimerList>
    1724:	f0 91 9c 01 	lds	r31, 0x019C	; 0x80019c <pxCurrentTimerList+0x1>
    1728:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    172a:	88 23       	and	r24, r24
    172c:	09 f4       	brne	.+2      	; 0x1730 <prvTimerTask+0x32>
    172e:	dc c0       	rjmp	.+440    	; 0x18e8 <prvTimerTask+0x1ea>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1730:	05 80       	ldd	r0, Z+5	; 0x05
    1732:	f6 81       	ldd	r31, Z+6	; 0x06
    1734:	e0 2d       	mov	r30, r0
    1736:	a0 80       	ld	r10, Z
    1738:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    173a:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    173e:	c4 01       	movw	r24, r8
    1740:	0e 94 0f 0b 	call	0x161e	; 0x161e <prvSampleTimeNow>
    1744:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    1746:	89 81       	ldd	r24, Y+1	; 0x01
    1748:	81 11       	cpse	r24, r1
    174a:	4b c0       	rjmp	.+150    	; 0x17e2 <prvTimerTask+0xe4>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    174c:	0a 15       	cp	r16, r10
    174e:	1b 05       	cpc	r17, r11
    1750:	b8 f1       	brcs	.+110    	; 0x17c0 <prvTimerTask+0xc2>
            {
                ( void ) xTaskResumeAll();
    1752:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1756:	e0 91 9b 01 	lds	r30, 0x019B	; 0x80019b <pxCurrentTimerList>
    175a:	f0 91 9c 01 	lds	r31, 0x019C	; 0x80019c <pxCurrentTimerList+0x1>
    175e:	05 80       	ldd	r0, Z+5	; 0x05
    1760:	f6 81       	ldd	r31, Z+6	; 0x06
    1762:	e0 2d       	mov	r30, r0
    1764:	66 80       	ldd	r6, Z+6	; 0x06
    1766:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1768:	c3 01       	movw	r24, r6
    176a:	02 96       	adiw	r24, 0x02	; 2
    176c:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto-reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1770:	d3 01       	movw	r26, r6
    1772:	52 96       	adiw	r26, 0x12	; 18
    1774:	8c 91       	ld	r24, X
    1776:	52 97       	sbiw	r26, 0x12	; 18
    1778:	82 ff       	sbrs	r24, 2
    177a:	17 c0       	rjmp	.+46     	; 0x17aa <prvTimerTask+0xac>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    177c:	1c 96       	adiw	r26, 0x0c	; 12
    177e:	6d 91       	ld	r22, X+
    1780:	7c 91       	ld	r23, X
    1782:	1d 97       	sbiw	r26, 0x0d	; 13
    1784:	6a 0d       	add	r22, r10
    1786:	7b 1d       	adc	r23, r11
    1788:	95 01       	movw	r18, r10
    178a:	a8 01       	movw	r20, r16
    178c:	c3 01       	movw	r24, r6
    178e:	0e 94 4d 0a 	call	0x149a	; 0x149a <prvInsertTimerInActiveList>
    1792:	88 23       	and	r24, r24
    1794:	69 f0       	breq	.+26     	; 0x17b0 <prvTimerTask+0xb2>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1796:	0e 2d       	mov	r16, r14
    1798:	1f 2d       	mov	r17, r15
    179a:	2e 2d       	mov	r18, r14
    179c:	3f 2d       	mov	r19, r15
    179e:	a5 01       	movw	r20, r10
    17a0:	65 2d       	mov	r22, r5
    17a2:	c3 01       	movw	r24, r6
    17a4:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTimerGenericCommand>
    17a8:	03 c0       	rjmp	.+6      	; 0x17b0 <prvTimerTask+0xb2>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    17aa:	8e 7f       	andi	r24, 0xFE	; 254
    17ac:	f3 01       	movw	r30, r6
    17ae:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    17b0:	d3 01       	movw	r26, r6
    17b2:	50 96       	adiw	r26, 0x10	; 16
    17b4:	ed 91       	ld	r30, X+
    17b6:	fc 91       	ld	r31, X
    17b8:	51 97       	sbiw	r26, 0x11	; 17
    17ba:	c3 01       	movw	r24, r6
    17bc:	09 95       	icall
    17be:	87 c0       	rjmp	.+270    	; 0x18ce <prvTimerTask+0x1d0>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    17c0:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    17c2:	b5 01       	movw	r22, r10
    17c4:	60 1b       	sub	r22, r16
    17c6:	71 0b       	sbc	r23, r17
    17c8:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <xTimerQueue>
    17cc:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <xTimerQueue+0x1>
    17d0:	0e 94 5c 05 	call	0xab8	; 0xab8 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    17d4:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
    17d8:	81 11       	cpse	r24, r1
    17da:	79 c0       	rjmp	.+242    	; 0x18ce <prvTimerTask+0x1d0>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    17dc:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYield>
    17e0:	76 c0       	rjmp	.+236    	; 0x18ce <prvTimerTask+0x1d0>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    17e2:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskResumeAll>
    17e6:	73 c0       	rjmp	.+230    	; 0x18ce <prvTimerTask+0x1d0>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    17e8:	89 81       	ldd	r24, Y+1	; 0x01
    17ea:	88 23       	and	r24, r24
    17ec:	0c f4       	brge	.+2      	; 0x17f0 <prvTimerTask+0xf2>
    17ee:	6f c0       	rjmp	.+222    	; 0x18ce <prvTimerTask+0x1d0>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    17f0:	ac 80       	ldd	r10, Y+4	; 0x04
    17f2:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    17f4:	f5 01       	movw	r30, r10
    17f6:	82 85       	ldd	r24, Z+10	; 0x0a
    17f8:	93 85       	ldd	r25, Z+11	; 0x0b
    17fa:	89 2b       	or	r24, r25
    17fc:	21 f0       	breq	.+8      	; 0x1806 <prvTimerTask+0x108>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    17fe:	c5 01       	movw	r24, r10
    1800:	02 96       	adiw	r24, 0x02	; 2
    1802:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1806:	ce 01       	movw	r24, r28
    1808:	06 96       	adiw	r24, 0x06	; 6
    180a:	0e 94 0f 0b 	call	0x161e	; 0x161e <prvSampleTimeNow>

            switch( xMessage.xMessageID )
    180e:	e9 81       	ldd	r30, Y+1	; 0x01
    1810:	0e 2e       	mov	r0, r30
    1812:	00 0c       	add	r0, r0
    1814:	ff 0b       	sbc	r31, r31
    1816:	ea 30       	cpi	r30, 0x0A	; 10
    1818:	f1 05       	cpc	r31, r1
    181a:	08 f0       	brcs	.+2      	; 0x181e <prvTimerTask+0x120>
    181c:	58 c0       	rjmp	.+176    	; 0x18ce <prvTimerTask+0x1d0>
    181e:	ea 5a       	subi	r30, 0xAA	; 170
    1820:	ff 4f       	sbci	r31, 0xFF	; 255
    1822:	0c 94 88 0c 	jmp	0x1910	; 0x1910 <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    1826:	d5 01       	movw	r26, r10
    1828:	52 96       	adiw	r26, 0x12	; 18
    182a:	2c 91       	ld	r18, X
    182c:	52 97       	sbiw	r26, 0x12	; 18
    182e:	21 60       	ori	r18, 0x01	; 1
    1830:	52 96       	adiw	r26, 0x12	; 18
    1832:	2c 93       	st	X, r18
    1834:	52 97       	sbiw	r26, 0x12	; 18
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1836:	2a 81       	ldd	r18, Y+2	; 0x02
    1838:	3b 81       	ldd	r19, Y+3	; 0x03
    183a:	1c 96       	adiw	r26, 0x0c	; 12
    183c:	6d 91       	ld	r22, X+
    183e:	7c 91       	ld	r23, X
    1840:	1d 97       	sbiw	r26, 0x0d	; 13
    1842:	62 0f       	add	r22, r18
    1844:	73 1f       	adc	r23, r19
    1846:	ac 01       	movw	r20, r24
    1848:	c5 01       	movw	r24, r10
    184a:	0e 94 4d 0a 	call	0x149a	; 0x149a <prvInsertTimerInActiveList>
    184e:	88 23       	and	r24, r24
    1850:	f1 f1       	breq	.+124    	; 0x18ce <prvTimerTask+0x1d0>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1852:	d5 01       	movw	r26, r10
    1854:	50 96       	adiw	r26, 0x10	; 16
    1856:	ed 91       	ld	r30, X+
    1858:	fc 91       	ld	r31, X
    185a:	51 97       	sbiw	r26, 0x11	; 17
    185c:	c5 01       	movw	r24, r10
    185e:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1860:	f5 01       	movw	r30, r10
    1862:	82 89       	ldd	r24, Z+18	; 0x12
    1864:	82 ff       	sbrs	r24, 2
    1866:	33 c0       	rjmp	.+102    	; 0x18ce <prvTimerTask+0x1d0>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1868:	4a 81       	ldd	r20, Y+2	; 0x02
    186a:	5b 81       	ldd	r21, Y+3	; 0x03
    186c:	84 85       	ldd	r24, Z+12	; 0x0c
    186e:	95 85       	ldd	r25, Z+13	; 0x0d
    1870:	48 0f       	add	r20, r24
    1872:	59 1f       	adc	r21, r25
    1874:	0e 2d       	mov	r16, r14
    1876:	1f 2d       	mov	r17, r15
    1878:	2e 2d       	mov	r18, r14
    187a:	3f 2d       	mov	r19, r15
    187c:	65 2d       	mov	r22, r5
    187e:	c5 01       	movw	r24, r10
    1880:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTimerGenericCommand>
    1884:	24 c0       	rjmp	.+72     	; 0x18ce <prvTimerTask+0x1d0>
                    break;

                case tmrCOMMAND_STOP :
                case tmrCOMMAND_STOP_FROM_ISR :
                    /* The timer has already been removed from the active list. */
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1886:	d5 01       	movw	r26, r10
    1888:	52 96       	adiw	r26, 0x12	; 18
    188a:	8c 91       	ld	r24, X
    188c:	52 97       	sbiw	r26, 0x12	; 18
    188e:	8e 7f       	andi	r24, 0xFE	; 254
    1890:	52 96       	adiw	r26, 0x12	; 18
    1892:	8c 93       	st	X, r24
    1894:	1c c0       	rjmp	.+56     	; 0x18ce <prvTimerTask+0x1d0>
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    1896:	f5 01       	movw	r30, r10
    1898:	22 89       	ldd	r18, Z+18	; 0x12
    189a:	21 60       	ori	r18, 0x01	; 1
    189c:	22 8b       	std	Z+18, r18	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    189e:	6a 81       	ldd	r22, Y+2	; 0x02
    18a0:	7b 81       	ldd	r23, Y+3	; 0x03
    18a2:	75 87       	std	Z+13, r23	; 0x0d
    18a4:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    18a6:	68 0f       	add	r22, r24
    18a8:	79 1f       	adc	r23, r25
    18aa:	9c 01       	movw	r18, r24
    18ac:	ac 01       	movw	r20, r24
    18ae:	c5 01       	movw	r24, r10
    18b0:	0e 94 4d 0a 	call	0x149a	; 0x149a <prvInsertTimerInActiveList>
    18b4:	0c c0       	rjmp	.+24     	; 0x18ce <prvTimerTask+0x1d0>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    18b6:	d5 01       	movw	r26, r10
    18b8:	52 96       	adiw	r26, 0x12	; 18
    18ba:	8c 91       	ld	r24, X
    18bc:	81 fd       	sbrc	r24, 1
    18be:	04 c0       	rjmp	.+8      	; 0x18c8 <prvTimerTask+0x1ca>
                        {
                            vPortFree( pxTimer );
    18c0:	c5 01       	movw	r24, r10
    18c2:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
    18c6:	03 c0       	rjmp	.+6      	; 0x18ce <prvTimerTask+0x1d0>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    18c8:	8e 7f       	andi	r24, 0xFE	; 254
    18ca:	f5 01       	movw	r30, r10
    18cc:	82 8b       	std	Z+18, r24	; 0x12
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    18ce:	4e 2d       	mov	r20, r14
    18d0:	5f 2d       	mov	r21, r15
    18d2:	6c 2d       	mov	r22, r12
    18d4:	7d 2d       	mov	r23, r13
    18d6:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <xTimerQueue>
    18da:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <xTimerQueue+0x1>
    18de:	0e 94 c3 04 	call	0x986	; 0x986 <xQueueReceive>
    18e2:	81 11       	cpse	r24, r1
    18e4:	81 cf       	rjmp	.-254    	; 0x17e8 <prvTimerTask+0xea>
    18e6:	1c cf       	rjmp	.-456    	; 0x1720 <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    18e8:	0e 94 74 07 	call	0xee8	; 0xee8 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    18ec:	c4 01       	movw	r24, r8
    18ee:	0e 94 0f 0b 	call	0x161e	; 0x161e <prvSampleTimeNow>
    18f2:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    18f4:	89 81       	ldd	r24, Y+1	; 0x01
    18f6:	81 11       	cpse	r24, r1
    18f8:	74 cf       	rjmp	.-280    	; 0x17e2 <prvTimerTask+0xe4>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    18fa:	e0 91 99 01 	lds	r30, 0x0199	; 0x800199 <pxOverflowTimerList>
    18fe:	f0 91 9a 01 	lds	r31, 0x019A	; 0x80019a <pxOverflowTimerList+0x1>
    1902:	80 81       	ld	r24, Z
    1904:	44 2d       	mov	r20, r4
    1906:	81 11       	cpse	r24, r1
    1908:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    190a:	ae 2c       	mov	r10, r14
    190c:	bf 2c       	mov	r11, r15
    190e:	59 cf       	rjmp	.-334    	; 0x17c2 <prvTimerTask+0xc4>

00001910 <__tablejump2__>:
    1910:	ee 0f       	add	r30, r30
    1912:	ff 1f       	adc	r31, r31
    1914:	05 90       	lpm	r0, Z+
    1916:	f4 91       	lpm	r31, Z
    1918:	e0 2d       	mov	r30, r0
    191a:	09 94       	ijmp

0000191c <malloc>:
    191c:	0f 93       	push	r16
    191e:	1f 93       	push	r17
    1920:	cf 93       	push	r28
    1922:	df 93       	push	r29
    1924:	82 30       	cpi	r24, 0x02	; 2
    1926:	91 05       	cpc	r25, r1
    1928:	10 f4       	brcc	.+4      	; 0x192e <malloc+0x12>
    192a:	82 e0       	ldi	r24, 0x02	; 2
    192c:	90 e0       	ldi	r25, 0x00	; 0
    192e:	e0 91 b1 01 	lds	r30, 0x01B1	; 0x8001b1 <__flp>
    1932:	f0 91 b2 01 	lds	r31, 0x01B2	; 0x8001b2 <__flp+0x1>
    1936:	20 e0       	ldi	r18, 0x00	; 0
    1938:	30 e0       	ldi	r19, 0x00	; 0
    193a:	a0 e0       	ldi	r26, 0x00	; 0
    193c:	b0 e0       	ldi	r27, 0x00	; 0
    193e:	30 97       	sbiw	r30, 0x00	; 0
    1940:	19 f1       	breq	.+70     	; 0x1988 <malloc+0x6c>
    1942:	40 81       	ld	r20, Z
    1944:	51 81       	ldd	r21, Z+1	; 0x01
    1946:	02 81       	ldd	r16, Z+2	; 0x02
    1948:	13 81       	ldd	r17, Z+3	; 0x03
    194a:	48 17       	cp	r20, r24
    194c:	59 07       	cpc	r21, r25
    194e:	c8 f0       	brcs	.+50     	; 0x1982 <malloc+0x66>
    1950:	84 17       	cp	r24, r20
    1952:	95 07       	cpc	r25, r21
    1954:	69 f4       	brne	.+26     	; 0x1970 <malloc+0x54>
    1956:	10 97       	sbiw	r26, 0x00	; 0
    1958:	31 f0       	breq	.+12     	; 0x1966 <malloc+0x4a>
    195a:	12 96       	adiw	r26, 0x02	; 2
    195c:	0c 93       	st	X, r16
    195e:	12 97       	sbiw	r26, 0x02	; 2
    1960:	13 96       	adiw	r26, 0x03	; 3
    1962:	1c 93       	st	X, r17
    1964:	27 c0       	rjmp	.+78     	; 0x19b4 <malloc+0x98>
    1966:	00 93 b1 01 	sts	0x01B1, r16	; 0x8001b1 <__flp>
    196a:	10 93 b2 01 	sts	0x01B2, r17	; 0x8001b2 <__flp+0x1>
    196e:	22 c0       	rjmp	.+68     	; 0x19b4 <malloc+0x98>
    1970:	21 15       	cp	r18, r1
    1972:	31 05       	cpc	r19, r1
    1974:	19 f0       	breq	.+6      	; 0x197c <malloc+0x60>
    1976:	42 17       	cp	r20, r18
    1978:	53 07       	cpc	r21, r19
    197a:	18 f4       	brcc	.+6      	; 0x1982 <malloc+0x66>
    197c:	9a 01       	movw	r18, r20
    197e:	bd 01       	movw	r22, r26
    1980:	ef 01       	movw	r28, r30
    1982:	df 01       	movw	r26, r30
    1984:	f8 01       	movw	r30, r16
    1986:	db cf       	rjmp	.-74     	; 0x193e <malloc+0x22>
    1988:	21 15       	cp	r18, r1
    198a:	31 05       	cpc	r19, r1
    198c:	f9 f0       	breq	.+62     	; 0x19cc <malloc+0xb0>
    198e:	28 1b       	sub	r18, r24
    1990:	39 0b       	sbc	r19, r25
    1992:	24 30       	cpi	r18, 0x04	; 4
    1994:	31 05       	cpc	r19, r1
    1996:	80 f4       	brcc	.+32     	; 0x19b8 <malloc+0x9c>
    1998:	8a 81       	ldd	r24, Y+2	; 0x02
    199a:	9b 81       	ldd	r25, Y+3	; 0x03
    199c:	61 15       	cp	r22, r1
    199e:	71 05       	cpc	r23, r1
    19a0:	21 f0       	breq	.+8      	; 0x19aa <malloc+0x8e>
    19a2:	fb 01       	movw	r30, r22
    19a4:	93 83       	std	Z+3, r25	; 0x03
    19a6:	82 83       	std	Z+2, r24	; 0x02
    19a8:	04 c0       	rjmp	.+8      	; 0x19b2 <malloc+0x96>
    19aa:	90 93 b2 01 	sts	0x01B2, r25	; 0x8001b2 <__flp+0x1>
    19ae:	80 93 b1 01 	sts	0x01B1, r24	; 0x8001b1 <__flp>
    19b2:	fe 01       	movw	r30, r28
    19b4:	32 96       	adiw	r30, 0x02	; 2
    19b6:	44 c0       	rjmp	.+136    	; 0x1a40 <malloc+0x124>
    19b8:	fe 01       	movw	r30, r28
    19ba:	e2 0f       	add	r30, r18
    19bc:	f3 1f       	adc	r31, r19
    19be:	81 93       	st	Z+, r24
    19c0:	91 93       	st	Z+, r25
    19c2:	22 50       	subi	r18, 0x02	; 2
    19c4:	31 09       	sbc	r19, r1
    19c6:	39 83       	std	Y+1, r19	; 0x01
    19c8:	28 83       	st	Y, r18
    19ca:	3a c0       	rjmp	.+116    	; 0x1a40 <malloc+0x124>
    19cc:	20 91 af 01 	lds	r18, 0x01AF	; 0x8001af <__brkval>
    19d0:	30 91 b0 01 	lds	r19, 0x01B0	; 0x8001b0 <__brkval+0x1>
    19d4:	23 2b       	or	r18, r19
    19d6:	41 f4       	brne	.+16     	; 0x19e8 <malloc+0xcc>
    19d8:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    19dc:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    19e0:	30 93 b0 01 	sts	0x01B0, r19	; 0x8001b0 <__brkval+0x1>
    19e4:	20 93 af 01 	sts	0x01AF, r18	; 0x8001af <__brkval>
    19e8:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    19ec:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    19f0:	21 15       	cp	r18, r1
    19f2:	31 05       	cpc	r19, r1
    19f4:	41 f4       	brne	.+16     	; 0x1a06 <malloc+0xea>
    19f6:	2d b7       	in	r18, 0x3d	; 61
    19f8:	3e b7       	in	r19, 0x3e	; 62
    19fa:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    19fe:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1a02:	24 1b       	sub	r18, r20
    1a04:	35 0b       	sbc	r19, r21
    1a06:	e0 91 af 01 	lds	r30, 0x01AF	; 0x8001af <__brkval>
    1a0a:	f0 91 b0 01 	lds	r31, 0x01B0	; 0x8001b0 <__brkval+0x1>
    1a0e:	e2 17       	cp	r30, r18
    1a10:	f3 07       	cpc	r31, r19
    1a12:	a0 f4       	brcc	.+40     	; 0x1a3c <malloc+0x120>
    1a14:	2e 1b       	sub	r18, r30
    1a16:	3f 0b       	sbc	r19, r31
    1a18:	28 17       	cp	r18, r24
    1a1a:	39 07       	cpc	r19, r25
    1a1c:	78 f0       	brcs	.+30     	; 0x1a3c <malloc+0x120>
    1a1e:	ac 01       	movw	r20, r24
    1a20:	4e 5f       	subi	r20, 0xFE	; 254
    1a22:	5f 4f       	sbci	r21, 0xFF	; 255
    1a24:	24 17       	cp	r18, r20
    1a26:	35 07       	cpc	r19, r21
    1a28:	48 f0       	brcs	.+18     	; 0x1a3c <malloc+0x120>
    1a2a:	4e 0f       	add	r20, r30
    1a2c:	5f 1f       	adc	r21, r31
    1a2e:	50 93 b0 01 	sts	0x01B0, r21	; 0x8001b0 <__brkval+0x1>
    1a32:	40 93 af 01 	sts	0x01AF, r20	; 0x8001af <__brkval>
    1a36:	81 93       	st	Z+, r24
    1a38:	91 93       	st	Z+, r25
    1a3a:	02 c0       	rjmp	.+4      	; 0x1a40 <malloc+0x124>
    1a3c:	e0 e0       	ldi	r30, 0x00	; 0
    1a3e:	f0 e0       	ldi	r31, 0x00	; 0
    1a40:	cf 01       	movw	r24, r30
    1a42:	df 91       	pop	r29
    1a44:	cf 91       	pop	r28
    1a46:	1f 91       	pop	r17
    1a48:	0f 91       	pop	r16
    1a4a:	08 95       	ret

00001a4c <free>:
    1a4c:	cf 93       	push	r28
    1a4e:	df 93       	push	r29
    1a50:	00 97       	sbiw	r24, 0x00	; 0
    1a52:	09 f4       	brne	.+2      	; 0x1a56 <free+0xa>
    1a54:	81 c0       	rjmp	.+258    	; 0x1b58 <free+0x10c>
    1a56:	fc 01       	movw	r30, r24
    1a58:	32 97       	sbiw	r30, 0x02	; 2
    1a5a:	13 82       	std	Z+3, r1	; 0x03
    1a5c:	12 82       	std	Z+2, r1	; 0x02
    1a5e:	a0 91 b1 01 	lds	r26, 0x01B1	; 0x8001b1 <__flp>
    1a62:	b0 91 b2 01 	lds	r27, 0x01B2	; 0x8001b2 <__flp+0x1>
    1a66:	10 97       	sbiw	r26, 0x00	; 0
    1a68:	81 f4       	brne	.+32     	; 0x1a8a <free+0x3e>
    1a6a:	20 81       	ld	r18, Z
    1a6c:	31 81       	ldd	r19, Z+1	; 0x01
    1a6e:	82 0f       	add	r24, r18
    1a70:	93 1f       	adc	r25, r19
    1a72:	20 91 af 01 	lds	r18, 0x01AF	; 0x8001af <__brkval>
    1a76:	30 91 b0 01 	lds	r19, 0x01B0	; 0x8001b0 <__brkval+0x1>
    1a7a:	28 17       	cp	r18, r24
    1a7c:	39 07       	cpc	r19, r25
    1a7e:	51 f5       	brne	.+84     	; 0x1ad4 <free+0x88>
    1a80:	f0 93 b0 01 	sts	0x01B0, r31	; 0x8001b0 <__brkval+0x1>
    1a84:	e0 93 af 01 	sts	0x01AF, r30	; 0x8001af <__brkval>
    1a88:	67 c0       	rjmp	.+206    	; 0x1b58 <free+0x10c>
    1a8a:	ed 01       	movw	r28, r26
    1a8c:	20 e0       	ldi	r18, 0x00	; 0
    1a8e:	30 e0       	ldi	r19, 0x00	; 0
    1a90:	ce 17       	cp	r28, r30
    1a92:	df 07       	cpc	r29, r31
    1a94:	40 f4       	brcc	.+16     	; 0x1aa6 <free+0x5a>
    1a96:	4a 81       	ldd	r20, Y+2	; 0x02
    1a98:	5b 81       	ldd	r21, Y+3	; 0x03
    1a9a:	9e 01       	movw	r18, r28
    1a9c:	41 15       	cp	r20, r1
    1a9e:	51 05       	cpc	r21, r1
    1aa0:	f1 f0       	breq	.+60     	; 0x1ade <free+0x92>
    1aa2:	ea 01       	movw	r28, r20
    1aa4:	f5 cf       	rjmp	.-22     	; 0x1a90 <free+0x44>
    1aa6:	d3 83       	std	Z+3, r29	; 0x03
    1aa8:	c2 83       	std	Z+2, r28	; 0x02
    1aaa:	40 81       	ld	r20, Z
    1aac:	51 81       	ldd	r21, Z+1	; 0x01
    1aae:	84 0f       	add	r24, r20
    1ab0:	95 1f       	adc	r25, r21
    1ab2:	c8 17       	cp	r28, r24
    1ab4:	d9 07       	cpc	r29, r25
    1ab6:	59 f4       	brne	.+22     	; 0x1ace <free+0x82>
    1ab8:	88 81       	ld	r24, Y
    1aba:	99 81       	ldd	r25, Y+1	; 0x01
    1abc:	84 0f       	add	r24, r20
    1abe:	95 1f       	adc	r25, r21
    1ac0:	02 96       	adiw	r24, 0x02	; 2
    1ac2:	91 83       	std	Z+1, r25	; 0x01
    1ac4:	80 83       	st	Z, r24
    1ac6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ac8:	9b 81       	ldd	r25, Y+3	; 0x03
    1aca:	93 83       	std	Z+3, r25	; 0x03
    1acc:	82 83       	std	Z+2, r24	; 0x02
    1ace:	21 15       	cp	r18, r1
    1ad0:	31 05       	cpc	r19, r1
    1ad2:	29 f4       	brne	.+10     	; 0x1ade <free+0x92>
    1ad4:	f0 93 b2 01 	sts	0x01B2, r31	; 0x8001b2 <__flp+0x1>
    1ad8:	e0 93 b1 01 	sts	0x01B1, r30	; 0x8001b1 <__flp>
    1adc:	3d c0       	rjmp	.+122    	; 0x1b58 <free+0x10c>
    1ade:	e9 01       	movw	r28, r18
    1ae0:	fb 83       	std	Y+3, r31	; 0x03
    1ae2:	ea 83       	std	Y+2, r30	; 0x02
    1ae4:	49 91       	ld	r20, Y+
    1ae6:	59 91       	ld	r21, Y+
    1ae8:	c4 0f       	add	r28, r20
    1aea:	d5 1f       	adc	r29, r21
    1aec:	ec 17       	cp	r30, r28
    1aee:	fd 07       	cpc	r31, r29
    1af0:	61 f4       	brne	.+24     	; 0x1b0a <free+0xbe>
    1af2:	80 81       	ld	r24, Z
    1af4:	91 81       	ldd	r25, Z+1	; 0x01
    1af6:	84 0f       	add	r24, r20
    1af8:	95 1f       	adc	r25, r21
    1afa:	02 96       	adiw	r24, 0x02	; 2
    1afc:	e9 01       	movw	r28, r18
    1afe:	99 83       	std	Y+1, r25	; 0x01
    1b00:	88 83       	st	Y, r24
    1b02:	82 81       	ldd	r24, Z+2	; 0x02
    1b04:	93 81       	ldd	r25, Z+3	; 0x03
    1b06:	9b 83       	std	Y+3, r25	; 0x03
    1b08:	8a 83       	std	Y+2, r24	; 0x02
    1b0a:	e0 e0       	ldi	r30, 0x00	; 0
    1b0c:	f0 e0       	ldi	r31, 0x00	; 0
    1b0e:	12 96       	adiw	r26, 0x02	; 2
    1b10:	8d 91       	ld	r24, X+
    1b12:	9c 91       	ld	r25, X
    1b14:	13 97       	sbiw	r26, 0x03	; 3
    1b16:	00 97       	sbiw	r24, 0x00	; 0
    1b18:	19 f0       	breq	.+6      	; 0x1b20 <free+0xd4>
    1b1a:	fd 01       	movw	r30, r26
    1b1c:	dc 01       	movw	r26, r24
    1b1e:	f7 cf       	rjmp	.-18     	; 0x1b0e <free+0xc2>
    1b20:	8d 91       	ld	r24, X+
    1b22:	9c 91       	ld	r25, X
    1b24:	11 97       	sbiw	r26, 0x01	; 1
    1b26:	9d 01       	movw	r18, r26
    1b28:	2e 5f       	subi	r18, 0xFE	; 254
    1b2a:	3f 4f       	sbci	r19, 0xFF	; 255
    1b2c:	82 0f       	add	r24, r18
    1b2e:	93 1f       	adc	r25, r19
    1b30:	20 91 af 01 	lds	r18, 0x01AF	; 0x8001af <__brkval>
    1b34:	30 91 b0 01 	lds	r19, 0x01B0	; 0x8001b0 <__brkval+0x1>
    1b38:	28 17       	cp	r18, r24
    1b3a:	39 07       	cpc	r19, r25
    1b3c:	69 f4       	brne	.+26     	; 0x1b58 <free+0x10c>
    1b3e:	30 97       	sbiw	r30, 0x00	; 0
    1b40:	29 f4       	brne	.+10     	; 0x1b4c <free+0x100>
    1b42:	10 92 b2 01 	sts	0x01B2, r1	; 0x8001b2 <__flp+0x1>
    1b46:	10 92 b1 01 	sts	0x01B1, r1	; 0x8001b1 <__flp>
    1b4a:	02 c0       	rjmp	.+4      	; 0x1b50 <free+0x104>
    1b4c:	13 82       	std	Z+3, r1	; 0x03
    1b4e:	12 82       	std	Z+2, r1	; 0x02
    1b50:	b0 93 b0 01 	sts	0x01B0, r27	; 0x8001b0 <__brkval+0x1>
    1b54:	a0 93 af 01 	sts	0x01AF, r26	; 0x8001af <__brkval>
    1b58:	df 91       	pop	r29
    1b5a:	cf 91       	pop	r28
    1b5c:	08 95       	ret

00001b5e <memcpy>:
    1b5e:	fb 01       	movw	r30, r22
    1b60:	dc 01       	movw	r26, r24
    1b62:	02 c0       	rjmp	.+4      	; 0x1b68 <memcpy+0xa>
    1b64:	01 90       	ld	r0, Z+
    1b66:	0d 92       	st	X+, r0
    1b68:	41 50       	subi	r20, 0x01	; 1
    1b6a:	50 40       	sbci	r21, 0x00	; 0
    1b6c:	d8 f7       	brcc	.-10     	; 0x1b64 <memcpy+0x6>
    1b6e:	08 95       	ret

00001b70 <memset>:
    1b70:	dc 01       	movw	r26, r24
    1b72:	01 c0       	rjmp	.+2      	; 0x1b76 <memset+0x6>
    1b74:	6d 93       	st	X+, r22
    1b76:	41 50       	subi	r20, 0x01	; 1
    1b78:	50 40       	sbci	r21, 0x00	; 0
    1b7a:	e0 f7       	brcc	.-8      	; 0x1b74 <memset+0x4>
    1b7c:	08 95       	ret

00001b7e <_exit>:
    1b7e:	f8 94       	cli

00001b80 <__stop_program>:
    1b80:	ff cf       	rjmp	.-2      	; 0x1b80 <__stop_program>
