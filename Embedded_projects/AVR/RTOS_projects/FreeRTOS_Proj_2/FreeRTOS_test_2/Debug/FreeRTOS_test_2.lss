
FreeRTOS_test_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00001d3e  00001dd2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d3e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000008e  00800124  00800124  00001df6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001df6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001e28  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000428  00000000  00000000  00001e68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000060fa  00000000  00000000  00002290  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017fc  00000000  00000000  0000838a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e9a  00000000  00000000  00009b86  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d20  00000000  00000000  0000ca20  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001cd2  00000000  00000000  0000d740  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005335  00000000  00000000  0000f412  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000510  00000000  00000000  00014747  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__ctors_end>
       4:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       8:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      10:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      14:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      18:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      1c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      20:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      24:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      28:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      2c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      30:	0c 94 f7 02 	jmp	0x5ee	; 0x5ee <__vector_12>
      34:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      38:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      3c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      40:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      44:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      48:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      4c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      50:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      54:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      58:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      5c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      60:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      64:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      68:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      6c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      70:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      74:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      78:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      7c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      80:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      84:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      88:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      8c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      90:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      94:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      98:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      9c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a0:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a4:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a8:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      ac:	f1 0c       	add	r15, r1
      ae:	f1 0c       	add	r15, r1
      b0:	f1 0c       	add	r15, r1
      b2:	21 0d       	add	r18, r1
      b4:	29 0d       	add	r18, r9
      b6:	39 0d       	add	r19, r9
      b8:	f1 0c       	add	r15, r1
      ba:	f1 0c       	add	r15, r1
      bc:	21 0d       	add	r18, r1
      be:	29 0d       	add	r18, r9

000000c0 <__ctors_end>:
      c0:	11 24       	eor	r1, r1
      c2:	1f be       	out	0x3f, r1	; 63
      c4:	cf ef       	ldi	r28, 0xFF	; 255
      c6:	da e0       	ldi	r29, 0x0A	; 10
      c8:	de bf       	out	0x3e, r29	; 62
      ca:	cd bf       	out	0x3d, r28	; 61

000000cc <__do_copy_data>:
      cc:	11 e0       	ldi	r17, 0x01	; 1
      ce:	a0 e0       	ldi	r26, 0x00	; 0
      d0:	b1 e0       	ldi	r27, 0x01	; 1
      d2:	ee e3       	ldi	r30, 0x3E	; 62
      d4:	fd e1       	ldi	r31, 0x1D	; 29
      d6:	02 c0       	rjmp	.+4      	; 0xdc <__do_copy_data+0x10>
      d8:	05 90       	lpm	r0, Z+
      da:	0d 92       	st	X+, r0
      dc:	a4 32       	cpi	r26, 0x24	; 36
      de:	b1 07       	cpc	r27, r17
      e0:	d9 f7       	brne	.-10     	; 0xd8 <__do_copy_data+0xc>

000000e2 <__do_clear_bss>:
      e2:	21 e0       	ldi	r18, 0x01	; 1
      e4:	a4 e2       	ldi	r26, 0x24	; 36
      e6:	b1 e0       	ldi	r27, 0x01	; 1
      e8:	01 c0       	rjmp	.+2      	; 0xec <.do_clear_bss_start>

000000ea <.do_clear_bss_loop>:
      ea:	1d 92       	st	X+, r1

000000ec <.do_clear_bss_start>:
      ec:	a2 3b       	cpi	r26, 0xB2	; 178
      ee:	b2 07       	cpc	r27, r18
      f0:	e1 f7       	brne	.-8      	; 0xea <.do_clear_bss_loop>
      f2:	0e 94 cb 01 	call	0x396	; 0x396 <main>
      f6:	0c 94 9d 0e 	jmp	0x1d3a	; 0x1d3a <_exit>

000000fa <__bad_interrupt>:
      fa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000fe <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      fe:	cf 93       	push	r28
     100:	df 93       	push	r29
     102:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
     104:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
     108:	ce 01       	movw	r24, r28
     10a:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <malloc>
     10e:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     110:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
     114:	20 97       	sbiw	r28, 0x00	; 0
     116:	11 f4       	brne	.+4      	; 0x11c <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
     118:	0e 94 bb 00 	call	0x176	; 0x176 <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
     11c:	ce 01       	movw	r24, r28
     11e:	df 91       	pop	r29
     120:	cf 91       	pop	r28
     122:	08 95       	ret

00000124 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     124:	cf 93       	push	r28
     126:	df 93       	push	r29
    if( pv )
     128:	00 97       	sbiw	r24, 0x00	; 0
     12a:	41 f0       	breq	.+16     	; 0x13c <vPortFree+0x18>
     12c:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
     12e:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
        {
            free( pv );
     132:	ce 01       	movw	r24, r28
     134:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
     138:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
    }
}
     13c:	df 91       	pop	r29
     13e:	cf 91       	pop	r28
     140:	08 95       	ret

00000142 <vApplicationIdleHook>:

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino with 328p
    DIDR0 = 0x3F;

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DIDR0 = 0xF3;
     142:	83 ef       	ldi	r24, 0xF3	; 243
     144:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
    DIDR2 = 0x3F;
     148:	8f e3       	ldi	r24, 0x3F	; 63
     14a:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7f807d>
    // When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
    // This bit can be set at any time to turn off the Analogue Comparator.
    // This will reduce power consumption in Active and Idle mode.
    // When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
    // Otherwise an interrupt can occur when the ACD bit is changed.
    ACSR &= ~_BV(ACIE);
     14e:	80 b7       	in	r24, 0x30	; 48
     150:	87 7f       	andi	r24, 0xF7	; 247
     152:	80 bf       	out	0x30, r24	; 48
    ACSR |=  _BV(ACD);
     154:	80 b7       	in	r24, 0x30	; 48
     156:	80 68       	ori	r24, 0x80	; 128
     158:	80 bf       	out	0x30, r24	; 48
    // SLEEP_MODE_PWR_DOWN     _BV(SM1)
    // SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
    // SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
    // SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

    set_sleep_mode( SLEEP_MODE_IDLE );
     15a:	83 b7       	in	r24, 0x33	; 51
     15c:	81 7f       	andi	r24, 0xF1	; 241
     15e:	83 bf       	out	0x33, r24	; 51

    portENTER_CRITICAL();
     160:	0f b6       	in	r0, 0x3f	; 63
     162:	f8 94       	cli
     164:	0f 92       	push	r0
    sleep_enable();
     166:	83 b7       	in	r24, 0x33	; 51
     168:	81 60       	ori	r24, 0x01	; 1
     16a:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
    sleep_bod_disable();
#endif

    portEXIT_CRITICAL();
     16c:	0f 90       	pop	r0
     16e:	0f be       	out	0x3f, r0	; 63
    sleep_cpu();            // good night.
     170:	88 95       	sleep

    sleep_reset();          // reset the sleep_mode() faster than sleep_disable();
     172:	13 be       	out	0x33, r1	; 51
     174:	08 95       	ret

00000176 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DDRC  |= _BV(DDC7);
     176:	3f 9a       	sbi	0x07, 7	; 7
    PORTC |= _BV(PORTC7);       // Main (red PC7) LED on. Main LED on.
     178:	47 9a       	sbi	0x08, 7	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     17a:	83 ed       	ldi	r24, 0xD3	; 211
     17c:	90 e3       	ldi	r25, 0x30	; 48
     17e:	01 97       	sbiw	r24, 0x01	; 1
     180:	f1 f7       	brne	.-4      	; 0x17e <vApplicationMallocFailedHook+0x8>
     182:	00 c0       	rjmp	.+0      	; 0x184 <vApplicationMallocFailedHook+0xe>
     184:	00 00       	nop

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
        PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED fast blink.
     186:	37 9a       	sbi	0x06, 7	; 6
     188:	f8 cf       	rjmp	.-16     	; 0x17a <vApplicationMallocFailedHook+0x4>

0000018a <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DDRC  |= _BV(DDC7);
     18a:	3f 9a       	sbi	0x07, 7	; 7
    PORTC |= _BV(PORTC7);       // Main (red PC7) LED on. Main LED on.
     18c:	47 9a       	sbi	0x08, 7	; 8
     18e:	2f e7       	ldi	r18, 0x7F	; 127
     190:	8a e1       	ldi	r24, 0x1A	; 26
     192:	96 e0       	ldi	r25, 0x06	; 6
     194:	21 50       	subi	r18, 0x01	; 1
     196:	80 40       	sbci	r24, 0x00	; 0
     198:	90 40       	sbci	r25, 0x00	; 0
     19a:	e1 f7       	brne	.-8      	; 0x194 <vApplicationStackOverflowHook+0xa>
     19c:	00 c0       	rjmp	.+0      	; 0x19e <vApplicationStackOverflowHook+0x14>
     19e:	00 00       	nop

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
        PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED slow blink.
     1a0:	37 9a       	sbi	0x06, 7	; 6
     1a2:	f5 cf       	rjmp	.-22     	; 0x18e <vApplicationStackOverflowHook+0x4>

000001a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     1a4:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1a6:	03 96       	adiw	r24, 0x03	; 3
     1a8:	92 83       	std	Z+2, r25	; 0x02
     1aa:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     1ac:	2f ef       	ldi	r18, 0xFF	; 255
     1ae:	3f ef       	ldi	r19, 0xFF	; 255
     1b0:	34 83       	std	Z+4, r19	; 0x04
     1b2:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1b4:	96 83       	std	Z+6, r25	; 0x06
     1b6:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1b8:	90 87       	std	Z+8, r25	; 0x08
     1ba:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1bc:	10 82       	st	Z, r1
     1be:	08 95       	ret

000001c0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     1c0:	fc 01       	movw	r30, r24
     1c2:	11 86       	std	Z+9, r1	; 0x09
     1c4:	10 86       	std	Z+8, r1	; 0x08
     1c6:	08 95       	ret

000001c8 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	9c 01       	movw	r18, r24
     1ce:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     1d0:	dc 01       	movw	r26, r24
     1d2:	11 96       	adiw	r26, 0x01	; 1
     1d4:	cd 91       	ld	r28, X+
     1d6:	dc 91       	ld	r29, X
     1d8:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     1da:	d3 83       	std	Z+3, r29	; 0x03
     1dc:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     1de:	8c 81       	ldd	r24, Y+4	; 0x04
     1e0:	9d 81       	ldd	r25, Y+5	; 0x05
     1e2:	95 83       	std	Z+5, r25	; 0x05
     1e4:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     1e6:	8c 81       	ldd	r24, Y+4	; 0x04
     1e8:	9d 81       	ldd	r25, Y+5	; 0x05
     1ea:	dc 01       	movw	r26, r24
     1ec:	13 96       	adiw	r26, 0x03	; 3
     1ee:	7c 93       	st	X, r23
     1f0:	6e 93       	st	-X, r22
     1f2:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
     1f4:	7d 83       	std	Y+5, r23	; 0x05
     1f6:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     1f8:	31 87       	std	Z+9, r19	; 0x09
     1fa:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
     1fc:	f9 01       	movw	r30, r18
     1fe:	80 81       	ld	r24, Z
     200:	8f 5f       	subi	r24, 0xFF	; 255
     202:	80 83       	st	Z, r24
}
     204:	df 91       	pop	r29
     206:	cf 91       	pop	r28
     208:	08 95       	ret

0000020a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     20a:	cf 93       	push	r28
     20c:	df 93       	push	r29
     20e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     210:	48 81       	ld	r20, Y
     212:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     214:	4f 3f       	cpi	r20, 0xFF	; 255
     216:	2f ef       	ldi	r18, 0xFF	; 255
     218:	52 07       	cpc	r21, r18
     21a:	21 f4       	brne	.+8      	; 0x224 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     21c:	fc 01       	movw	r30, r24
     21e:	a7 81       	ldd	r26, Z+7	; 0x07
     220:	b0 85       	ldd	r27, Z+8	; 0x08
     222:	0d c0       	rjmp	.+26     	; 0x23e <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     224:	dc 01       	movw	r26, r24
     226:	13 96       	adiw	r26, 0x03	; 3
     228:	01 c0       	rjmp	.+2      	; 0x22c <vListInsert+0x22>
     22a:	df 01       	movw	r26, r30
     22c:	12 96       	adiw	r26, 0x02	; 2
     22e:	ed 91       	ld	r30, X+
     230:	fc 91       	ld	r31, X
     232:	13 97       	sbiw	r26, 0x03	; 3
     234:	20 81       	ld	r18, Z
     236:	31 81       	ldd	r19, Z+1	; 0x01
     238:	42 17       	cp	r20, r18
     23a:	53 07       	cpc	r21, r19
     23c:	b0 f7       	brcc	.-20     	; 0x22a <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     23e:	12 96       	adiw	r26, 0x02	; 2
     240:	ed 91       	ld	r30, X+
     242:	fc 91       	ld	r31, X
     244:	13 97       	sbiw	r26, 0x03	; 3
     246:	fb 83       	std	Y+3, r31	; 0x03
     248:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     24a:	d5 83       	std	Z+5, r29	; 0x05
     24c:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     24e:	bd 83       	std	Y+5, r27	; 0x05
     250:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
     252:	13 96       	adiw	r26, 0x03	; 3
     254:	dc 93       	st	X, r29
     256:	ce 93       	st	-X, r28
     258:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
     25a:	99 87       	std	Y+9, r25	; 0x09
     25c:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     25e:	fc 01       	movw	r30, r24
     260:	20 81       	ld	r18, Z
     262:	2f 5f       	subi	r18, 0xFF	; 255
     264:	20 83       	st	Z, r18
}
     266:	df 91       	pop	r29
     268:	cf 91       	pop	r28
     26a:	08 95       	ret

0000026c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     272:	a0 85       	ldd	r26, Z+8	; 0x08
     274:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     276:	c2 81       	ldd	r28, Z+2	; 0x02
     278:	d3 81       	ldd	r29, Z+3	; 0x03
     27a:	84 81       	ldd	r24, Z+4	; 0x04
     27c:	95 81       	ldd	r25, Z+5	; 0x05
     27e:	9d 83       	std	Y+5, r25	; 0x05
     280:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     282:	c4 81       	ldd	r28, Z+4	; 0x04
     284:	d5 81       	ldd	r29, Z+5	; 0x05
     286:	82 81       	ldd	r24, Z+2	; 0x02
     288:	93 81       	ldd	r25, Z+3	; 0x03
     28a:	9b 83       	std	Y+3, r25	; 0x03
     28c:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     28e:	11 96       	adiw	r26, 0x01	; 1
     290:	8d 91       	ld	r24, X+
     292:	9c 91       	ld	r25, X
     294:	12 97       	sbiw	r26, 0x02	; 2
     296:	e8 17       	cp	r30, r24
     298:	f9 07       	cpc	r31, r25
     29a:	31 f4       	brne	.+12     	; 0x2a8 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     29c:	84 81       	ldd	r24, Z+4	; 0x04
     29e:	95 81       	ldd	r25, Z+5	; 0x05
     2a0:	12 96       	adiw	r26, 0x02	; 2
     2a2:	9c 93       	st	X, r25
     2a4:	8e 93       	st	-X, r24
     2a6:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     2a8:	11 86       	std	Z+9, r1	; 0x09
     2aa:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
     2ac:	8c 91       	ld	r24, X
     2ae:	81 50       	subi	r24, 0x01	; 1
     2b0:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
     2b2:	8c 91       	ld	r24, X
}
     2b4:	df 91       	pop	r29
     2b6:	cf 91       	pop	r28
     2b8:	08 95       	ret

000002ba <task1_code>:
	}
	return 0;
}
/*Task1 Code */
void task1_code(void*pvParamter)
{
     2ba:	cf 93       	push	r28
     2bc:	df 93       	push	r29
     2be:	00 d0       	rcall	.+0      	; 0x2c0 <task1_code+0x6>
     2c0:	cd b7       	in	r28, 0x3d	; 61
     2c2:	de b7       	in	r29, 0x3e	; 62
	TickType_t LastWake;
	const TickType_t freq=100;
	LastWake= xTaskGetTickCount();
     2c4:	0e 94 c8 07 	call	0xf90	; 0xf90 <xTaskGetTickCount>
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
	BaseType_t flag_Que1;
	PORTB |= (1<<0);
     2cc:	28 9a       	sbi	0x05, 0	; 5
	for (;;)
	{
		counter_Que1++;
     2ce:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <__data_end>
     2d2:	8f 5f       	subi	r24, 0xFF	; 255
     2d4:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <__data_end>
		if(counter_Que1<10)
     2d8:	8a 30       	cpi	r24, 0x0A	; 10
     2da:	94 f4       	brge	.+36     	; 0x300 <task1_code+0x46>
		{
			flag_Que1= xQueueSend(Queue_1, (void *) &counter_Que1, (TickType_t)10);
     2dc:	20 e0       	ldi	r18, 0x00	; 0
     2de:	4a e0       	ldi	r20, 0x0A	; 10
     2e0:	50 e0       	ldi	r21, 0x00	; 0
     2e2:	64 e2       	ldi	r22, 0x24	; 36
     2e4:	71 e0       	ldi	r23, 0x01	; 1
     2e6:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <Queue_1>
     2ea:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <Queue_1+0x1>
     2ee:	0e 94 34 04 	call	0x868	; 0x868 <xQueueGenericSend>
			vTaskDelayUntil(&LastWake,800);
     2f2:	60 e2       	ldi	r22, 0x20	; 32
     2f4:	73 e0       	ldi	r23, 0x03	; 3
     2f6:	ce 01       	movw	r24, r28
     2f8:	01 96       	adiw	r24, 0x01	; 1
     2fa:	0e 94 14 09 	call	0x1228	; 0x1228 <vTaskDelayUntil>
     2fe:	e7 cf       	rjmp	.-50     	; 0x2ce <task1_code+0x14>
		}
		else if(counter_Que1==10)
     300:	8a 30       	cpi	r24, 0x0A	; 10
     302:	29 f7       	brne	.-54     	; 0x2ce <task1_code+0x14>
		{
			PORTB = 0x00;
     304:	15 b8       	out	0x05, r1	; 5
			vTaskDelayUntil(&LastWake,300);
     306:	6c e2       	ldi	r22, 0x2C	; 44
     308:	71 e0       	ldi	r23, 0x01	; 1
     30a:	ce 01       	movw	r24, r28
     30c:	01 96       	adiw	r24, 0x01	; 1
     30e:	0e 94 14 09 	call	0x1228	; 0x1228 <vTaskDelayUntil>
			PORTB |= (1<<2);
     312:	2a 9a       	sbi	0x05, 2	; 5
			vTaskDelayUntil(&LastWake,100);
     314:	64 e6       	ldi	r22, 0x64	; 100
     316:	70 e0       	ldi	r23, 0x00	; 0
     318:	ce 01       	movw	r24, r28
     31a:	01 96       	adiw	r24, 0x01	; 1
     31c:	0e 94 14 09 	call	0x1228	; 0x1228 <vTaskDelayUntil>
			vTaskSuspend(task1_handle);
     320:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <task1_handle>
     324:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <task1_handle+0x1>
     328:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <vTaskSuspend>
     32c:	d0 cf       	rjmp	.-96     	; 0x2ce <task1_code+0x14>

0000032e <task2_code>:
	}
}

/*Task2 Code */
void task2_code(void*pvParamter)
{
     32e:	cf 93       	push	r28
     330:	df 93       	push	r29
     332:	00 d0       	rcall	.+0      	; 0x334 <task2_code+0x6>
     334:	cd b7       	in	r28, 0x3d	; 61
     336:	de b7       	in	r29, 0x3e	; 62
	TickType_t LastWake2;
	const TickType_t freq2=4000;
	LastWake2= xTaskGetTickCount();
     338:	0e 94 c8 07 	call	0xf90	; 0xf90 <xTaskGetTickCount>
     33c:	9a 83       	std	Y+2, r25	; 0x02
     33e:	89 83       	std	Y+1, r24	; 0x01
	BaseType_t flag_Que1;
	PORTB |= (1<<1);
     340:	29 9a       	sbi	0x05, 1	; 5
	for (;;)
	{
		if(counter_Que1==10)
		{
			for(counter_Que1=9;counter_Que1>=0;counter_Que1--)
     342:	09 e0       	ldi	r16, 0x09	; 9
			{
			TOOGLE_BIT(PORTB,PINB3);
     344:	18 e0       	ldi	r17, 0x08	; 8
	LastWake2= xTaskGetTickCount();
	BaseType_t flag_Que1;
	PORTB |= (1<<1);
	for (;;)
	{
		if(counter_Que1==10)
     346:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <__data_end>
     34a:	8a 30       	cpi	r24, 0x0A	; 10
     34c:	11 f5       	brne	.+68     	; 0x392 <task2_code+0x64>
		{
			for(counter_Que1=9;counter_Que1>=0;counter_Que1--)
     34e:	00 93 24 01 	sts	0x0124, r16	; 0x800124 <__data_end>
			{
			TOOGLE_BIT(PORTB,PINB3);
     352:	85 b1       	in	r24, 0x05	; 5
     354:	81 27       	eor	r24, r17
     356:	85 b9       	out	0x05, r24	; 5
			vTaskDelayUntil(&LastWake2,1000);
     358:	68 ee       	ldi	r22, 0xE8	; 232
     35a:	73 e0       	ldi	r23, 0x03	; 3
     35c:	ce 01       	movw	r24, r28
     35e:	01 96       	adiw	r24, 0x01	; 1
     360:	0e 94 14 09 	call	0x1228	; 0x1228 <vTaskDelayUntil>
			flag_Que1=(unsigned int) xQueueReceive(Queue_1, (void *) &counter_Que1, (TickType_t)10);
     364:	4a e0       	ldi	r20, 0x0A	; 10
     366:	50 e0       	ldi	r21, 0x00	; 0
     368:	64 e2       	ldi	r22, 0x24	; 36
     36a:	71 e0       	ldi	r23, 0x01	; 1
     36c:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <Queue_1>
     370:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <Queue_1+0x1>
     374:	0e 94 11 05 	call	0xa22	; 0xa22 <xQueueReceive>
			vTaskDelayUntil(&LastWake2,freq2);	
     378:	60 ea       	ldi	r22, 0xA0	; 160
     37a:	7f e0       	ldi	r23, 0x0F	; 15
     37c:	ce 01       	movw	r24, r28
     37e:	01 96       	adiw	r24, 0x01	; 1
     380:	0e 94 14 09 	call	0x1228	; 0x1228 <vTaskDelayUntil>
	PORTB |= (1<<1);
	for (;;)
	{
		if(counter_Que1==10)
		{
			for(counter_Que1=9;counter_Que1>=0;counter_Que1--)
     384:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <__data_end>
     388:	81 50       	subi	r24, 0x01	; 1
     38a:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <__data_end>
     38e:	88 23       	and	r24, r24
     390:	04 f7       	brge	.-64     	; 0x352 <task2_code+0x24>
			vTaskDelayUntil(&LastWake2,1000);
			flag_Que1=(unsigned int) xQueueReceive(Queue_1, (void *) &counter_Que1, (TickType_t)10);
			vTaskDelayUntil(&LastWake2,freq2);	
			}
		}
		PORTB |= (1<<3);
     392:	2b 9a       	sbi	0x05, 3	; 5
	}
     394:	d8 cf       	rjmp	.-80     	; 0x346 <task2_code+0x18>

00000396 <main>:
void task1_code(void*pvParamter);
void task2_code(void*pvParamter);
BaseType_t counter_Que1=0;
int main(void)
{
	DDRB=0XFF;
     396:	8f ef       	ldi	r24, 0xFF	; 255
     398:	84 b9       	out	0x04, r24	; 4
	PORTB=0X00;
     39a:	15 b8       	out	0x05, r1	; 5
	DDRD=0XFF;
     39c:	8a b9       	out	0x0a, r24	; 10
	PORTD=0X00;
     39e:	1b b8       	out	0x0b, r1	; 11
	xTaskCreate(task1_code,"pcTask1",85,task1_handle,TASK1_PRIORITY,NULL);
     3a0:	20 91 27 01 	lds	r18, 0x0127	; 0x800127 <task1_handle>
     3a4:	30 91 28 01 	lds	r19, 0x0128	; 0x800128 <task1_handle+0x1>
     3a8:	e1 2c       	mov	r14, r1
     3aa:	f1 2c       	mov	r15, r1
     3ac:	03 e0       	ldi	r16, 0x03	; 3
     3ae:	45 e5       	ldi	r20, 0x55	; 85
     3b0:	50 e0       	ldi	r21, 0x00	; 0
     3b2:	66 e0       	ldi	r22, 0x06	; 6
     3b4:	71 e0       	ldi	r23, 0x01	; 1
     3b6:	8d e5       	ldi	r24, 0x5D	; 93
     3b8:	91 e0       	ldi	r25, 0x01	; 1
     3ba:	0e 94 78 06 	call	0xcf0	; 0xcf0 <xTaskCreate>
	xTaskCreate(task2_code,"pcTask2",85,task2_handle,TASK2_PRIORITY,NULL);
     3be:	20 91 25 01 	lds	r18, 0x0125	; 0x800125 <task2_handle>
     3c2:	30 91 26 01 	lds	r19, 0x0126	; 0x800126 <task2_handle+0x1>
     3c6:	02 e0       	ldi	r16, 0x02	; 2
     3c8:	45 e5       	ldi	r20, 0x55	; 85
     3ca:	50 e0       	ldi	r21, 0x00	; 0
     3cc:	6e e0       	ldi	r22, 0x0E	; 14
     3ce:	71 e0       	ldi	r23, 0x01	; 1
     3d0:	87 e9       	ldi	r24, 0x97	; 151
     3d2:	91 e0       	ldi	r25, 0x01	; 1
     3d4:	0e 94 78 06 	call	0xcf0	; 0xcf0 <xTaskCreate>
	Queue_1= xQueueCreate( 10, sizeof(unsigned int ));
     3d8:	40 e0       	ldi	r20, 0x00	; 0
     3da:	62 e0       	ldi	r22, 0x02	; 2
     3dc:	8a e0       	ldi	r24, 0x0A	; 10
     3de:	0e 94 11 04 	call	0x822	; 0x822 <xQueueGenericCreate>
     3e2:	90 93 ad 01 	sts	0x01AD, r25	; 0x8001ad <Queue_1+0x1>
     3e6:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <Queue_1>
	vTaskStartScheduler();
     3ea:	0e 94 94 07 	call	0xf28	; 0xf28 <vTaskStartScheduler>
     3ee:	ff cf       	rjmp	.-2      	; 0x3ee <main+0x58>

000003f0 <pxPortInitialiseStack>:
{
    portSAVE_CONTEXT();
    vTaskSwitchContext();
    portRESTORE_CONTEXT();

    __asm__ __volatile__ ( "reti" );
     3f0:	fc 01       	movw	r30, r24
     3f2:	60 83       	st	Z, r22
     3f4:	31 97       	sbiw	r30, 0x01	; 1
     3f6:	70 83       	st	Z, r23
     3f8:	31 97       	sbiw	r30, 0x01	; 1
     3fa:	10 82       	st	Z, r1
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	20 e8       	ldi	r18, 0x80	; 128
     400:	20 83       	st	Z, r18
     402:	31 97       	sbiw	r30, 0x01	; 1
     404:	10 82       	st	Z, r1
     406:	77 97       	sbiw	r30, 0x17	; 23
     408:	40 83       	st	Z, r20
     40a:	31 97       	sbiw	r30, 0x01	; 1
     40c:	50 83       	st	Z, r21
     40e:	83 97       	sbiw	r24, 0x23	; 35
     410:	08 95       	ret

00000412 <xPortStartScheduler>:
     412:	a8 95       	wdr
     414:	90 ec       	ldi	r25, 0xC0	; 192
     416:	88 e1       	ldi	r24, 0x18	; 24
     418:	0f b6       	in	r0, 0x3f	; 63
     41a:	f8 94       	cli
     41c:	a8 95       	wdr
     41e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7f8060>
     422:	0f be       	out	0x3f, r0	; 63
     424:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7f8060>
     428:	a0 91 8e 01 	lds	r26, 0x018E	; 0x80018e <pxCurrentTCB>
     42c:	b0 91 8f 01 	lds	r27, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     430:	cd 91       	ld	r28, X+
     432:	cd bf       	out	0x3d, r28	; 61
     434:	dd 91       	ld	r29, X+
     436:	de bf       	out	0x3e, r29	; 62
     438:	ff 91       	pop	r31
     43a:	ef 91       	pop	r30
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	bf 91       	pop	r27
     442:	af 91       	pop	r26
     444:	9f 91       	pop	r25
     446:	8f 91       	pop	r24
     448:	7f 91       	pop	r23
     44a:	6f 91       	pop	r22
     44c:	5f 91       	pop	r21
     44e:	4f 91       	pop	r20
     450:	3f 91       	pop	r19
     452:	2f 91       	pop	r18
     454:	1f 91       	pop	r17
     456:	0f 91       	pop	r16
     458:	ff 90       	pop	r15
     45a:	ef 90       	pop	r14
     45c:	df 90       	pop	r13
     45e:	cf 90       	pop	r12
     460:	bf 90       	pop	r11
     462:	af 90       	pop	r10
     464:	9f 90       	pop	r9
     466:	8f 90       	pop	r8
     468:	7f 90       	pop	r7
     46a:	6f 90       	pop	r6
     46c:	5f 90       	pop	r5
     46e:	4f 90       	pop	r4
     470:	3f 90       	pop	r3
     472:	2f 90       	pop	r2
     474:	1f 90       	pop	r1
     476:	0f 90       	pop	r0
     478:	0f be       	out	0x3f, r0	; 63
     47a:	0f 90       	pop	r0
     47c:	08 95       	ret
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	08 95       	ret

00000482 <vPortYield>:
     482:	0f 92       	push	r0
     484:	0f b6       	in	r0, 0x3f	; 63
     486:	f8 94       	cli
     488:	0f 92       	push	r0
     48a:	1f 92       	push	r1
     48c:	11 24       	eor	r1, r1
     48e:	2f 92       	push	r2
     490:	3f 92       	push	r3
     492:	4f 92       	push	r4
     494:	5f 92       	push	r5
     496:	6f 92       	push	r6
     498:	7f 92       	push	r7
     49a:	8f 92       	push	r8
     49c:	9f 92       	push	r9
     49e:	af 92       	push	r10
     4a0:	bf 92       	push	r11
     4a2:	cf 92       	push	r12
     4a4:	df 92       	push	r13
     4a6:	ef 92       	push	r14
     4a8:	ff 92       	push	r15
     4aa:	0f 93       	push	r16
     4ac:	1f 93       	push	r17
     4ae:	2f 93       	push	r18
     4b0:	3f 93       	push	r19
     4b2:	4f 93       	push	r20
     4b4:	5f 93       	push	r21
     4b6:	6f 93       	push	r22
     4b8:	7f 93       	push	r23
     4ba:	8f 93       	push	r24
     4bc:	9f 93       	push	r25
     4be:	af 93       	push	r26
     4c0:	bf 93       	push	r27
     4c2:	cf 93       	push	r28
     4c4:	df 93       	push	r29
     4c6:	ef 93       	push	r30
     4c8:	ff 93       	push	r31
     4ca:	a0 91 8e 01 	lds	r26, 0x018E	; 0x80018e <pxCurrentTCB>
     4ce:	b0 91 8f 01 	lds	r27, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     4d2:	0d b6       	in	r0, 0x3d	; 61
     4d4:	0d 92       	st	X+, r0
     4d6:	0e b6       	in	r0, 0x3e	; 62
     4d8:	0d 92       	st	X+, r0
     4da:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vTaskSwitchContext>
     4de:	a0 91 8e 01 	lds	r26, 0x018E	; 0x80018e <pxCurrentTCB>
     4e2:	b0 91 8f 01 	lds	r27, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     4e6:	cd 91       	ld	r28, X+
     4e8:	cd bf       	out	0x3d, r28	; 61
     4ea:	dd 91       	ld	r29, X+
     4ec:	de bf       	out	0x3e, r29	; 62
     4ee:	ff 91       	pop	r31
     4f0:	ef 91       	pop	r30
     4f2:	df 91       	pop	r29
     4f4:	cf 91       	pop	r28
     4f6:	bf 91       	pop	r27
     4f8:	af 91       	pop	r26
     4fa:	9f 91       	pop	r25
     4fc:	8f 91       	pop	r24
     4fe:	7f 91       	pop	r23
     500:	6f 91       	pop	r22
     502:	5f 91       	pop	r21
     504:	4f 91       	pop	r20
     506:	3f 91       	pop	r19
     508:	2f 91       	pop	r18
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	ff 90       	pop	r15
     510:	ef 90       	pop	r14
     512:	df 90       	pop	r13
     514:	cf 90       	pop	r12
     516:	bf 90       	pop	r11
     518:	af 90       	pop	r10
     51a:	9f 90       	pop	r9
     51c:	8f 90       	pop	r8
     51e:	7f 90       	pop	r7
     520:	6f 90       	pop	r6
     522:	5f 90       	pop	r5
     524:	4f 90       	pop	r4
     526:	3f 90       	pop	r3
     528:	2f 90       	pop	r2
     52a:	1f 90       	pop	r1
     52c:	0f 90       	pop	r0
     52e:	0f be       	out	0x3f, r0	; 63
     530:	0f 90       	pop	r0
     532:	08 95       	ret

00000534 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
     534:	0f 92       	push	r0
     536:	0f b6       	in	r0, 0x3f	; 63
     538:	f8 94       	cli
     53a:	0f 92       	push	r0
     53c:	1f 92       	push	r1
     53e:	11 24       	eor	r1, r1
     540:	2f 92       	push	r2
     542:	3f 92       	push	r3
     544:	4f 92       	push	r4
     546:	5f 92       	push	r5
     548:	6f 92       	push	r6
     54a:	7f 92       	push	r7
     54c:	8f 92       	push	r8
     54e:	9f 92       	push	r9
     550:	af 92       	push	r10
     552:	bf 92       	push	r11
     554:	cf 92       	push	r12
     556:	df 92       	push	r13
     558:	ef 92       	push	r14
     55a:	ff 92       	push	r15
     55c:	0f 93       	push	r16
     55e:	1f 93       	push	r17
     560:	2f 93       	push	r18
     562:	3f 93       	push	r19
     564:	4f 93       	push	r20
     566:	5f 93       	push	r21
     568:	6f 93       	push	r22
     56a:	7f 93       	push	r23
     56c:	8f 93       	push	r24
     56e:	9f 93       	push	r25
     570:	af 93       	push	r26
     572:	bf 93       	push	r27
     574:	cf 93       	push	r28
     576:	df 93       	push	r29
     578:	ef 93       	push	r30
     57a:	ff 93       	push	r31
     57c:	a0 91 8e 01 	lds	r26, 0x018E	; 0x80018e <pxCurrentTCB>
     580:	b0 91 8f 01 	lds	r27, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     584:	0d b6       	in	r0, 0x3d	; 61
     586:	0d 92       	st	X+, r0
     588:	0e b6       	in	r0, 0x3e	; 62
     58a:	0d 92       	st	X+, r0
    sleep_reset();        /* reset the sleep_mode() faster than sleep_disable(); */
     58c:	13 be       	out	0x33, r1	; 51
    if( xTaskIncrementTick() != pdFALSE )
     58e:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <xTaskIncrementTick>
     592:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
     594:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vTaskSwitchContext>
    }
    portRESTORE_CONTEXT();
     598:	a0 91 8e 01 	lds	r26, 0x018E	; 0x80018e <pxCurrentTCB>
     59c:	b0 91 8f 01 	lds	r27, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     5a0:	cd 91       	ld	r28, X+
     5a2:	cd bf       	out	0x3d, r28	; 61
     5a4:	dd 91       	ld	r29, X+
     5a6:	de bf       	out	0x3e, r29	; 62
     5a8:	ff 91       	pop	r31
     5aa:	ef 91       	pop	r30
     5ac:	df 91       	pop	r29
     5ae:	cf 91       	pop	r28
     5b0:	bf 91       	pop	r27
     5b2:	af 91       	pop	r26
     5b4:	9f 91       	pop	r25
     5b6:	8f 91       	pop	r24
     5b8:	7f 91       	pop	r23
     5ba:	6f 91       	pop	r22
     5bc:	5f 91       	pop	r21
     5be:	4f 91       	pop	r20
     5c0:	3f 91       	pop	r19
     5c2:	2f 91       	pop	r18
     5c4:	1f 91       	pop	r17
     5c6:	0f 91       	pop	r16
     5c8:	ff 90       	pop	r15
     5ca:	ef 90       	pop	r14
     5cc:	df 90       	pop	r13
     5ce:	cf 90       	pop	r12
     5d0:	bf 90       	pop	r11
     5d2:	af 90       	pop	r10
     5d4:	9f 90       	pop	r9
     5d6:	8f 90       	pop	r8
     5d8:	7f 90       	pop	r7
     5da:	6f 90       	pop	r6
     5dc:	5f 90       	pop	r5
     5de:	4f 90       	pop	r4
     5e0:	3f 90       	pop	r3
     5e2:	2f 90       	pop	r2
     5e4:	1f 90       	pop	r1
     5e6:	0f 90       	pop	r0
     5e8:	0f be       	out	0x3f, r0	; 63
     5ea:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
     5ec:	08 95       	ret

000005ee <__vector_12>:
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
/*  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
 */
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
     5ee:	0e 94 9a 02 	call	0x534	; 0x534 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
     5f2:	18 95       	reti

000005f4 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	0f 92       	push	r0
     5fa:	fc 01       	movw	r30, r24
     5fc:	92 8d       	ldd	r25, Z+26	; 0x1a
     5fe:	0f 90       	pop	r0
     600:	0f be       	out	0x3f, r0	; 63
     602:	81 e0       	ldi	r24, 0x01	; 1
     604:	91 11       	cpse	r25, r1
     606:	80 e0       	ldi	r24, 0x00	; 0
     608:	08 95       	ret

0000060a <prvCopyDataToQueue>:
     60a:	0f 93       	push	r16
     60c:	1f 93       	push	r17
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	ec 01       	movw	r28, r24
     614:	04 2f       	mov	r16, r20
     616:	1a 8d       	ldd	r17, Y+26	; 0x1a
     618:	4c 8d       	ldd	r20, Y+28	; 0x1c
     61a:	41 11       	cpse	r20, r1
     61c:	0c c0       	rjmp	.+24     	; 0x636 <prvCopyDataToQueue+0x2c>
     61e:	88 81       	ld	r24, Y
     620:	99 81       	ldd	r25, Y+1	; 0x01
     622:	89 2b       	or	r24, r25
     624:	09 f0       	breq	.+2      	; 0x628 <prvCopyDataToQueue+0x1e>
     626:	42 c0       	rjmp	.+132    	; 0x6ac <prvCopyDataToQueue+0xa2>
     628:	8c 81       	ldd	r24, Y+4	; 0x04
     62a:	9d 81       	ldd	r25, Y+5	; 0x05
     62c:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <xTaskPriorityDisinherit>
     630:	1d 82       	std	Y+5, r1	; 0x05
     632:	1c 82       	std	Y+4, r1	; 0x04
     634:	42 c0       	rjmp	.+132    	; 0x6ba <prvCopyDataToQueue+0xb0>
     636:	01 11       	cpse	r16, r1
     638:	17 c0       	rjmp	.+46     	; 0x668 <prvCopyDataToQueue+0x5e>
     63a:	50 e0       	ldi	r21, 0x00	; 0
     63c:	8a 81       	ldd	r24, Y+2	; 0x02
     63e:	9b 81       	ldd	r25, Y+3	; 0x03
     640:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <memcpy>
     644:	2c 8d       	ldd	r18, Y+28	; 0x1c
     646:	8a 81       	ldd	r24, Y+2	; 0x02
     648:	9b 81       	ldd	r25, Y+3	; 0x03
     64a:	82 0f       	add	r24, r18
     64c:	91 1d       	adc	r25, r1
     64e:	9b 83       	std	Y+3, r25	; 0x03
     650:	8a 83       	std	Y+2, r24	; 0x02
     652:	2c 81       	ldd	r18, Y+4	; 0x04
     654:	3d 81       	ldd	r19, Y+5	; 0x05
     656:	82 17       	cp	r24, r18
     658:	93 07       	cpc	r25, r19
     65a:	50 f1       	brcs	.+84     	; 0x6b0 <prvCopyDataToQueue+0xa6>
     65c:	88 81       	ld	r24, Y
     65e:	99 81       	ldd	r25, Y+1	; 0x01
     660:	9b 83       	std	Y+3, r25	; 0x03
     662:	8a 83       	std	Y+2, r24	; 0x02
     664:	80 e0       	ldi	r24, 0x00	; 0
     666:	29 c0       	rjmp	.+82     	; 0x6ba <prvCopyDataToQueue+0xb0>
     668:	50 e0       	ldi	r21, 0x00	; 0
     66a:	8e 81       	ldd	r24, Y+6	; 0x06
     66c:	9f 81       	ldd	r25, Y+7	; 0x07
     66e:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <memcpy>
     672:	8c 8d       	ldd	r24, Y+28	; 0x1c
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	91 95       	neg	r25
     678:	81 95       	neg	r24
     67a:	91 09       	sbc	r25, r1
     67c:	2e 81       	ldd	r18, Y+6	; 0x06
     67e:	3f 81       	ldd	r19, Y+7	; 0x07
     680:	28 0f       	add	r18, r24
     682:	39 1f       	adc	r19, r25
     684:	3f 83       	std	Y+7, r19	; 0x07
     686:	2e 83       	std	Y+6, r18	; 0x06
     688:	48 81       	ld	r20, Y
     68a:	59 81       	ldd	r21, Y+1	; 0x01
     68c:	24 17       	cp	r18, r20
     68e:	35 07       	cpc	r19, r21
     690:	30 f4       	brcc	.+12     	; 0x69e <prvCopyDataToQueue+0x94>
     692:	2c 81       	ldd	r18, Y+4	; 0x04
     694:	3d 81       	ldd	r19, Y+5	; 0x05
     696:	82 0f       	add	r24, r18
     698:	93 1f       	adc	r25, r19
     69a:	9f 83       	std	Y+7, r25	; 0x07
     69c:	8e 83       	std	Y+6, r24	; 0x06
     69e:	02 30       	cpi	r16, 0x02	; 2
     6a0:	49 f4       	brne	.+18     	; 0x6b4 <prvCopyDataToQueue+0xaa>
     6a2:	11 23       	and	r17, r17
     6a4:	49 f0       	breq	.+18     	; 0x6b8 <prvCopyDataToQueue+0xae>
     6a6:	11 50       	subi	r17, 0x01	; 1
     6a8:	80 e0       	ldi	r24, 0x00	; 0
     6aa:	07 c0       	rjmp	.+14     	; 0x6ba <prvCopyDataToQueue+0xb0>
     6ac:	80 e0       	ldi	r24, 0x00	; 0
     6ae:	05 c0       	rjmp	.+10     	; 0x6ba <prvCopyDataToQueue+0xb0>
     6b0:	80 e0       	ldi	r24, 0x00	; 0
     6b2:	03 c0       	rjmp	.+6      	; 0x6ba <prvCopyDataToQueue+0xb0>
     6b4:	80 e0       	ldi	r24, 0x00	; 0
     6b6:	01 c0       	rjmp	.+2      	; 0x6ba <prvCopyDataToQueue+0xb0>
     6b8:	80 e0       	ldi	r24, 0x00	; 0
     6ba:	1f 5f       	subi	r17, 0xFF	; 255
     6bc:	1a 8f       	std	Y+26, r17	; 0x1a
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	1f 91       	pop	r17
     6c4:	0f 91       	pop	r16
     6c6:	08 95       	ret

000006c8 <prvCopyDataFromQueue>:
     6c8:	fc 01       	movw	r30, r24
     6ca:	44 8d       	ldd	r20, Z+28	; 0x1c
     6cc:	44 23       	and	r20, r20
     6ce:	a9 f0       	breq	.+42     	; 0x6fa <prvCopyDataFromQueue+0x32>
     6d0:	50 e0       	ldi	r21, 0x00	; 0
     6d2:	26 81       	ldd	r18, Z+6	; 0x06
     6d4:	37 81       	ldd	r19, Z+7	; 0x07
     6d6:	24 0f       	add	r18, r20
     6d8:	35 1f       	adc	r19, r21
     6da:	37 83       	std	Z+7, r19	; 0x07
     6dc:	26 83       	std	Z+6, r18	; 0x06
     6de:	84 81       	ldd	r24, Z+4	; 0x04
     6e0:	95 81       	ldd	r25, Z+5	; 0x05
     6e2:	28 17       	cp	r18, r24
     6e4:	39 07       	cpc	r19, r25
     6e6:	20 f0       	brcs	.+8      	; 0x6f0 <prvCopyDataFromQueue+0x28>
     6e8:	80 81       	ld	r24, Z
     6ea:	91 81       	ldd	r25, Z+1	; 0x01
     6ec:	97 83       	std	Z+7, r25	; 0x07
     6ee:	86 83       	std	Z+6, r24	; 0x06
     6f0:	cb 01       	movw	r24, r22
     6f2:	66 81       	ldd	r22, Z+6	; 0x06
     6f4:	77 81       	ldd	r23, Z+7	; 0x07
     6f6:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <memcpy>
     6fa:	08 95       	ret

000006fc <prvUnlockQueue>:
     6fc:	ef 92       	push	r14
     6fe:	ff 92       	push	r15
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	8c 01       	movw	r16, r24
     708:	0f b6       	in	r0, 0x3f	; 63
     70a:	f8 94       	cli
     70c:	0f 92       	push	r0
     70e:	fc 01       	movw	r30, r24
     710:	c6 8d       	ldd	r28, Z+30	; 0x1e
     712:	1c 16       	cp	r1, r28
     714:	ac f4       	brge	.+42     	; 0x740 <prvUnlockQueue+0x44>
     716:	81 89       	ldd	r24, Z+17	; 0x11
     718:	81 11       	cpse	r24, r1
     71a:	06 c0       	rjmp	.+12     	; 0x728 <prvUnlockQueue+0x2c>
     71c:	11 c0       	rjmp	.+34     	; 0x740 <prvUnlockQueue+0x44>
     71e:	f8 01       	movw	r30, r16
     720:	81 89       	ldd	r24, Z+17	; 0x11
     722:	81 11       	cpse	r24, r1
     724:	05 c0       	rjmp	.+10     	; 0x730 <prvUnlockQueue+0x34>
     726:	0c c0       	rjmp	.+24     	; 0x740 <prvUnlockQueue+0x44>
     728:	78 01       	movw	r14, r16
     72a:	f1 e1       	ldi	r31, 0x11	; 17
     72c:	ef 0e       	add	r14, r31
     72e:	f1 1c       	adc	r15, r1
     730:	c7 01       	movw	r24, r14
     732:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <xTaskRemoveFromEventList>
     736:	81 11       	cpse	r24, r1
     738:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <vTaskMissedYield>
     73c:	c1 50       	subi	r28, 0x01	; 1
     73e:	79 f7       	brne	.-34     	; 0x71e <prvUnlockQueue+0x22>
     740:	8f ef       	ldi	r24, 0xFF	; 255
     742:	f8 01       	movw	r30, r16
     744:	86 8f       	std	Z+30, r24	; 0x1e
     746:	0f 90       	pop	r0
     748:	0f be       	out	0x3f, r0	; 63
     74a:	0f b6       	in	r0, 0x3f	; 63
     74c:	f8 94       	cli
     74e:	0f 92       	push	r0
     750:	c5 8d       	ldd	r28, Z+29	; 0x1d
     752:	1c 16       	cp	r1, r28
     754:	ac f4       	brge	.+42     	; 0x780 <prvUnlockQueue+0x84>
     756:	80 85       	ldd	r24, Z+8	; 0x08
     758:	81 11       	cpse	r24, r1
     75a:	06 c0       	rjmp	.+12     	; 0x768 <prvUnlockQueue+0x6c>
     75c:	11 c0       	rjmp	.+34     	; 0x780 <prvUnlockQueue+0x84>
     75e:	f8 01       	movw	r30, r16
     760:	80 85       	ldd	r24, Z+8	; 0x08
     762:	81 11       	cpse	r24, r1
     764:	05 c0       	rjmp	.+10     	; 0x770 <prvUnlockQueue+0x74>
     766:	0c c0       	rjmp	.+24     	; 0x780 <prvUnlockQueue+0x84>
     768:	78 01       	movw	r14, r16
     76a:	f8 e0       	ldi	r31, 0x08	; 8
     76c:	ef 0e       	add	r14, r31
     76e:	f1 1c       	adc	r15, r1
     770:	c7 01       	movw	r24, r14
     772:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <xTaskRemoveFromEventList>
     776:	81 11       	cpse	r24, r1
     778:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <vTaskMissedYield>
     77c:	c1 50       	subi	r28, 0x01	; 1
     77e:	79 f7       	brne	.-34     	; 0x75e <prvUnlockQueue+0x62>
     780:	8f ef       	ldi	r24, 0xFF	; 255
     782:	f8 01       	movw	r30, r16
     784:	85 8f       	std	Z+29, r24	; 0x1d
     786:	0f 90       	pop	r0
     788:	0f be       	out	0x3f, r0	; 63
     78a:	cf 91       	pop	r28
     78c:	1f 91       	pop	r17
     78e:	0f 91       	pop	r16
     790:	ff 90       	pop	r15
     792:	ef 90       	pop	r14
     794:	08 95       	ret

00000796 <xQueueGenericReset>:
     796:	cf 93       	push	r28
     798:	df 93       	push	r29
     79a:	ec 01       	movw	r28, r24
     79c:	0f b6       	in	r0, 0x3f	; 63
     79e:	f8 94       	cli
     7a0:	0f 92       	push	r0
     7a2:	e8 81       	ld	r30, Y
     7a4:	f9 81       	ldd	r31, Y+1	; 0x01
     7a6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     7a8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	30 e0       	ldi	r19, 0x00	; 0
     7ae:	82 9f       	mul	r24, r18
     7b0:	a0 01       	movw	r20, r0
     7b2:	83 9f       	mul	r24, r19
     7b4:	50 0d       	add	r21, r0
     7b6:	92 9f       	mul	r25, r18
     7b8:	50 0d       	add	r21, r0
     7ba:	11 24       	eor	r1, r1
     7bc:	4e 0f       	add	r20, r30
     7be:	5f 1f       	adc	r21, r31
     7c0:	5d 83       	std	Y+5, r21	; 0x05
     7c2:	4c 83       	std	Y+4, r20	; 0x04
     7c4:	1a 8e       	std	Y+26, r1	; 0x1a
     7c6:	fb 83       	std	Y+3, r31	; 0x03
     7c8:	ea 83       	std	Y+2, r30	; 0x02
     7ca:	01 97       	sbiw	r24, 0x01	; 1
     7cc:	82 9f       	mul	r24, r18
     7ce:	a0 01       	movw	r20, r0
     7d0:	83 9f       	mul	r24, r19
     7d2:	50 0d       	add	r21, r0
     7d4:	92 9f       	mul	r25, r18
     7d6:	50 0d       	add	r21, r0
     7d8:	11 24       	eor	r1, r1
     7da:	cf 01       	movw	r24, r30
     7dc:	84 0f       	add	r24, r20
     7de:	95 1f       	adc	r25, r21
     7e0:	9f 83       	std	Y+7, r25	; 0x07
     7e2:	8e 83       	std	Y+6, r24	; 0x06
     7e4:	8f ef       	ldi	r24, 0xFF	; 255
     7e6:	8d 8f       	std	Y+29, r24	; 0x1d
     7e8:	8e 8f       	std	Y+30, r24	; 0x1e
     7ea:	61 11       	cpse	r22, r1
     7ec:	0c c0       	rjmp	.+24     	; 0x806 <xQueueGenericReset+0x70>
     7ee:	88 85       	ldd	r24, Y+8	; 0x08
     7f0:	88 23       	and	r24, r24
     7f2:	89 f0       	breq	.+34     	; 0x816 <xQueueGenericReset+0x80>
     7f4:	ce 01       	movw	r24, r28
     7f6:	08 96       	adiw	r24, 0x08	; 8
     7f8:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <xTaskRemoveFromEventList>
     7fc:	88 23       	and	r24, r24
     7fe:	59 f0       	breq	.+22     	; 0x816 <xQueueGenericReset+0x80>
     800:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     804:	08 c0       	rjmp	.+16     	; 0x816 <xQueueGenericReset+0x80>
     806:	ce 01       	movw	r24, r28
     808:	08 96       	adiw	r24, 0x08	; 8
     80a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     80e:	ce 01       	movw	r24, r28
     810:	41 96       	adiw	r24, 0x11	; 17
     812:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     816:	0f 90       	pop	r0
     818:	0f be       	out	0x3f, r0	; 63
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	df 91       	pop	r29
     81e:	cf 91       	pop	r28
     820:	08 95       	ret

00000822 <xQueueGenericCreate>:
     822:	0f 93       	push	r16
     824:	1f 93       	push	r17
     826:	cf 93       	push	r28
     828:	df 93       	push	r29
     82a:	08 2f       	mov	r16, r24
     82c:	16 2f       	mov	r17, r22
     82e:	86 9f       	mul	r24, r22
     830:	c0 01       	movw	r24, r0
     832:	11 24       	eor	r1, r1
     834:	4f 96       	adiw	r24, 0x1f	; 31
     836:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     83a:	ec 01       	movw	r28, r24
     83c:	00 97       	sbiw	r24, 0x00	; 0
     83e:	71 f0       	breq	.+28     	; 0x85c <xQueueGenericCreate+0x3a>
     840:	11 11       	cpse	r17, r1
     842:	03 c0       	rjmp	.+6      	; 0x84a <xQueueGenericCreate+0x28>
     844:	99 83       	std	Y+1, r25	; 0x01
     846:	88 83       	st	Y, r24
     848:	03 c0       	rjmp	.+6      	; 0x850 <xQueueGenericCreate+0x2e>
     84a:	4f 96       	adiw	r24, 0x1f	; 31
     84c:	99 83       	std	Y+1, r25	; 0x01
     84e:	88 83       	st	Y, r24
     850:	0b 8f       	std	Y+27, r16	; 0x1b
     852:	1c 8f       	std	Y+28, r17	; 0x1c
     854:	61 e0       	ldi	r22, 0x01	; 1
     856:	ce 01       	movw	r24, r28
     858:	0e 94 cb 03 	call	0x796	; 0x796 <xQueueGenericReset>
     85c:	ce 01       	movw	r24, r28
     85e:	df 91       	pop	r29
     860:	cf 91       	pop	r28
     862:	1f 91       	pop	r17
     864:	0f 91       	pop	r16
     866:	08 95       	ret

00000868 <xQueueGenericSend>:
     868:	9f 92       	push	r9
     86a:	af 92       	push	r10
     86c:	bf 92       	push	r11
     86e:	cf 92       	push	r12
     870:	df 92       	push	r13
     872:	ef 92       	push	r14
     874:	ff 92       	push	r15
     876:	0f 93       	push	r16
     878:	1f 93       	push	r17
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	00 d0       	rcall	.+0      	; 0x880 <xQueueGenericSend+0x18>
     880:	00 d0       	rcall	.+0      	; 0x882 <xQueueGenericSend+0x1a>
     882:	1f 92       	push	r1
     884:	cd b7       	in	r28, 0x3d	; 61
     886:	de b7       	in	r29, 0x3e	; 62
     888:	8c 01       	movw	r16, r24
     88a:	6b 01       	movw	r12, r22
     88c:	5d 83       	std	Y+5, r21	; 0x05
     88e:	4c 83       	std	Y+4, r20	; 0x04
     890:	a2 2e       	mov	r10, r18
     892:	b1 2c       	mov	r11, r1
     894:	99 24       	eor	r9, r9
     896:	93 94       	inc	r9
     898:	7c 01       	movw	r14, r24
     89a:	88 e0       	ldi	r24, 0x08	; 8
     89c:	e8 0e       	add	r14, r24
     89e:	f1 1c       	adc	r15, r1
     8a0:	0f b6       	in	r0, 0x3f	; 63
     8a2:	f8 94       	cli
     8a4:	0f 92       	push	r0
     8a6:	f8 01       	movw	r30, r16
     8a8:	92 8d       	ldd	r25, Z+26	; 0x1a
     8aa:	83 8d       	ldd	r24, Z+27	; 0x1b
     8ac:	98 17       	cp	r25, r24
     8ae:	18 f0       	brcs	.+6      	; 0x8b6 <xQueueGenericSend+0x4e>
     8b0:	f2 e0       	ldi	r31, 0x02	; 2
     8b2:	af 12       	cpse	r10, r31
     8b4:	19 c0       	rjmp	.+50     	; 0x8e8 <xQueueGenericSend+0x80>
     8b6:	4a 2d       	mov	r20, r10
     8b8:	b6 01       	movw	r22, r12
     8ba:	c8 01       	movw	r24, r16
     8bc:	0e 94 05 03 	call	0x60a	; 0x60a <prvCopyDataToQueue>
     8c0:	f8 01       	movw	r30, r16
     8c2:	91 89       	ldd	r25, Z+17	; 0x11
     8c4:	99 23       	and	r25, r25
     8c6:	49 f0       	breq	.+18     	; 0x8da <xQueueGenericSend+0x72>
     8c8:	c8 01       	movw	r24, r16
     8ca:	41 96       	adiw	r24, 0x11	; 17
     8cc:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <xTaskRemoveFromEventList>
     8d0:	88 23       	and	r24, r24
     8d2:	31 f0       	breq	.+12     	; 0x8e0 <xQueueGenericSend+0x78>
     8d4:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     8d8:	03 c0       	rjmp	.+6      	; 0x8e0 <xQueueGenericSend+0x78>
     8da:	81 11       	cpse	r24, r1
     8dc:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     8e0:	0f 90       	pop	r0
     8e2:	0f be       	out	0x3f, r0	; 63
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	50 c0       	rjmp	.+160    	; 0x988 <xQueueGenericSend+0x120>
     8e8:	8c 81       	ldd	r24, Y+4	; 0x04
     8ea:	9d 81       	ldd	r25, Y+5	; 0x05
     8ec:	89 2b       	or	r24, r25
     8ee:	21 f4       	brne	.+8      	; 0x8f8 <xQueueGenericSend+0x90>
     8f0:	0f 90       	pop	r0
     8f2:	0f be       	out	0x3f, r0	; 63
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	48 c0       	rjmp	.+144    	; 0x988 <xQueueGenericSend+0x120>
     8f8:	b1 10       	cpse	r11, r1
     8fa:	05 c0       	rjmp	.+10     	; 0x906 <xQueueGenericSend+0x9e>
     8fc:	ce 01       	movw	r24, r28
     8fe:	01 96       	adiw	r24, 0x01	; 1
     900:	0e 94 98 0a 	call	0x1530	; 0x1530 <vTaskInternalSetTimeOutState>
     904:	b9 2c       	mov	r11, r9
     906:	0f 90       	pop	r0
     908:	0f be       	out	0x3f, r0	; 63
     90a:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
     90e:	0f b6       	in	r0, 0x3f	; 63
     910:	f8 94       	cli
     912:	0f 92       	push	r0
     914:	f8 01       	movw	r30, r16
     916:	85 8d       	ldd	r24, Z+29	; 0x1d
     918:	8f 3f       	cpi	r24, 0xFF	; 255
     91a:	09 f4       	brne	.+2      	; 0x91e <xQueueGenericSend+0xb6>
     91c:	15 8e       	std	Z+29, r1	; 0x1d
     91e:	f8 01       	movw	r30, r16
     920:	86 8d       	ldd	r24, Z+30	; 0x1e
     922:	8f 3f       	cpi	r24, 0xFF	; 255
     924:	09 f4       	brne	.+2      	; 0x928 <xQueueGenericSend+0xc0>
     926:	16 8e       	std	Z+30, r1	; 0x1e
     928:	0f 90       	pop	r0
     92a:	0f be       	out	0x3f, r0	; 63
     92c:	be 01       	movw	r22, r28
     92e:	6c 5f       	subi	r22, 0xFC	; 252
     930:	7f 4f       	sbci	r23, 0xFF	; 255
     932:	ce 01       	movw	r24, r28
     934:	01 96       	adiw	r24, 0x01	; 1
     936:	0e 94 a3 0a 	call	0x1546	; 0x1546 <xTaskCheckForTimeOut>
     93a:	81 11       	cpse	r24, r1
     93c:	1f c0       	rjmp	.+62     	; 0x97c <xQueueGenericSend+0x114>
     93e:	0f b6       	in	r0, 0x3f	; 63
     940:	f8 94       	cli
     942:	0f 92       	push	r0
     944:	f8 01       	movw	r30, r16
     946:	92 8d       	ldd	r25, Z+26	; 0x1a
     948:	83 8d       	ldd	r24, Z+27	; 0x1b
     94a:	0f 90       	pop	r0
     94c:	0f be       	out	0x3f, r0	; 63
     94e:	98 13       	cpse	r25, r24
     950:	0f c0       	rjmp	.+30     	; 0x970 <xQueueGenericSend+0x108>
     952:	6c 81       	ldd	r22, Y+4	; 0x04
     954:	7d 81       	ldd	r23, Y+5	; 0x05
     956:	c7 01       	movw	r24, r14
     958:	0e 94 25 0a 	call	0x144a	; 0x144a <vTaskPlaceOnEventList>
     95c:	c8 01       	movw	r24, r16
     95e:	0e 94 7e 03 	call	0x6fc	; 0x6fc <prvUnlockQueue>
     962:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
     966:	81 11       	cpse	r24, r1
     968:	9b cf       	rjmp	.-202    	; 0x8a0 <xQueueGenericSend+0x38>
     96a:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     96e:	98 cf       	rjmp	.-208    	; 0x8a0 <xQueueGenericSend+0x38>
     970:	c8 01       	movw	r24, r16
     972:	0e 94 7e 03 	call	0x6fc	; 0x6fc <prvUnlockQueue>
     976:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
     97a:	92 cf       	rjmp	.-220    	; 0x8a0 <xQueueGenericSend+0x38>
     97c:	c8 01       	movw	r24, r16
     97e:	0e 94 7e 03 	call	0x6fc	; 0x6fc <prvUnlockQueue>
     982:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
     986:	80 e0       	ldi	r24, 0x00	; 0
     988:	0f 90       	pop	r0
     98a:	0f 90       	pop	r0
     98c:	0f 90       	pop	r0
     98e:	0f 90       	pop	r0
     990:	0f 90       	pop	r0
     992:	df 91       	pop	r29
     994:	cf 91       	pop	r28
     996:	1f 91       	pop	r17
     998:	0f 91       	pop	r16
     99a:	ff 90       	pop	r15
     99c:	ef 90       	pop	r14
     99e:	df 90       	pop	r13
     9a0:	cf 90       	pop	r12
     9a2:	bf 90       	pop	r11
     9a4:	af 90       	pop	r10
     9a6:	9f 90       	pop	r9
     9a8:	08 95       	ret

000009aa <xQueueGenericSendFromISR>:
     9aa:	ef 92       	push	r14
     9ac:	ff 92       	push	r15
     9ae:	0f 93       	push	r16
     9b0:	1f 93       	push	r17
     9b2:	cf 93       	push	r28
     9b4:	df 93       	push	r29
     9b6:	8a 01       	movw	r16, r20
     9b8:	fc 01       	movw	r30, r24
     9ba:	52 8d       	ldd	r21, Z+26	; 0x1a
     9bc:	33 8d       	ldd	r19, Z+27	; 0x1b
     9be:	53 17       	cp	r21, r19
     9c0:	10 f0       	brcs	.+4      	; 0x9c6 <xQueueGenericSendFromISR+0x1c>
     9c2:	22 30       	cpi	r18, 0x02	; 2
     9c4:	01 f5       	brne	.+64     	; 0xa06 <__DATA_REGION_LENGTH__+0x6>
     9c6:	42 2f       	mov	r20, r18
     9c8:	78 01       	movw	r14, r16
     9ca:	ec 01       	movw	r28, r24
     9cc:	1e 8d       	ldd	r17, Y+30	; 0x1e
     9ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
     9d0:	ce 01       	movw	r24, r28
     9d2:	0e 94 05 03 	call	0x60a	; 0x60a <prvCopyDataToQueue>
     9d6:	1f 3f       	cpi	r17, 0xFF	; 255
     9d8:	81 f4       	brne	.+32     	; 0x9fa <xQueueGenericSendFromISR+0x50>
     9da:	89 89       	ldd	r24, Y+17	; 0x11
     9dc:	88 23       	and	r24, r24
     9de:	a9 f0       	breq	.+42     	; 0xa0a <__DATA_REGION_LENGTH__+0xa>
     9e0:	ce 01       	movw	r24, r28
     9e2:	41 96       	adiw	r24, 0x11	; 17
     9e4:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <xTaskRemoveFromEventList>
     9e8:	88 23       	and	r24, r24
     9ea:	89 f0       	breq	.+34     	; 0xa0e <__DATA_REGION_LENGTH__+0xe>
     9ec:	e1 14       	cp	r14, r1
     9ee:	f1 04       	cpc	r15, r1
     9f0:	81 f0       	breq	.+32     	; 0xa12 <__DATA_REGION_LENGTH__+0x12>
     9f2:	81 e0       	ldi	r24, 0x01	; 1
     9f4:	f7 01       	movw	r30, r14
     9f6:	80 83       	st	Z, r24
     9f8:	0d c0       	rjmp	.+26     	; 0xa14 <__DATA_REGION_LENGTH__+0x14>
     9fa:	ff 24       	eor	r15, r15
     9fc:	f3 94       	inc	r15
     9fe:	f1 0e       	add	r15, r17
     a00:	fe 8e       	std	Y+30, r15	; 0x1e
     a02:	81 e0       	ldi	r24, 0x01	; 1
     a04:	07 c0       	rjmp	.+14     	; 0xa14 <__DATA_REGION_LENGTH__+0x14>
     a06:	80 e0       	ldi	r24, 0x00	; 0
     a08:	05 c0       	rjmp	.+10     	; 0xa14 <__DATA_REGION_LENGTH__+0x14>
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	03 c0       	rjmp	.+6      	; 0xa14 <__DATA_REGION_LENGTH__+0x14>
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	01 c0       	rjmp	.+2      	; 0xa14 <__DATA_REGION_LENGTH__+0x14>
     a12:	81 e0       	ldi	r24, 0x01	; 1
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	1f 91       	pop	r17
     a1a:	0f 91       	pop	r16
     a1c:	ff 90       	pop	r15
     a1e:	ef 90       	pop	r14
     a20:	08 95       	ret

00000a22 <xQueueReceive>:
     a22:	9f 92       	push	r9
     a24:	af 92       	push	r10
     a26:	bf 92       	push	r11
     a28:	cf 92       	push	r12
     a2a:	df 92       	push	r13
     a2c:	ef 92       	push	r14
     a2e:	ff 92       	push	r15
     a30:	0f 93       	push	r16
     a32:	1f 93       	push	r17
     a34:	cf 93       	push	r28
     a36:	df 93       	push	r29
     a38:	00 d0       	rcall	.+0      	; 0xa3a <xQueueReceive+0x18>
     a3a:	00 d0       	rcall	.+0      	; 0xa3c <xQueueReceive+0x1a>
     a3c:	1f 92       	push	r1
     a3e:	cd b7       	in	r28, 0x3d	; 61
     a40:	de b7       	in	r29, 0x3e	; 62
     a42:	8c 01       	movw	r16, r24
     a44:	5b 01       	movw	r10, r22
     a46:	5d 83       	std	Y+5, r21	; 0x05
     a48:	4c 83       	std	Y+4, r20	; 0x04
     a4a:	e1 2c       	mov	r14, r1
     a4c:	99 24       	eor	r9, r9
     a4e:	93 94       	inc	r9
     a50:	6c 01       	movw	r12, r24
     a52:	81 e1       	ldi	r24, 0x11	; 17
     a54:	c8 0e       	add	r12, r24
     a56:	d1 1c       	adc	r13, r1
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	f8 94       	cli
     a5c:	0f 92       	push	r0
     a5e:	f8 01       	movw	r30, r16
     a60:	f2 8c       	ldd	r15, Z+26	; 0x1a
     a62:	ff 20       	and	r15, r15
     a64:	a9 f0       	breq	.+42     	; 0xa90 <xQueueReceive+0x6e>
     a66:	b5 01       	movw	r22, r10
     a68:	c8 01       	movw	r24, r16
     a6a:	0e 94 64 03 	call	0x6c8	; 0x6c8 <prvCopyDataFromQueue>
     a6e:	fa 94       	dec	r15
     a70:	f8 01       	movw	r30, r16
     a72:	f2 8e       	std	Z+26, r15	; 0x1a
     a74:	80 85       	ldd	r24, Z+8	; 0x08
     a76:	88 23       	and	r24, r24
     a78:	39 f0       	breq	.+14     	; 0xa88 <xQueueReceive+0x66>
     a7a:	c8 01       	movw	r24, r16
     a7c:	08 96       	adiw	r24, 0x08	; 8
     a7e:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <xTaskRemoveFromEventList>
     a82:	81 11       	cpse	r24, r1
     a84:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     a88:	0f 90       	pop	r0
     a8a:	0f be       	out	0x3f, r0	; 63
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	51 c0       	rjmp	.+162    	; 0xb32 <__stack+0x33>
     a90:	8c 81       	ldd	r24, Y+4	; 0x04
     a92:	9d 81       	ldd	r25, Y+5	; 0x05
     a94:	89 2b       	or	r24, r25
     a96:	21 f4       	brne	.+8      	; 0xaa0 <xQueueReceive+0x7e>
     a98:	0f 90       	pop	r0
     a9a:	0f be       	out	0x3f, r0	; 63
     a9c:	80 e0       	ldi	r24, 0x00	; 0
     a9e:	49 c0       	rjmp	.+146    	; 0xb32 <__stack+0x33>
     aa0:	e1 10       	cpse	r14, r1
     aa2:	05 c0       	rjmp	.+10     	; 0xaae <xQueueReceive+0x8c>
     aa4:	ce 01       	movw	r24, r28
     aa6:	01 96       	adiw	r24, 0x01	; 1
     aa8:	0e 94 98 0a 	call	0x1530	; 0x1530 <vTaskInternalSetTimeOutState>
     aac:	e9 2c       	mov	r14, r9
     aae:	0f 90       	pop	r0
     ab0:	0f be       	out	0x3f, r0	; 63
     ab2:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
     ab6:	0f b6       	in	r0, 0x3f	; 63
     ab8:	f8 94       	cli
     aba:	0f 92       	push	r0
     abc:	f8 01       	movw	r30, r16
     abe:	85 8d       	ldd	r24, Z+29	; 0x1d
     ac0:	8f 3f       	cpi	r24, 0xFF	; 255
     ac2:	09 f4       	brne	.+2      	; 0xac6 <xQueueReceive+0xa4>
     ac4:	15 8e       	std	Z+29, r1	; 0x1d
     ac6:	f8 01       	movw	r30, r16
     ac8:	86 8d       	ldd	r24, Z+30	; 0x1e
     aca:	8f 3f       	cpi	r24, 0xFF	; 255
     acc:	09 f4       	brne	.+2      	; 0xad0 <xQueueReceive+0xae>
     ace:	16 8e       	std	Z+30, r1	; 0x1e
     ad0:	0f 90       	pop	r0
     ad2:	0f be       	out	0x3f, r0	; 63
     ad4:	be 01       	movw	r22, r28
     ad6:	6c 5f       	subi	r22, 0xFC	; 252
     ad8:	7f 4f       	sbci	r23, 0xFF	; 255
     ada:	ce 01       	movw	r24, r28
     adc:	01 96       	adiw	r24, 0x01	; 1
     ade:	0e 94 a3 0a 	call	0x1546	; 0x1546 <xTaskCheckForTimeOut>
     ae2:	81 11       	cpse	r24, r1
     ae4:	1a c0       	rjmp	.+52     	; 0xb1a <__stack+0x1b>
     ae6:	c8 01       	movw	r24, r16
     ae8:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <prvIsQueueEmpty>
     aec:	88 23       	and	r24, r24
     aee:	79 f0       	breq	.+30     	; 0xb0e <__stack+0xf>
     af0:	6c 81       	ldd	r22, Y+4	; 0x04
     af2:	7d 81       	ldd	r23, Y+5	; 0x05
     af4:	c6 01       	movw	r24, r12
     af6:	0e 94 25 0a 	call	0x144a	; 0x144a <vTaskPlaceOnEventList>
     afa:	c8 01       	movw	r24, r16
     afc:	0e 94 7e 03 	call	0x6fc	; 0x6fc <prvUnlockQueue>
     b00:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
     b04:	81 11       	cpse	r24, r1
     b06:	a8 cf       	rjmp	.-176    	; 0xa58 <xQueueReceive+0x36>
     b08:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     b0c:	a5 cf       	rjmp	.-182    	; 0xa58 <xQueueReceive+0x36>
     b0e:	c8 01       	movw	r24, r16
     b10:	0e 94 7e 03 	call	0x6fc	; 0x6fc <prvUnlockQueue>
     b14:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
     b18:	9f cf       	rjmp	.-194    	; 0xa58 <xQueueReceive+0x36>
     b1a:	c8 01       	movw	r24, r16
     b1c:	0e 94 7e 03 	call	0x6fc	; 0x6fc <prvUnlockQueue>
     b20:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
     b24:	c8 01       	movw	r24, r16
     b26:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <prvIsQueueEmpty>
     b2a:	88 23       	and	r24, r24
     b2c:	09 f4       	brne	.+2      	; 0xb30 <__stack+0x31>
     b2e:	94 cf       	rjmp	.-216    	; 0xa58 <xQueueReceive+0x36>
     b30:	80 e0       	ldi	r24, 0x00	; 0
     b32:	0f 90       	pop	r0
     b34:	0f 90       	pop	r0
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	df 91       	pop	r29
     b3e:	cf 91       	pop	r28
     b40:	1f 91       	pop	r17
     b42:	0f 91       	pop	r16
     b44:	ff 90       	pop	r15
     b46:	ef 90       	pop	r14
     b48:	df 90       	pop	r13
     b4a:	cf 90       	pop	r12
     b4c:	bf 90       	pop	r11
     b4e:	af 90       	pop	r10
     b50:	9f 90       	pop	r9
     b52:	08 95       	ret

00000b54 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
     b54:	cf 93       	push	r28
     b56:	df 93       	push	r29
     b58:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
     b5a:	0f b6       	in	r0, 0x3f	; 63
     b5c:	f8 94       	cli
     b5e:	0f 92       	push	r0
     b60:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b62:	8f 3f       	cpi	r24, 0xFF	; 255
     b64:	09 f4       	brne	.+2      	; 0xb68 <vQueueWaitForMessageRestricted+0x14>
     b66:	1d 8e       	std	Y+29, r1	; 0x1d
     b68:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b6a:	8f 3f       	cpi	r24, 0xFF	; 255
     b6c:	09 f4       	brne	.+2      	; 0xb70 <vQueueWaitForMessageRestricted+0x1c>
     b6e:	1e 8e       	std	Y+30, r1	; 0x1e
     b70:	0f 90       	pop	r0
     b72:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     b74:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b76:	81 11       	cpse	r24, r1
     b78:	04 c0       	rjmp	.+8      	; 0xb82 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     b7a:	ce 01       	movw	r24, r28
     b7c:	41 96       	adiw	r24, 0x11	; 17
     b7e:	0e 94 37 0a 	call	0x146e	; 0x146e <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
     b82:	ce 01       	movw	r24, r28
     b84:	0e 94 7e 03 	call	0x6fc	; 0x6fc <prvUnlockQueue>
    }
     b88:	df 91       	pop	r29
     b8a:	cf 91       	pop	r28
     b8c:	08 95       	ret

00000b8e <prvResetNextTaskUnblockTime>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     b8e:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxDelayedTaskList>
     b92:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxDelayedTaskList+0x1>
     b96:	80 81       	ld	r24, Z
     b98:	81 11       	cpse	r24, r1
     b9a:	07 c0       	rjmp	.+14     	; 0xbaa <prvResetNextTaskUnblockTime+0x1c>
     b9c:	8f ef       	ldi	r24, 0xFF	; 255
     b9e:	9f ef       	ldi	r25, 0xFF	; 255
     ba0:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <xNextTaskUnblockTime+0x1>
     ba4:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <xNextTaskUnblockTime>
     ba8:	08 95       	ret
     baa:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxDelayedTaskList>
     bae:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxDelayedTaskList+0x1>
     bb2:	05 80       	ldd	r0, Z+5	; 0x05
     bb4:	f6 81       	ldd	r31, Z+6	; 0x06
     bb6:	e0 2d       	mov	r30, r0
     bb8:	06 80       	ldd	r0, Z+6	; 0x06
     bba:	f7 81       	ldd	r31, Z+7	; 0x07
     bbc:	e0 2d       	mov	r30, r0
     bbe:	82 81       	ldd	r24, Z+2	; 0x02
     bc0:	93 81       	ldd	r25, Z+3	; 0x03
     bc2:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <xNextTaskUnblockTime+0x1>
     bc6:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <xNextTaskUnblockTime>
     bca:	08 95       	ret

00000bcc <prvAddCurrentTaskToDelayedList>:
     bcc:	ff 92       	push	r15
     bce:	0f 93       	push	r16
     bd0:	1f 93       	push	r17
     bd2:	cf 93       	push	r28
     bd4:	df 93       	push	r29
     bd6:	ec 01       	movw	r28, r24
     bd8:	f6 2e       	mov	r15, r22
     bda:	00 91 35 01 	lds	r16, 0x0135	; 0x800135 <xTickCount>
     bde:	10 91 36 01 	lds	r17, 0x0136	; 0x800136 <xTickCount+0x1>
     be2:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <pxCurrentTCB>
     be6:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     bea:	02 96       	adiw	r24, 0x02	; 2
     bec:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
     bf0:	cf 3f       	cpi	r28, 0xFF	; 255
     bf2:	8f ef       	ldi	r24, 0xFF	; 255
     bf4:	d8 07       	cpc	r29, r24
     bf6:	69 f4       	brne	.+26     	; 0xc12 <prvAddCurrentTaskToDelayedList+0x46>
     bf8:	ff 20       	and	r15, r15
     bfa:	59 f0       	breq	.+22     	; 0xc12 <prvAddCurrentTaskToDelayedList+0x46>
     bfc:	60 91 8e 01 	lds	r22, 0x018E	; 0x80018e <pxCurrentTCB>
     c00:	70 91 8f 01 	lds	r23, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     c04:	6e 5f       	subi	r22, 0xFE	; 254
     c06:	7f 4f       	sbci	r23, 0xFF	; 255
     c08:	88 e3       	ldi	r24, 0x38	; 56
     c0a:	91 e0       	ldi	r25, 0x01	; 1
     c0c:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
     c10:	2f c0       	rjmp	.+94     	; 0xc70 <prvAddCurrentTaskToDelayedList+0xa4>
     c12:	c0 0f       	add	r28, r16
     c14:	d1 1f       	adc	r29, r17
     c16:	e0 91 8e 01 	lds	r30, 0x018E	; 0x80018e <pxCurrentTCB>
     c1a:	f0 91 8f 01 	lds	r31, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     c1e:	d3 83       	std	Z+3, r29	; 0x03
     c20:	c2 83       	std	Z+2, r28	; 0x02
     c22:	c0 17       	cp	r28, r16
     c24:	d1 07       	cpc	r29, r17
     c26:	68 f4       	brcc	.+26     	; 0xc42 <prvAddCurrentTaskToDelayedList+0x76>
     c28:	60 91 8e 01 	lds	r22, 0x018E	; 0x80018e <pxCurrentTCB>
     c2c:	70 91 8f 01 	lds	r23, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     c30:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <pxOverflowDelayedTaskList>
     c34:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <pxOverflowDelayedTaskList+0x1>
     c38:	6e 5f       	subi	r22, 0xFE	; 254
     c3a:	7f 4f       	sbci	r23, 0xFF	; 255
     c3c:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
     c40:	17 c0       	rjmp	.+46     	; 0xc70 <prvAddCurrentTaskToDelayedList+0xa4>
     c42:	60 91 8e 01 	lds	r22, 0x018E	; 0x80018e <pxCurrentTCB>
     c46:	70 91 8f 01 	lds	r23, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     c4a:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxDelayedTaskList>
     c4e:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxDelayedTaskList+0x1>
     c52:	6e 5f       	subi	r22, 0xFE	; 254
     c54:	7f 4f       	sbci	r23, 0xFF	; 255
     c56:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
     c5a:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <xNextTaskUnblockTime>
     c5e:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <xNextTaskUnblockTime+0x1>
     c62:	c8 17       	cp	r28, r24
     c64:	d9 07       	cpc	r29, r25
     c66:	20 f4       	brcc	.+8      	; 0xc70 <prvAddCurrentTaskToDelayedList+0xa4>
     c68:	d0 93 2d 01 	sts	0x012D, r29	; 0x80012d <xNextTaskUnblockTime+0x1>
     c6c:	c0 93 2c 01 	sts	0x012C, r28	; 0x80012c <xNextTaskUnblockTime>
     c70:	df 91       	pop	r29
     c72:	cf 91       	pop	r28
     c74:	1f 91       	pop	r17
     c76:	0f 91       	pop	r16
     c78:	ff 90       	pop	r15
     c7a:	08 95       	ret

00000c7c <prvIdleTask>:
     c7c:	02 e4       	ldi	r16, 0x42	; 66
     c7e:	11 e0       	ldi	r17, 0x01	; 1
     c80:	0f 2e       	mov	r0, r31
     c82:	fa e6       	ldi	r31, 0x6A	; 106
     c84:	ef 2e       	mov	r14, r31
     c86:	f1 e0       	ldi	r31, 0x01	; 1
     c88:	ff 2e       	mov	r15, r31
     c8a:	f0 2d       	mov	r31, r0
     c8c:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxDeletedTasksWaitingCleanUp>
     c90:	88 23       	and	r24, r24
     c92:	29 f1       	breq	.+74     	; 0xcde <prvIdleTask+0x62>
     c94:	0f b6       	in	r0, 0x3f	; 63
     c96:	f8 94       	cli
     c98:	0f 92       	push	r0
     c9a:	d8 01       	movw	r26, r16
     c9c:	15 96       	adiw	r26, 0x05	; 5
     c9e:	ed 91       	ld	r30, X+
     ca0:	fc 91       	ld	r31, X
     ca2:	16 97       	sbiw	r26, 0x06	; 6
     ca4:	c6 81       	ldd	r28, Z+6	; 0x06
     ca6:	d7 81       	ldd	r29, Z+7	; 0x07
     ca8:	ce 01       	movw	r24, r28
     caa:	02 96       	adiw	r24, 0x02	; 2
     cac:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
     cb0:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <uxCurrentNumberOfTasks>
     cb4:	81 50       	subi	r24, 0x01	; 1
     cb6:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <uxCurrentNumberOfTasks>
     cba:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxDeletedTasksWaitingCleanUp>
     cbe:	81 50       	subi	r24, 0x01	; 1
     cc0:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <uxDeletedTasksWaitingCleanUp>
     cc4:	0f 90       	pop	r0
     cc6:	0f be       	out	0x3f, r0	; 63
     cc8:	8f 89       	ldd	r24, Y+23	; 0x17
     cca:	98 8d       	ldd	r25, Y+24	; 0x18
     ccc:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     cd0:	ce 01       	movw	r24, r28
     cd2:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     cd6:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxDeletedTasksWaitingCleanUp>
     cda:	81 11       	cpse	r24, r1
     cdc:	db cf       	rjmp	.-74     	; 0xc94 <prvIdleTask+0x18>
     cde:	f7 01       	movw	r30, r14
     ce0:	80 81       	ld	r24, Z
     ce2:	82 30       	cpi	r24, 0x02	; 2
     ce4:	10 f0       	brcs	.+4      	; 0xcea <prvIdleTask+0x6e>
     ce6:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     cea:	0e 94 a1 00 	call	0x142	; 0x142 <vApplicationIdleHook>
     cee:	ce cf       	rjmp	.-100    	; 0xc8c <prvIdleTask+0x10>

00000cf0 <xTaskCreate>:
     cf0:	4f 92       	push	r4
     cf2:	5f 92       	push	r5
     cf4:	6f 92       	push	r6
     cf6:	7f 92       	push	r7
     cf8:	8f 92       	push	r8
     cfa:	9f 92       	push	r9
     cfc:	af 92       	push	r10
     cfe:	bf 92       	push	r11
     d00:	cf 92       	push	r12
     d02:	df 92       	push	r13
     d04:	ef 92       	push	r14
     d06:	ff 92       	push	r15
     d08:	0f 93       	push	r16
     d0a:	cf 93       	push	r28
     d0c:	df 93       	push	r29
     d0e:	4c 01       	movw	r8, r24
     d10:	6b 01       	movw	r12, r22
     d12:	5a 01       	movw	r10, r20
     d14:	29 01       	movw	r4, r18
     d16:	ca 01       	movw	r24, r20
     d18:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     d1c:	3c 01       	movw	r6, r24
     d1e:	89 2b       	or	r24, r25
     d20:	09 f4       	brne	.+2      	; 0xd24 <xTaskCreate+0x34>
     d22:	f1 c0       	rjmp	.+482    	; 0xf06 <xTaskCreate+0x216>
     d24:	88 e2       	ldi	r24, 0x28	; 40
     d26:	90 e0       	ldi	r25, 0x00	; 0
     d28:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     d2c:	ec 01       	movw	r28, r24
     d2e:	89 2b       	or	r24, r25
     d30:	99 f0       	breq	.+38     	; 0xd58 <xTaskCreate+0x68>
     d32:	78 8e       	std	Y+24, r7	; 0x18
     d34:	6f 8a       	std	Y+23, r6	; 0x17
     d36:	a5 01       	movw	r20, r10
     d38:	65 ea       	ldi	r22, 0xA5	; 165
     d3a:	70 e0       	ldi	r23, 0x00	; 0
     d3c:	c3 01       	movw	r24, r6
     d3e:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <memset>
     d42:	81 e0       	ldi	r24, 0x01	; 1
     d44:	a8 1a       	sub	r10, r24
     d46:	b1 08       	sbc	r11, r1
     d48:	8f 89       	ldd	r24, Y+23	; 0x17
     d4a:	98 8d       	ldd	r25, Y+24	; 0x18
     d4c:	a8 0e       	add	r10, r24
     d4e:	b9 1e       	adc	r11, r25
     d50:	c1 14       	cp	r12, r1
     d52:	d1 04       	cpc	r13, r1
     d54:	29 f4       	brne	.+10     	; 0xd60 <xTaskCreate+0x70>
     d56:	20 c0       	rjmp	.+64     	; 0xd98 <xTaskCreate+0xa8>
     d58:	c3 01       	movw	r24, r6
     d5a:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     d5e:	d3 c0       	rjmp	.+422    	; 0xf06 <xTaskCreate+0x216>
     d60:	d6 01       	movw	r26, r12
     d62:	8c 91       	ld	r24, X
     d64:	89 8f       	std	Y+25, r24	; 0x19
     d66:	8c 91       	ld	r24, X
     d68:	88 23       	and	r24, r24
     d6a:	a1 f0       	breq	.+40     	; 0xd94 <xTaskCreate+0xa4>
     d6c:	ae 01       	movw	r20, r28
     d6e:	46 5e       	subi	r20, 0xE6	; 230
     d70:	5f 4f       	sbci	r21, 0xFF	; 255
     d72:	f6 01       	movw	r30, r12
     d74:	31 96       	adiw	r30, 0x01	; 1
     d76:	b8 e0       	ldi	r27, 0x08	; 8
     d78:	cb 0e       	add	r12, r27
     d7a:	d1 1c       	adc	r13, r1
     d7c:	cf 01       	movw	r24, r30
     d7e:	21 91       	ld	r18, Z+
     d80:	da 01       	movw	r26, r20
     d82:	2d 93       	st	X+, r18
     d84:	ad 01       	movw	r20, r26
     d86:	dc 01       	movw	r26, r24
     d88:	8c 91       	ld	r24, X
     d8a:	88 23       	and	r24, r24
     d8c:	19 f0       	breq	.+6      	; 0xd94 <xTaskCreate+0xa4>
     d8e:	ec 15       	cp	r30, r12
     d90:	fd 05       	cpc	r31, r13
     d92:	a1 f7       	brne	.-24     	; 0xd7c <xTaskCreate+0x8c>
     d94:	18 a2       	std	Y+32, r1	; 0x20
     d96:	01 c0       	rjmp	.+2      	; 0xd9a <xTaskCreate+0xaa>
     d98:	19 8e       	std	Y+25, r1	; 0x19
     d9a:	04 30       	cpi	r16, 0x04	; 4
     d9c:	08 f0       	brcs	.+2      	; 0xda0 <xTaskCreate+0xb0>
     d9e:	03 e0       	ldi	r16, 0x03	; 3
     da0:	0e 8b       	std	Y+22, r16	; 0x16
     da2:	09 a3       	std	Y+33, r16	; 0x21
     da4:	1a a2       	std	Y+34, r1	; 0x22
     da6:	6e 01       	movw	r12, r28
     da8:	b2 e0       	ldi	r27, 0x02	; 2
     daa:	cb 0e       	add	r12, r27
     dac:	d1 1c       	adc	r13, r1
     dae:	c6 01       	movw	r24, r12
     db0:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vListInitialiseItem>
     db4:	ce 01       	movw	r24, r28
     db6:	0c 96       	adiw	r24, 0x0c	; 12
     db8:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vListInitialiseItem>
     dbc:	d9 87       	std	Y+9, r29	; 0x09
     dbe:	c8 87       	std	Y+8, r28	; 0x08
     dc0:	84 e0       	ldi	r24, 0x04	; 4
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	80 1b       	sub	r24, r16
     dc6:	91 09       	sbc	r25, r1
     dc8:	9d 87       	std	Y+13, r25	; 0x0d
     dca:	8c 87       	std	Y+12, r24	; 0x0c
     dcc:	db 8b       	std	Y+19, r29	; 0x13
     dce:	ca 8b       	std	Y+18, r28	; 0x12
     dd0:	1b a2       	std	Y+35, r1	; 0x23
     dd2:	1c a2       	std	Y+36, r1	; 0x24
     dd4:	1d a2       	std	Y+37, r1	; 0x25
     dd6:	1e a2       	std	Y+38, r1	; 0x26
     dd8:	1f a2       	std	Y+39, r1	; 0x27
     dda:	a2 01       	movw	r20, r4
     ddc:	b4 01       	movw	r22, r8
     dde:	c5 01       	movw	r24, r10
     de0:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <pxPortInitialiseStack>
     de4:	99 83       	std	Y+1, r25	; 0x01
     de6:	88 83       	st	Y, r24
     de8:	e1 14       	cp	r14, r1
     dea:	f1 04       	cpc	r15, r1
     dec:	19 f0       	breq	.+6      	; 0xdf4 <xTaskCreate+0x104>
     dee:	f7 01       	movw	r30, r14
     df0:	d1 83       	std	Z+1, r29	; 0x01
     df2:	c0 83       	st	Z, r28
     df4:	0f b6       	in	r0, 0x3f	; 63
     df6:	f8 94       	cli
     df8:	0f 92       	push	r0
     dfa:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <uxCurrentNumberOfTasks>
     dfe:	8f 5f       	subi	r24, 0xFF	; 255
     e00:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <uxCurrentNumberOfTasks>
     e04:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <pxCurrentTCB>
     e08:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     e0c:	89 2b       	or	r24, r25
     e0e:	d1 f5       	brne	.+116    	; 0xe84 <xTaskCreate+0x194>
     e10:	d0 93 8f 01 	sts	0x018F, r29	; 0x80018f <pxCurrentTCB+0x1>
     e14:	c0 93 8e 01 	sts	0x018E, r28	; 0x80018e <pxCurrentTCB>
     e18:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <uxCurrentNumberOfTasks>
     e1c:	81 30       	cpi	r24, 0x01	; 1
     e1e:	09 f0       	breq	.+2      	; 0xe22 <xTaskCreate+0x132>
     e20:	41 c0       	rjmp	.+130    	; 0xea4 <xTaskCreate+0x1b4>
     e22:	8a e6       	ldi	r24, 0x6A	; 106
     e24:	91 e0       	ldi	r25, 0x01	; 1
     e26:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e2a:	83 e7       	ldi	r24, 0x73	; 115
     e2c:	91 e0       	ldi	r25, 0x01	; 1
     e2e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e32:	8c e7       	ldi	r24, 0x7C	; 124
     e34:	91 e0       	ldi	r25, 0x01	; 1
     e36:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e3a:	85 e8       	ldi	r24, 0x85	; 133
     e3c:	91 e0       	ldi	r25, 0x01	; 1
     e3e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e42:	81 e6       	ldi	r24, 0x61	; 97
     e44:	91 e0       	ldi	r25, 0x01	; 1
     e46:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e4a:	88 e5       	ldi	r24, 0x58	; 88
     e4c:	91 e0       	ldi	r25, 0x01	; 1
     e4e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e52:	8b e4       	ldi	r24, 0x4B	; 75
     e54:	91 e0       	ldi	r25, 0x01	; 1
     e56:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e5a:	82 e4       	ldi	r24, 0x42	; 66
     e5c:	91 e0       	ldi	r25, 0x01	; 1
     e5e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e62:	88 e3       	ldi	r24, 0x38	; 56
     e64:	91 e0       	ldi	r25, 0x01	; 1
     e66:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     e6a:	81 e6       	ldi	r24, 0x61	; 97
     e6c:	91 e0       	ldi	r25, 0x01	; 1
     e6e:	90 93 57 01 	sts	0x0157, r25	; 0x800157 <pxDelayedTaskList+0x1>
     e72:	80 93 56 01 	sts	0x0156, r24	; 0x800156 <pxDelayedTaskList>
     e76:	88 e5       	ldi	r24, 0x58	; 88
     e78:	91 e0       	ldi	r25, 0x01	; 1
     e7a:	90 93 55 01 	sts	0x0155, r25	; 0x800155 <pxOverflowDelayedTaskList+0x1>
     e7e:	80 93 54 01 	sts	0x0154, r24	; 0x800154 <pxOverflowDelayedTaskList>
     e82:	10 c0       	rjmp	.+32     	; 0xea4 <xTaskCreate+0x1b4>
     e84:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xSchedulerRunning>
     e88:	81 11       	cpse	r24, r1
     e8a:	0c c0       	rjmp	.+24     	; 0xea4 <xTaskCreate+0x1b4>
     e8c:	e0 91 8e 01 	lds	r30, 0x018E	; 0x80018e <pxCurrentTCB>
     e90:	f0 91 8f 01 	lds	r31, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     e94:	96 89       	ldd	r25, Z+22	; 0x16
     e96:	8e 89       	ldd	r24, Y+22	; 0x16
     e98:	89 17       	cp	r24, r25
     e9a:	20 f0       	brcs	.+8      	; 0xea4 <xTaskCreate+0x1b4>
     e9c:	d0 93 8f 01 	sts	0x018F, r29	; 0x80018f <pxCurrentTCB+0x1>
     ea0:	c0 93 8e 01 	sts	0x018E, r28	; 0x80018e <pxCurrentTCB>
     ea4:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <uxTaskNumber>
     ea8:	8f 5f       	subi	r24, 0xFF	; 255
     eaa:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <uxTaskNumber>
     eae:	8e 89       	ldd	r24, Y+22	; 0x16
     eb0:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <uxTopReadyPriority>
     eb4:	98 17       	cp	r25, r24
     eb6:	10 f4       	brcc	.+4      	; 0xebc <xTaskCreate+0x1cc>
     eb8:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxTopReadyPriority>
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	9c 01       	movw	r18, r24
     ec0:	22 0f       	add	r18, r18
     ec2:	33 1f       	adc	r19, r19
     ec4:	22 0f       	add	r18, r18
     ec6:	33 1f       	adc	r19, r19
     ec8:	22 0f       	add	r18, r18
     eca:	33 1f       	adc	r19, r19
     ecc:	82 0f       	add	r24, r18
     ece:	93 1f       	adc	r25, r19
     ed0:	b6 01       	movw	r22, r12
     ed2:	86 59       	subi	r24, 0x96	; 150
     ed4:	9e 4f       	sbci	r25, 0xFE	; 254
     ed6:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
     eda:	0f 90       	pop	r0
     edc:	0f be       	out	0x3f, r0	; 63
     ede:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xSchedulerRunning>
     ee2:	88 23       	and	r24, r24
     ee4:	61 f0       	breq	.+24     	; 0xefe <xTaskCreate+0x20e>
     ee6:	e0 91 8e 01 	lds	r30, 0x018E	; 0x80018e <pxCurrentTCB>
     eea:	f0 91 8f 01 	lds	r31, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
     eee:	96 89       	ldd	r25, Z+22	; 0x16
     ef0:	8e 89       	ldd	r24, Y+22	; 0x16
     ef2:	98 17       	cp	r25, r24
     ef4:	30 f4       	brcc	.+12     	; 0xf02 <xTaskCreate+0x212>
     ef6:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	05 c0       	rjmp	.+10     	; 0xf08 <xTaskCreate+0x218>
     efe:	81 e0       	ldi	r24, 0x01	; 1
     f00:	03 c0       	rjmp	.+6      	; 0xf08 <xTaskCreate+0x218>
     f02:	81 e0       	ldi	r24, 0x01	; 1
     f04:	01 c0       	rjmp	.+2      	; 0xf08 <xTaskCreate+0x218>
     f06:	8f ef       	ldi	r24, 0xFF	; 255
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	0f 91       	pop	r16
     f0e:	ff 90       	pop	r15
     f10:	ef 90       	pop	r14
     f12:	df 90       	pop	r13
     f14:	cf 90       	pop	r12
     f16:	bf 90       	pop	r11
     f18:	af 90       	pop	r10
     f1a:	9f 90       	pop	r9
     f1c:	8f 90       	pop	r8
     f1e:	7f 90       	pop	r7
     f20:	6f 90       	pop	r6
     f22:	5f 90       	pop	r5
     f24:	4f 90       	pop	r4
     f26:	08 95       	ret

00000f28 <vTaskStartScheduler>:
     f28:	ef 92       	push	r14
     f2a:	ff 92       	push	r15
     f2c:	0f 93       	push	r16
     f2e:	0f 2e       	mov	r0, r31
     f30:	fa e2       	ldi	r31, 0x2A	; 42
     f32:	ef 2e       	mov	r14, r31
     f34:	f1 e0       	ldi	r31, 0x01	; 1
     f36:	ff 2e       	mov	r15, r31
     f38:	f0 2d       	mov	r31, r0
     f3a:	00 e0       	ldi	r16, 0x00	; 0
     f3c:	20 e0       	ldi	r18, 0x00	; 0
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	45 e5       	ldi	r20, 0x55	; 85
     f42:	50 e0       	ldi	r21, 0x00	; 0
     f44:	66 e1       	ldi	r22, 0x16	; 22
     f46:	71 e0       	ldi	r23, 0x01	; 1
     f48:	8e e3       	ldi	r24, 0x3E	; 62
     f4a:	96 e0       	ldi	r25, 0x06	; 6
     f4c:	0e 94 78 06 	call	0xcf0	; 0xcf0 <xTaskCreate>
     f50:	81 30       	cpi	r24, 0x01	; 1
     f52:	a1 f4       	brne	.+40     	; 0xf7c <vTaskStartScheduler+0x54>
     f54:	0e 94 83 0b 	call	0x1706	; 0x1706 <xTimerCreateTimerTask>
     f58:	81 30       	cpi	r24, 0x01	; 1
     f5a:	81 f4       	brne	.+32     	; 0xf7c <vTaskStartScheduler+0x54>
     f5c:	f8 94       	cli
     f5e:	8f ef       	ldi	r24, 0xFF	; 255
     f60:	9f ef       	ldi	r25, 0xFF	; 255
     f62:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <xNextTaskUnblockTime+0x1>
     f66:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <xNextTaskUnblockTime>
     f6a:	81 e0       	ldi	r24, 0x01	; 1
     f6c:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <xSchedulerRunning>
     f70:	10 92 36 01 	sts	0x0136, r1	; 0x800136 <xTickCount+0x1>
     f74:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <xTickCount>
     f78:	0e 94 09 02 	call	0x412	; 0x412 <xPortStartScheduler>
     f7c:	0f 91       	pop	r16
     f7e:	ff 90       	pop	r15
     f80:	ef 90       	pop	r14
     f82:	08 95       	ret

00000f84 <vTaskSuspendAll>:
     f84:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <uxSchedulerSuspended>
     f88:	8f 5f       	subi	r24, 0xFF	; 255
     f8a:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <uxSchedulerSuspended>
     f8e:	08 95       	ret

00000f90 <xTaskGetTickCount>:
     f90:	0f b6       	in	r0, 0x3f	; 63
     f92:	f8 94       	cli
     f94:	0f 92       	push	r0
     f96:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <xTickCount>
     f9a:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <xTickCount+0x1>
     f9e:	0f 90       	pop	r0
     fa0:	0f be       	out	0x3f, r0	; 63
     fa2:	08 95       	ret

00000fa4 <xTaskIncrementTick>:
     fa4:	cf 92       	push	r12
     fa6:	df 92       	push	r13
     fa8:	ef 92       	push	r14
     faa:	ff 92       	push	r15
     fac:	0f 93       	push	r16
     fae:	1f 93       	push	r17
     fb0:	cf 93       	push	r28
     fb2:	df 93       	push	r29
     fb4:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <uxSchedulerSuspended>
     fb8:	81 11       	cpse	r24, r1
     fba:	9f c0       	rjmp	.+318    	; 0x10fa <xTaskIncrementTick+0x156>
     fbc:	e0 90 35 01 	lds	r14, 0x0135	; 0x800135 <xTickCount>
     fc0:	f0 90 36 01 	lds	r15, 0x0136	; 0x800136 <xTickCount+0x1>
     fc4:	8f ef       	ldi	r24, 0xFF	; 255
     fc6:	e8 1a       	sub	r14, r24
     fc8:	f8 0a       	sbc	r15, r24
     fca:	f0 92 36 01 	sts	0x0136, r15	; 0x800136 <xTickCount+0x1>
     fce:	e0 92 35 01 	sts	0x0135, r14	; 0x800135 <xTickCount>
     fd2:	e1 14       	cp	r14, r1
     fd4:	f1 04       	cpc	r15, r1
     fd6:	b9 f4       	brne	.+46     	; 0x1006 <xTaskIncrementTick+0x62>
     fd8:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <pxDelayedTaskList>
     fdc:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <pxDelayedTaskList+0x1>
     fe0:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <pxOverflowDelayedTaskList>
     fe4:	30 91 55 01 	lds	r19, 0x0155	; 0x800155 <pxOverflowDelayedTaskList+0x1>
     fe8:	30 93 57 01 	sts	0x0157, r19	; 0x800157 <pxDelayedTaskList+0x1>
     fec:	20 93 56 01 	sts	0x0156, r18	; 0x800156 <pxDelayedTaskList>
     ff0:	90 93 55 01 	sts	0x0155, r25	; 0x800155 <pxOverflowDelayedTaskList+0x1>
     ff4:	80 93 54 01 	sts	0x0154, r24	; 0x800154 <pxOverflowDelayedTaskList>
     ff8:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <xNumOfOverflows>
     ffc:	8f 5f       	subi	r24, 0xFF	; 255
     ffe:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xNumOfOverflows>
    1002:	0e 94 c7 05 	call	0xb8e	; 0xb8e <prvResetNextTaskUnblockTime>
    1006:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <xNextTaskUnblockTime>
    100a:	90 91 2d 01 	lds	r25, 0x012D	; 0x80012d <xNextTaskUnblockTime+0x1>
    100e:	e8 16       	cp	r14, r24
    1010:	f9 06       	cpc	r15, r25
    1012:	10 f4       	brcc	.+4      	; 0x1018 <xTaskIncrementTick+0x74>
    1014:	d1 2c       	mov	r13, r1
    1016:	53 c0       	rjmp	.+166    	; 0x10be <xTaskIncrementTick+0x11a>
    1018:	d1 2c       	mov	r13, r1
    101a:	cc 24       	eor	r12, r12
    101c:	c3 94       	inc	r12
    101e:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxDelayedTaskList>
    1022:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxDelayedTaskList+0x1>
    1026:	80 81       	ld	r24, Z
    1028:	81 11       	cpse	r24, r1
    102a:	07 c0       	rjmp	.+14     	; 0x103a <xTaskIncrementTick+0x96>
    102c:	8f ef       	ldi	r24, 0xFF	; 255
    102e:	9f ef       	ldi	r25, 0xFF	; 255
    1030:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <xNextTaskUnblockTime+0x1>
    1034:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <xNextTaskUnblockTime>
    1038:	42 c0       	rjmp	.+132    	; 0x10be <xTaskIncrementTick+0x11a>
    103a:	e0 91 56 01 	lds	r30, 0x0156	; 0x800156 <pxDelayedTaskList>
    103e:	f0 91 57 01 	lds	r31, 0x0157	; 0x800157 <pxDelayedTaskList+0x1>
    1042:	05 80       	ldd	r0, Z+5	; 0x05
    1044:	f6 81       	ldd	r31, Z+6	; 0x06
    1046:	e0 2d       	mov	r30, r0
    1048:	c6 81       	ldd	r28, Z+6	; 0x06
    104a:	d7 81       	ldd	r29, Z+7	; 0x07
    104c:	8a 81       	ldd	r24, Y+2	; 0x02
    104e:	9b 81       	ldd	r25, Y+3	; 0x03
    1050:	e8 16       	cp	r14, r24
    1052:	f9 06       	cpc	r15, r25
    1054:	28 f4       	brcc	.+10     	; 0x1060 <xTaskIncrementTick+0xbc>
    1056:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <xNextTaskUnblockTime+0x1>
    105a:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <xNextTaskUnblockTime>
    105e:	2f c0       	rjmp	.+94     	; 0x10be <xTaskIncrementTick+0x11a>
    1060:	8e 01       	movw	r16, r28
    1062:	0e 5f       	subi	r16, 0xFE	; 254
    1064:	1f 4f       	sbci	r17, 0xFF	; 255
    1066:	c8 01       	movw	r24, r16
    1068:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    106c:	8c 89       	ldd	r24, Y+20	; 0x14
    106e:	9d 89       	ldd	r25, Y+21	; 0x15
    1070:	89 2b       	or	r24, r25
    1072:	21 f0       	breq	.+8      	; 0x107c <xTaskIncrementTick+0xd8>
    1074:	ce 01       	movw	r24, r28
    1076:	0c 96       	adiw	r24, 0x0c	; 12
    1078:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    107c:	8e 89       	ldd	r24, Y+22	; 0x16
    107e:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <uxTopReadyPriority>
    1082:	98 17       	cp	r25, r24
    1084:	10 f4       	brcc	.+4      	; 0x108a <xTaskIncrementTick+0xe6>
    1086:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxTopReadyPriority>
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	9c 01       	movw	r18, r24
    108e:	22 0f       	add	r18, r18
    1090:	33 1f       	adc	r19, r19
    1092:	22 0f       	add	r18, r18
    1094:	33 1f       	adc	r19, r19
    1096:	22 0f       	add	r18, r18
    1098:	33 1f       	adc	r19, r19
    109a:	82 0f       	add	r24, r18
    109c:	93 1f       	adc	r25, r19
    109e:	b8 01       	movw	r22, r16
    10a0:	86 59       	subi	r24, 0x96	; 150
    10a2:	9e 4f       	sbci	r25, 0xFE	; 254
    10a4:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    10a8:	e0 91 8e 01 	lds	r30, 0x018E	; 0x80018e <pxCurrentTCB>
    10ac:	f0 91 8f 01 	lds	r31, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    10b0:	9e 89       	ldd	r25, Y+22	; 0x16
    10b2:	86 89       	ldd	r24, Z+22	; 0x16
    10b4:	98 17       	cp	r25, r24
    10b6:	08 f4       	brcc	.+2      	; 0x10ba <xTaskIncrementTick+0x116>
    10b8:	b2 cf       	rjmp	.-156    	; 0x101e <xTaskIncrementTick+0x7a>
    10ba:	dc 2c       	mov	r13, r12
    10bc:	b0 cf       	rjmp	.-160    	; 0x101e <xTaskIncrementTick+0x7a>
    10be:	e0 91 8e 01 	lds	r30, 0x018E	; 0x80018e <pxCurrentTCB>
    10c2:	f0 91 8f 01 	lds	r31, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    10c6:	86 89       	ldd	r24, Z+22	; 0x16
    10c8:	90 e0       	ldi	r25, 0x00	; 0
    10ca:	fc 01       	movw	r30, r24
    10cc:	ee 0f       	add	r30, r30
    10ce:	ff 1f       	adc	r31, r31
    10d0:	ee 0f       	add	r30, r30
    10d2:	ff 1f       	adc	r31, r31
    10d4:	ee 0f       	add	r30, r30
    10d6:	ff 1f       	adc	r31, r31
    10d8:	8e 0f       	add	r24, r30
    10da:	9f 1f       	adc	r25, r31
    10dc:	fc 01       	movw	r30, r24
    10de:	e6 59       	subi	r30, 0x96	; 150
    10e0:	fe 4f       	sbci	r31, 0xFE	; 254
    10e2:	80 81       	ld	r24, Z
    10e4:	82 30       	cpi	r24, 0x02	; 2
    10e6:	10 f0       	brcs	.+4      	; 0x10ec <xTaskIncrementTick+0x148>
    10e8:	dd 24       	eor	r13, r13
    10ea:	d3 94       	inc	r13
    10ec:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xYieldPending>
    10f0:	88 23       	and	r24, r24
    10f2:	69 f0       	breq	.+26     	; 0x110e <xTaskIncrementTick+0x16a>
    10f4:	dd 24       	eor	r13, r13
    10f6:	d3 94       	inc	r13
    10f8:	0a c0       	rjmp	.+20     	; 0x110e <xTaskIncrementTick+0x16a>
    10fa:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <xPendedTicks>
    10fe:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <xPendedTicks+0x1>
    1102:	01 96       	adiw	r24, 0x01	; 1
    1104:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <xPendedTicks+0x1>
    1108:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <xPendedTicks>
    110c:	d1 2c       	mov	r13, r1
    110e:	8d 2d       	mov	r24, r13
    1110:	df 91       	pop	r29
    1112:	cf 91       	pop	r28
    1114:	1f 91       	pop	r17
    1116:	0f 91       	pop	r16
    1118:	ff 90       	pop	r15
    111a:	ef 90       	pop	r14
    111c:	df 90       	pop	r13
    111e:	cf 90       	pop	r12
    1120:	08 95       	ret

00001122 <xTaskResumeAll>:
    1122:	df 92       	push	r13
    1124:	ef 92       	push	r14
    1126:	ff 92       	push	r15
    1128:	0f 93       	push	r16
    112a:	1f 93       	push	r17
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	f8 94       	cli
    1134:	0f 92       	push	r0
    1136:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <uxSchedulerSuspended>
    113a:	81 50       	subi	r24, 0x01	; 1
    113c:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <uxSchedulerSuspended>
    1140:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <uxSchedulerSuspended>
    1144:	81 11       	cpse	r24, r1
    1146:	63 c0       	rjmp	.+198    	; 0x120e <xTaskResumeAll+0xec>
    1148:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <uxCurrentNumberOfTasks>
    114c:	81 11       	cpse	r24, r1
    114e:	33 c0       	rjmp	.+102    	; 0x11b6 <xTaskResumeAll+0x94>
    1150:	61 c0       	rjmp	.+194    	; 0x1214 <xTaskResumeAll+0xf2>
    1152:	d7 01       	movw	r26, r14
    1154:	15 96       	adiw	r26, 0x05	; 5
    1156:	ed 91       	ld	r30, X+
    1158:	fc 91       	ld	r31, X
    115a:	16 97       	sbiw	r26, 0x06	; 6
    115c:	c6 81       	ldd	r28, Z+6	; 0x06
    115e:	d7 81       	ldd	r29, Z+7	; 0x07
    1160:	ce 01       	movw	r24, r28
    1162:	0c 96       	adiw	r24, 0x0c	; 12
    1164:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    1168:	8e 01       	movw	r16, r28
    116a:	0e 5f       	subi	r16, 0xFE	; 254
    116c:	1f 4f       	sbci	r17, 0xFF	; 255
    116e:	c8 01       	movw	r24, r16
    1170:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    1174:	8e 89       	ldd	r24, Y+22	; 0x16
    1176:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <uxTopReadyPriority>
    117a:	98 17       	cp	r25, r24
    117c:	10 f4       	brcc	.+4      	; 0x1182 <xTaskResumeAll+0x60>
    117e:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxTopReadyPriority>
    1182:	90 e0       	ldi	r25, 0x00	; 0
    1184:	9c 01       	movw	r18, r24
    1186:	22 0f       	add	r18, r18
    1188:	33 1f       	adc	r19, r19
    118a:	22 0f       	add	r18, r18
    118c:	33 1f       	adc	r19, r19
    118e:	22 0f       	add	r18, r18
    1190:	33 1f       	adc	r19, r19
    1192:	82 0f       	add	r24, r18
    1194:	93 1f       	adc	r25, r19
    1196:	b8 01       	movw	r22, r16
    1198:	86 59       	subi	r24, 0x96	; 150
    119a:	9e 4f       	sbci	r25, 0xFE	; 254
    119c:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    11a0:	e0 91 8e 01 	lds	r30, 0x018E	; 0x80018e <pxCurrentTCB>
    11a4:	f0 91 8f 01 	lds	r31, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    11a8:	9e 89       	ldd	r25, Y+22	; 0x16
    11aa:	86 89       	ldd	r24, Z+22	; 0x16
    11ac:	98 17       	cp	r25, r24
    11ae:	68 f0       	brcs	.+26     	; 0x11ca <xTaskResumeAll+0xa8>
    11b0:	d0 92 30 01 	sts	0x0130, r13	; 0x800130 <xYieldPending>
    11b4:	0a c0       	rjmp	.+20     	; 0x11ca <xTaskResumeAll+0xa8>
    11b6:	c0 e0       	ldi	r28, 0x00	; 0
    11b8:	d0 e0       	ldi	r29, 0x00	; 0
    11ba:	0f 2e       	mov	r0, r31
    11bc:	fb e4       	ldi	r31, 0x4B	; 75
    11be:	ef 2e       	mov	r14, r31
    11c0:	f1 e0       	ldi	r31, 0x01	; 1
    11c2:	ff 2e       	mov	r15, r31
    11c4:	f0 2d       	mov	r31, r0
    11c6:	dd 24       	eor	r13, r13
    11c8:	d3 94       	inc	r13
    11ca:	f7 01       	movw	r30, r14
    11cc:	80 81       	ld	r24, Z
    11ce:	81 11       	cpse	r24, r1
    11d0:	c0 cf       	rjmp	.-128    	; 0x1152 <xTaskResumeAll+0x30>
    11d2:	cd 2b       	or	r28, r29
    11d4:	11 f0       	breq	.+4      	; 0x11da <xTaskResumeAll+0xb8>
    11d6:	0e 94 c7 05 	call	0xb8e	; 0xb8e <prvResetNextTaskUnblockTime>
    11da:	c0 91 31 01 	lds	r28, 0x0131	; 0x800131 <xPendedTicks>
    11de:	d0 91 32 01 	lds	r29, 0x0132	; 0x800132 <xPendedTicks+0x1>
    11e2:	20 97       	sbiw	r28, 0x00	; 0
    11e4:	61 f0       	breq	.+24     	; 0x11fe <xTaskResumeAll+0xdc>
    11e6:	11 e0       	ldi	r17, 0x01	; 1
    11e8:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <xTaskIncrementTick>
    11ec:	81 11       	cpse	r24, r1
    11ee:	10 93 30 01 	sts	0x0130, r17	; 0x800130 <xYieldPending>
    11f2:	21 97       	sbiw	r28, 0x01	; 1
    11f4:	c9 f7       	brne	.-14     	; 0x11e8 <xTaskResumeAll+0xc6>
    11f6:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <xPendedTicks+0x1>
    11fa:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <xPendedTicks>
    11fe:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xYieldPending>
    1202:	88 23       	and	r24, r24
    1204:	31 f0       	breq	.+12     	; 0x1212 <xTaskResumeAll+0xf0>
    1206:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
    120a:	81 e0       	ldi	r24, 0x01	; 1
    120c:	03 c0       	rjmp	.+6      	; 0x1214 <xTaskResumeAll+0xf2>
    120e:	80 e0       	ldi	r24, 0x00	; 0
    1210:	01 c0       	rjmp	.+2      	; 0x1214 <xTaskResumeAll+0xf2>
    1212:	80 e0       	ldi	r24, 0x00	; 0
    1214:	0f 90       	pop	r0
    1216:	0f be       	out	0x3f, r0	; 63
    1218:	df 91       	pop	r29
    121a:	cf 91       	pop	r28
    121c:	1f 91       	pop	r17
    121e:	0f 91       	pop	r16
    1220:	ff 90       	pop	r15
    1222:	ef 90       	pop	r14
    1224:	df 90       	pop	r13
    1226:	08 95       	ret

00001228 <vTaskDelayUntil>:
    1228:	0f 93       	push	r16
    122a:	1f 93       	push	r17
    122c:	cf 93       	push	r28
    122e:	df 93       	push	r29
    1230:	8c 01       	movw	r16, r24
    1232:	eb 01       	movw	r28, r22
    1234:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
    1238:	40 91 35 01 	lds	r20, 0x0135	; 0x800135 <xTickCount>
    123c:	50 91 36 01 	lds	r21, 0x0136	; 0x800136 <xTickCount+0x1>
    1240:	f8 01       	movw	r30, r16
    1242:	20 81       	ld	r18, Z
    1244:	31 81       	ldd	r19, Z+1	; 0x01
    1246:	c9 01       	movw	r24, r18
    1248:	8c 0f       	add	r24, r28
    124a:	9d 1f       	adc	r25, r29
    124c:	42 17       	cp	r20, r18
    124e:	53 07       	cpc	r21, r19
    1250:	48 f4       	brcc	.+18     	; 0x1264 <vTaskDelayUntil+0x3c>
    1252:	82 17       	cp	r24, r18
    1254:	93 07       	cpc	r25, r19
    1256:	e8 f4       	brcc	.+58     	; 0x1292 <vTaskDelayUntil+0x6a>
    1258:	91 83       	std	Z+1, r25	; 0x01
    125a:	80 83       	st	Z, r24
    125c:	48 17       	cp	r20, r24
    125e:	59 07       	cpc	r21, r25
    1260:	68 f4       	brcc	.+26     	; 0x127c <vTaskDelayUntil+0x54>
    1262:	07 c0       	rjmp	.+14     	; 0x1272 <vTaskDelayUntil+0x4a>
    1264:	82 17       	cp	r24, r18
    1266:	93 07       	cpc	r25, r19
    1268:	80 f0       	brcs	.+32     	; 0x128a <vTaskDelayUntil+0x62>
    126a:	48 17       	cp	r20, r24
    126c:	59 07       	cpc	r21, r25
    126e:	68 f0       	brcs	.+26     	; 0x128a <vTaskDelayUntil+0x62>
    1270:	10 c0       	rjmp	.+32     	; 0x1292 <vTaskDelayUntil+0x6a>
    1272:	60 e0       	ldi	r22, 0x00	; 0
    1274:	84 1b       	sub	r24, r20
    1276:	95 0b       	sbc	r25, r21
    1278:	0e 94 e6 05 	call	0xbcc	; 0xbcc <prvAddCurrentTaskToDelayedList>
    127c:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
    1280:	81 11       	cpse	r24, r1
    1282:	0b c0       	rjmp	.+22     	; 0x129a <vTaskDelayUntil+0x72>
    1284:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
    1288:	08 c0       	rjmp	.+16     	; 0x129a <vTaskDelayUntil+0x72>
    128a:	f8 01       	movw	r30, r16
    128c:	91 83       	std	Z+1, r25	; 0x01
    128e:	80 83       	st	Z, r24
    1290:	f0 cf       	rjmp	.-32     	; 0x1272 <vTaskDelayUntil+0x4a>
    1292:	f8 01       	movw	r30, r16
    1294:	91 83       	std	Z+1, r25	; 0x01
    1296:	80 83       	st	Z, r24
    1298:	f1 cf       	rjmp	.-30     	; 0x127c <vTaskDelayUntil+0x54>
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	08 95       	ret

000012a4 <vTaskSwitchContext>:
    12a4:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <uxSchedulerSuspended>
    12a8:	88 23       	and	r24, r24
    12aa:	21 f0       	breq	.+8      	; 0x12b4 <vTaskSwitchContext+0x10>
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <xYieldPending>
    12b2:	08 95       	ret
    12b4:	10 92 30 01 	sts	0x0130, r1	; 0x800130 <xYieldPending>
    12b8:	a0 91 8e 01 	lds	r26, 0x018E	; 0x80018e <pxCurrentTCB>
    12bc:	b0 91 8f 01 	lds	r27, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    12c0:	e0 91 8e 01 	lds	r30, 0x018E	; 0x80018e <pxCurrentTCB>
    12c4:	f0 91 8f 01 	lds	r31, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    12c8:	2d 91       	ld	r18, X+
    12ca:	3c 91       	ld	r19, X
    12cc:	87 89       	ldd	r24, Z+23	; 0x17
    12ce:	90 8d       	ldd	r25, Z+24	; 0x18
    12d0:	82 17       	cp	r24, r18
    12d2:	93 07       	cpc	r25, r19
    12d4:	60 f0       	brcs	.+24     	; 0x12ee <vTaskSwitchContext+0x4a>
    12d6:	60 91 8e 01 	lds	r22, 0x018E	; 0x80018e <pxCurrentTCB>
    12da:	70 91 8f 01 	lds	r23, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    12de:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <pxCurrentTCB>
    12e2:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    12e6:	67 5e       	subi	r22, 0xE7	; 231
    12e8:	7f 4f       	sbci	r23, 0xFF	; 255
    12ea:	0e 94 c5 00 	call	0x18a	; 0x18a <vApplicationStackOverflowHook>
    12ee:	20 91 34 01 	lds	r18, 0x0134	; 0x800134 <uxTopReadyPriority>
    12f2:	82 2f       	mov	r24, r18
    12f4:	90 e0       	ldi	r25, 0x00	; 0
    12f6:	fc 01       	movw	r30, r24
    12f8:	ee 0f       	add	r30, r30
    12fa:	ff 1f       	adc	r31, r31
    12fc:	ee 0f       	add	r30, r30
    12fe:	ff 1f       	adc	r31, r31
    1300:	ee 0f       	add	r30, r30
    1302:	ff 1f       	adc	r31, r31
    1304:	e8 0f       	add	r30, r24
    1306:	f9 1f       	adc	r31, r25
    1308:	e6 59       	subi	r30, 0x96	; 150
    130a:	fe 4f       	sbci	r31, 0xFE	; 254
    130c:	30 81       	ld	r19, Z
    130e:	31 11       	cpse	r19, r1
    1310:	11 c0       	rjmp	.+34     	; 0x1334 <vTaskSwitchContext+0x90>
    1312:	21 50       	subi	r18, 0x01	; 1
    1314:	82 2f       	mov	r24, r18
    1316:	90 e0       	ldi	r25, 0x00	; 0
    1318:	fc 01       	movw	r30, r24
    131a:	ee 0f       	add	r30, r30
    131c:	ff 1f       	adc	r31, r31
    131e:	ee 0f       	add	r30, r30
    1320:	ff 1f       	adc	r31, r31
    1322:	ee 0f       	add	r30, r30
    1324:	ff 1f       	adc	r31, r31
    1326:	e8 0f       	add	r30, r24
    1328:	f9 1f       	adc	r31, r25
    132a:	e6 59       	subi	r30, 0x96	; 150
    132c:	fe 4f       	sbci	r31, 0xFE	; 254
    132e:	30 81       	ld	r19, Z
    1330:	33 23       	and	r19, r19
    1332:	79 f3       	breq	.-34     	; 0x1312 <vTaskSwitchContext+0x6e>
    1334:	ac 01       	movw	r20, r24
    1336:	44 0f       	add	r20, r20
    1338:	55 1f       	adc	r21, r21
    133a:	44 0f       	add	r20, r20
    133c:	55 1f       	adc	r21, r21
    133e:	44 0f       	add	r20, r20
    1340:	55 1f       	adc	r21, r21
    1342:	48 0f       	add	r20, r24
    1344:	59 1f       	adc	r21, r25
    1346:	da 01       	movw	r26, r20
    1348:	a6 59       	subi	r26, 0x96	; 150
    134a:	be 4f       	sbci	r27, 0xFE	; 254
    134c:	11 96       	adiw	r26, 0x01	; 1
    134e:	ed 91       	ld	r30, X+
    1350:	fc 91       	ld	r31, X
    1352:	12 97       	sbiw	r26, 0x02	; 2
    1354:	02 80       	ldd	r0, Z+2	; 0x02
    1356:	f3 81       	ldd	r31, Z+3	; 0x03
    1358:	e0 2d       	mov	r30, r0
    135a:	12 96       	adiw	r26, 0x02	; 2
    135c:	fc 93       	st	X, r31
    135e:	ee 93       	st	-X, r30
    1360:	11 97       	sbiw	r26, 0x01	; 1
    1362:	43 59       	subi	r20, 0x93	; 147
    1364:	5e 4f       	sbci	r21, 0xFE	; 254
    1366:	e4 17       	cp	r30, r20
    1368:	f5 07       	cpc	r31, r21
    136a:	29 f4       	brne	.+10     	; 0x1376 <vTaskSwitchContext+0xd2>
    136c:	42 81       	ldd	r20, Z+2	; 0x02
    136e:	53 81       	ldd	r21, Z+3	; 0x03
    1370:	fd 01       	movw	r30, r26
    1372:	52 83       	std	Z+2, r21	; 0x02
    1374:	41 83       	std	Z+1, r20	; 0x01
    1376:	fc 01       	movw	r30, r24
    1378:	ee 0f       	add	r30, r30
    137a:	ff 1f       	adc	r31, r31
    137c:	ee 0f       	add	r30, r30
    137e:	ff 1f       	adc	r31, r31
    1380:	ee 0f       	add	r30, r30
    1382:	ff 1f       	adc	r31, r31
    1384:	8e 0f       	add	r24, r30
    1386:	9f 1f       	adc	r25, r31
    1388:	fc 01       	movw	r30, r24
    138a:	e6 59       	subi	r30, 0x96	; 150
    138c:	fe 4f       	sbci	r31, 0xFE	; 254
    138e:	01 80       	ldd	r0, Z+1	; 0x01
    1390:	f2 81       	ldd	r31, Z+2	; 0x02
    1392:	e0 2d       	mov	r30, r0
    1394:	86 81       	ldd	r24, Z+6	; 0x06
    1396:	97 81       	ldd	r25, Z+7	; 0x07
    1398:	90 93 8f 01 	sts	0x018F, r25	; 0x80018f <pxCurrentTCB+0x1>
    139c:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <pxCurrentTCB>
    13a0:	20 93 34 01 	sts	0x0134, r18	; 0x800134 <uxTopReadyPriority>
    13a4:	08 95       	ret

000013a6 <vTaskSuspend>:
    13a6:	0f 93       	push	r16
    13a8:	1f 93       	push	r17
    13aa:	cf 93       	push	r28
    13ac:	df 93       	push	r29
    13ae:	ec 01       	movw	r28, r24
    13b0:	0f b6       	in	r0, 0x3f	; 63
    13b2:	f8 94       	cli
    13b4:	0f 92       	push	r0
    13b6:	89 2b       	or	r24, r25
    13b8:	21 f4       	brne	.+8      	; 0x13c2 <vTaskSuspend+0x1c>
    13ba:	c0 91 8e 01 	lds	r28, 0x018E	; 0x80018e <pxCurrentTCB>
    13be:	d0 91 8f 01 	lds	r29, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    13c2:	8e 01       	movw	r16, r28
    13c4:	0e 5f       	subi	r16, 0xFE	; 254
    13c6:	1f 4f       	sbci	r17, 0xFF	; 255
    13c8:	c8 01       	movw	r24, r16
    13ca:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    13ce:	8c 89       	ldd	r24, Y+20	; 0x14
    13d0:	9d 89       	ldd	r25, Y+21	; 0x15
    13d2:	89 2b       	or	r24, r25
    13d4:	21 f0       	breq	.+8      	; 0x13de <vTaskSuspend+0x38>
    13d6:	ce 01       	movw	r24, r28
    13d8:	0c 96       	adiw	r24, 0x0c	; 12
    13da:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    13de:	b8 01       	movw	r22, r16
    13e0:	88 e3       	ldi	r24, 0x38	; 56
    13e2:	91 e0       	ldi	r25, 0x01	; 1
    13e4:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    13e8:	8f a1       	ldd	r24, Y+39	; 0x27
    13ea:	81 30       	cpi	r24, 0x01	; 1
    13ec:	09 f4       	brne	.+2      	; 0x13f0 <vTaskSuspend+0x4a>
    13ee:	1f a2       	std	Y+39, r1	; 0x27
    13f0:	0f 90       	pop	r0
    13f2:	0f be       	out	0x3f, r0	; 63
    13f4:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xSchedulerRunning>
    13f8:	88 23       	and	r24, r24
    13fa:	39 f0       	breq	.+14     	; 0x140a <vTaskSuspend+0x64>
    13fc:	0f b6       	in	r0, 0x3f	; 63
    13fe:	f8 94       	cli
    1400:	0f 92       	push	r0
    1402:	0e 94 c7 05 	call	0xb8e	; 0xb8e <prvResetNextTaskUnblockTime>
    1406:	0f 90       	pop	r0
    1408:	0f be       	out	0x3f, r0	; 63
    140a:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <pxCurrentTCB>
    140e:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    1412:	c8 17       	cp	r28, r24
    1414:	d9 07       	cpc	r29, r25
    1416:	a1 f4       	brne	.+40     	; 0x1440 <vTaskSuspend+0x9a>
    1418:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xSchedulerRunning>
    141c:	88 23       	and	r24, r24
    141e:	19 f0       	breq	.+6      	; 0x1426 <vTaskSuspend+0x80>
    1420:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
    1424:	0d c0       	rjmp	.+26     	; 0x1440 <vTaskSuspend+0x9a>
    1426:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <xSuspendedTaskList>
    142a:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <uxCurrentNumberOfTasks>
    142e:	98 13       	cpse	r25, r24
    1430:	05 c0       	rjmp	.+10     	; 0x143c <vTaskSuspend+0x96>
    1432:	10 92 8f 01 	sts	0x018F, r1	; 0x80018f <pxCurrentTCB+0x1>
    1436:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <pxCurrentTCB>
    143a:	02 c0       	rjmp	.+4      	; 0x1440 <vTaskSuspend+0x9a>
    143c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vTaskSwitchContext>
    1440:	df 91       	pop	r29
    1442:	cf 91       	pop	r28
    1444:	1f 91       	pop	r17
    1446:	0f 91       	pop	r16
    1448:	08 95       	ret

0000144a <vTaskPlaceOnEventList>:
    144a:	cf 93       	push	r28
    144c:	df 93       	push	r29
    144e:	eb 01       	movw	r28, r22
    1450:	60 91 8e 01 	lds	r22, 0x018E	; 0x80018e <pxCurrentTCB>
    1454:	70 91 8f 01 	lds	r23, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    1458:	64 5f       	subi	r22, 0xF4	; 244
    145a:	7f 4f       	sbci	r23, 0xFF	; 255
    145c:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    1460:	61 e0       	ldi	r22, 0x01	; 1
    1462:	ce 01       	movw	r24, r28
    1464:	0e 94 e6 05 	call	0xbcc	; 0xbcc <prvAddCurrentTaskToDelayedList>
    1468:	df 91       	pop	r29
    146a:	cf 91       	pop	r28
    146c:	08 95       	ret

0000146e <vTaskPlaceOnEventListRestricted>:
    146e:	0f 93       	push	r16
    1470:	1f 93       	push	r17
    1472:	cf 93       	push	r28
    1474:	8b 01       	movw	r16, r22
    1476:	c4 2f       	mov	r28, r20
    1478:	60 91 8e 01 	lds	r22, 0x018E	; 0x80018e <pxCurrentTCB>
    147c:	70 91 8f 01 	lds	r23, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    1480:	64 5f       	subi	r22, 0xF4	; 244
    1482:	7f 4f       	sbci	r23, 0xFF	; 255
    1484:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1488:	cc 23       	and	r28, r28
    148a:	11 f0       	breq	.+4      	; 0x1490 <vTaskPlaceOnEventListRestricted+0x22>
    148c:	0f ef       	ldi	r16, 0xFF	; 255
    148e:	1f ef       	ldi	r17, 0xFF	; 255
    1490:	6c 2f       	mov	r22, r28
    1492:	c8 01       	movw	r24, r16
    1494:	0e 94 e6 05 	call	0xbcc	; 0xbcc <prvAddCurrentTaskToDelayedList>
    1498:	cf 91       	pop	r28
    149a:	1f 91       	pop	r17
    149c:	0f 91       	pop	r16
    149e:	08 95       	ret

000014a0 <xTaskRemoveFromEventList>:
    14a0:	0f 93       	push	r16
    14a2:	1f 93       	push	r17
    14a4:	cf 93       	push	r28
    14a6:	df 93       	push	r29
    14a8:	dc 01       	movw	r26, r24
    14aa:	15 96       	adiw	r26, 0x05	; 5
    14ac:	ed 91       	ld	r30, X+
    14ae:	fc 91       	ld	r31, X
    14b0:	16 97       	sbiw	r26, 0x06	; 6
    14b2:	c6 81       	ldd	r28, Z+6	; 0x06
    14b4:	d7 81       	ldd	r29, Z+7	; 0x07
    14b6:	8e 01       	movw	r16, r28
    14b8:	04 5f       	subi	r16, 0xF4	; 244
    14ba:	1f 4f       	sbci	r17, 0xFF	; 255
    14bc:	c8 01       	movw	r24, r16
    14be:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    14c2:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <uxSchedulerSuspended>
    14c6:	81 11       	cpse	r24, r1
    14c8:	1c c0       	rjmp	.+56     	; 0x1502 <xTaskRemoveFromEventList+0x62>
    14ca:	0a 50       	subi	r16, 0x0A	; 10
    14cc:	11 09       	sbc	r17, r1
    14ce:	c8 01       	movw	r24, r16
    14d0:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    14d4:	8e 89       	ldd	r24, Y+22	; 0x16
    14d6:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <uxTopReadyPriority>
    14da:	98 17       	cp	r25, r24
    14dc:	10 f4       	brcc	.+4      	; 0x14e2 <xTaskRemoveFromEventList+0x42>
    14de:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxTopReadyPriority>
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	9c 01       	movw	r18, r24
    14e6:	22 0f       	add	r18, r18
    14e8:	33 1f       	adc	r19, r19
    14ea:	22 0f       	add	r18, r18
    14ec:	33 1f       	adc	r19, r19
    14ee:	22 0f       	add	r18, r18
    14f0:	33 1f       	adc	r19, r19
    14f2:	82 0f       	add	r24, r18
    14f4:	93 1f       	adc	r25, r19
    14f6:	b8 01       	movw	r22, r16
    14f8:	86 59       	subi	r24, 0x96	; 150
    14fa:	9e 4f       	sbci	r25, 0xFE	; 254
    14fc:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1500:	05 c0       	rjmp	.+10     	; 0x150c <xTaskRemoveFromEventList+0x6c>
    1502:	b8 01       	movw	r22, r16
    1504:	8b e4       	ldi	r24, 0x4B	; 75
    1506:	91 e0       	ldi	r25, 0x01	; 1
    1508:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    150c:	e0 91 8e 01 	lds	r30, 0x018E	; 0x80018e <pxCurrentTCB>
    1510:	f0 91 8f 01 	lds	r31, 0x018F	; 0x80018f <pxCurrentTCB+0x1>
    1514:	9e 89       	ldd	r25, Y+22	; 0x16
    1516:	86 89       	ldd	r24, Z+22	; 0x16
    1518:	89 17       	cp	r24, r25
    151a:	20 f4       	brcc	.+8      	; 0x1524 <xTaskRemoveFromEventList+0x84>
    151c:	81 e0       	ldi	r24, 0x01	; 1
    151e:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <xYieldPending>
    1522:	01 c0       	rjmp	.+2      	; 0x1526 <xTaskRemoveFromEventList+0x86>
    1524:	80 e0       	ldi	r24, 0x00	; 0
    1526:	df 91       	pop	r29
    1528:	cf 91       	pop	r28
    152a:	1f 91       	pop	r17
    152c:	0f 91       	pop	r16
    152e:	08 95       	ret

00001530 <vTaskInternalSetTimeOutState>:
    1530:	20 91 2f 01 	lds	r18, 0x012F	; 0x80012f <xNumOfOverflows>
    1534:	fc 01       	movw	r30, r24
    1536:	20 83       	st	Z, r18
    1538:	20 91 35 01 	lds	r18, 0x0135	; 0x800135 <xTickCount>
    153c:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <xTickCount+0x1>
    1540:	32 83       	std	Z+2, r19	; 0x02
    1542:	21 83       	std	Z+1, r18	; 0x01
    1544:	08 95       	ret

00001546 <xTaskCheckForTimeOut>:
    1546:	cf 93       	push	r28
    1548:	df 93       	push	r29
    154a:	0f b6       	in	r0, 0x3f	; 63
    154c:	f8 94       	cli
    154e:	0f 92       	push	r0
    1550:	20 91 35 01 	lds	r18, 0x0135	; 0x800135 <xTickCount>
    1554:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <xTickCount+0x1>
    1558:	db 01       	movw	r26, r22
    155a:	4d 91       	ld	r20, X+
    155c:	5c 91       	ld	r21, X
    155e:	4f 3f       	cpi	r20, 0xFF	; 255
    1560:	bf ef       	ldi	r27, 0xFF	; 255
    1562:	5b 07       	cpc	r21, r27
    1564:	f1 f0       	breq	.+60     	; 0x15a2 <xTaskCheckForTimeOut+0x5c>
    1566:	ec 01       	movw	r28, r24
    1568:	e9 81       	ldd	r30, Y+1	; 0x01
    156a:	fa 81       	ldd	r31, Y+2	; 0x02
    156c:	a0 91 2f 01 	lds	r26, 0x012F	; 0x80012f <xNumOfOverflows>
    1570:	b8 81       	ld	r27, Y
    1572:	ba 17       	cp	r27, r26
    1574:	19 f0       	breq	.+6      	; 0x157c <xTaskCheckForTimeOut+0x36>
    1576:	2e 17       	cp	r18, r30
    1578:	3f 07       	cpc	r19, r31
    157a:	a8 f4       	brcc	.+42     	; 0x15a6 <xTaskCheckForTimeOut+0x60>
    157c:	2e 1b       	sub	r18, r30
    157e:	3f 0b       	sbc	r19, r31
    1580:	24 17       	cp	r18, r20
    1582:	35 07       	cpc	r19, r21
    1584:	48 f4       	brcc	.+18     	; 0x1598 <xTaskCheckForTimeOut+0x52>
    1586:	fb 01       	movw	r30, r22
    1588:	42 1b       	sub	r20, r18
    158a:	53 0b       	sbc	r21, r19
    158c:	51 83       	std	Z+1, r21	; 0x01
    158e:	40 83       	st	Z, r20
    1590:	0e 94 98 0a 	call	0x1530	; 0x1530 <vTaskInternalSetTimeOutState>
    1594:	80 e0       	ldi	r24, 0x00	; 0
    1596:	08 c0       	rjmp	.+16     	; 0x15a8 <xTaskCheckForTimeOut+0x62>
    1598:	fb 01       	movw	r30, r22
    159a:	11 82       	std	Z+1, r1	; 0x01
    159c:	10 82       	st	Z, r1
    159e:	81 e0       	ldi	r24, 0x01	; 1
    15a0:	03 c0       	rjmp	.+6      	; 0x15a8 <xTaskCheckForTimeOut+0x62>
    15a2:	80 e0       	ldi	r24, 0x00	; 0
    15a4:	01 c0       	rjmp	.+2      	; 0x15a8 <xTaskCheckForTimeOut+0x62>
    15a6:	81 e0       	ldi	r24, 0x01	; 1
    15a8:	0f 90       	pop	r0
    15aa:	0f be       	out	0x3f, r0	; 63
    15ac:	df 91       	pop	r29
    15ae:	cf 91       	pop	r28
    15b0:	08 95       	ret

000015b2 <vTaskMissedYield>:
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <xYieldPending>
    15b8:	08 95       	ret

000015ba <xTaskGetSchedulerState>:
    15ba:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xSchedulerRunning>
    15be:	88 23       	and	r24, r24
    15c0:	31 f0       	breq	.+12     	; 0x15ce <xTaskGetSchedulerState+0x14>
    15c2:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <uxSchedulerSuspended>
    15c6:	88 23       	and	r24, r24
    15c8:	21 f0       	breq	.+8      	; 0x15d2 <xTaskGetSchedulerState+0x18>
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	08 95       	ret
    15ce:	81 e0       	ldi	r24, 0x01	; 1
    15d0:	08 95       	ret
    15d2:	82 e0       	ldi	r24, 0x02	; 2
    15d4:	08 95       	ret

000015d6 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    15d6:	0f 93       	push	r16
    15d8:	1f 93       	push	r17
    15da:	cf 93       	push	r28
    15dc:	df 93       	push	r29
    15de:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    15e0:	89 2b       	or	r24, r25
    15e2:	79 f1       	breq	.+94     	; 0x1642 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    15e4:	82 a1       	ldd	r24, Z+34	; 0x22
    15e6:	81 50       	subi	r24, 0x01	; 1
    15e8:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    15ea:	26 89       	ldd	r18, Z+22	; 0x16
    15ec:	91 a1       	ldd	r25, Z+33	; 0x21
    15ee:	29 17       	cp	r18, r25
    15f0:	51 f1       	breq	.+84     	; 0x1646 <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    15f2:	81 11       	cpse	r24, r1
    15f4:	2a c0       	rjmp	.+84     	; 0x164a <xTaskPriorityDisinherit+0x74>
    15f6:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready/delayed list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    15f8:	8f 01       	movw	r16, r30
    15fa:	0e 5f       	subi	r16, 0xFE	; 254
    15fc:	1f 4f       	sbci	r17, 0xFF	; 255
    15fe:	c8 01       	movw	r24, r16
    1600:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    1604:	89 a1       	ldd	r24, Y+33	; 0x21
    1606:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1608:	24 e0       	ldi	r18, 0x04	; 4
    160a:	30 e0       	ldi	r19, 0x00	; 0
    160c:	28 1b       	sub	r18, r24
    160e:	31 09       	sbc	r19, r1
    1610:	3d 87       	std	Y+13, r19	; 0x0d
    1612:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    1614:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <uxTopReadyPriority>
    1618:	98 17       	cp	r25, r24
    161a:	10 f4       	brcc	.+4      	; 0x1620 <xTaskPriorityDisinherit+0x4a>
    161c:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxTopReadyPriority>
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	9c 01       	movw	r18, r24
    1624:	22 0f       	add	r18, r18
    1626:	33 1f       	adc	r19, r19
    1628:	22 0f       	add	r18, r18
    162a:	33 1f       	adc	r19, r19
    162c:	22 0f       	add	r18, r18
    162e:	33 1f       	adc	r19, r19
    1630:	82 0f       	add	r24, r18
    1632:	93 1f       	adc	r25, r19
    1634:	b8 01       	movw	r22, r16
    1636:	86 59       	subi	r24, 0x96	; 150
    1638:	9e 4f       	sbci	r25, 0xFE	; 254
    163a:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    163e:	81 e0       	ldi	r24, 0x01	; 1
    1640:	05 c0       	rjmp	.+10     	; 0x164c <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    1642:	80 e0       	ldi	r24, 0x00	; 0
    1644:	03 c0       	rjmp	.+6      	; 0x164c <xTaskPriorityDisinherit+0x76>
    1646:	80 e0       	ldi	r24, 0x00	; 0
    1648:	01 c0       	rjmp	.+2      	; 0x164c <xTaskPriorityDisinherit+0x76>
    164a:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    164c:	df 91       	pop	r29
    164e:	cf 91       	pop	r28
    1650:	1f 91       	pop	r17
    1652:	0f 91       	pop	r16
    1654:	08 95       	ret

00001656 <prvInsertTimerInActiveList>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    1656:	fc 01       	movw	r30, r24
    1658:	73 83       	std	Z+3, r23	; 0x03
    165a:	62 83       	std	Z+2, r22	; 0x02
    165c:	91 87       	std	Z+9, r25	; 0x09
    165e:	80 87       	std	Z+8, r24	; 0x08
    1660:	46 17       	cp	r20, r22
    1662:	57 07       	cpc	r21, r23
    1664:	90 f0       	brcs	.+36     	; 0x168a <prvInsertTimerInActiveList+0x34>
    1666:	42 1b       	sub	r20, r18
    1668:	53 0b       	sbc	r21, r19
    166a:	84 85       	ldd	r24, Z+12	; 0x0c
    166c:	95 85       	ldd	r25, Z+13	; 0x0d
    166e:	48 17       	cp	r20, r24
    1670:	59 07       	cpc	r21, r25
    1672:	e0 f4       	brcc	.+56     	; 0x16ac <prvInsertTimerInActiveList+0x56>
    1674:	bf 01       	movw	r22, r30
    1676:	6e 5f       	subi	r22, 0xFE	; 254
    1678:	7f 4f       	sbci	r23, 0xFF	; 255
    167a:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <pxOverflowTimerList>
    167e:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <pxOverflowTimerList+0x1>
    1682:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    1686:	80 e0       	ldi	r24, 0x00	; 0
    1688:	08 95       	ret
    168a:	42 17       	cp	r20, r18
    168c:	53 07       	cpc	r21, r19
    168e:	18 f4       	brcc	.+6      	; 0x1696 <prvInsertTimerInActiveList+0x40>
    1690:	62 17       	cp	r22, r18
    1692:	73 07       	cpc	r23, r19
    1694:	68 f4       	brcc	.+26     	; 0x16b0 <prvInsertTimerInActiveList+0x5a>
    1696:	bf 01       	movw	r22, r30
    1698:	6e 5f       	subi	r22, 0xFE	; 254
    169a:	7f 4f       	sbci	r23, 0xFF	; 255
    169c:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <pxCurrentTimerList>
    16a0:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <pxCurrentTimerList+0x1>
    16a4:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    16a8:	80 e0       	ldi	r24, 0x00	; 0
    16aa:	08 95       	ret
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	08 95       	ret
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	08 95       	ret

000016b4 <prvCheckForValidListAndQueue>:
    16b4:	0f b6       	in	r0, 0x3f	; 63
    16b6:	f8 94       	cli
    16b8:	0f 92       	push	r0
    16ba:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <xTimerQueue>
    16be:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <xTimerQueue+0x1>
    16c2:	89 2b       	or	r24, r25
    16c4:	e9 f4       	brne	.+58     	; 0x1700 <prvCheckForValidListAndQueue+0x4c>
    16c6:	83 ea       	ldi	r24, 0xA3	; 163
    16c8:	91 e0       	ldi	r25, 0x01	; 1
    16ca:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
    16ce:	8a e9       	ldi	r24, 0x9A	; 154
    16d0:	91 e0       	ldi	r25, 0x01	; 1
    16d2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
    16d6:	83 ea       	ldi	r24, 0xA3	; 163
    16d8:	91 e0       	ldi	r25, 0x01	; 1
    16da:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxCurrentTimerList+0x1>
    16de:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxCurrentTimerList>
    16e2:	8a e9       	ldi	r24, 0x9A	; 154
    16e4:	91 e0       	ldi	r25, 0x01	; 1
    16e6:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <pxOverflowTimerList+0x1>
    16ea:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <pxOverflowTimerList>
    16ee:	40 e0       	ldi	r20, 0x00	; 0
    16f0:	65 e0       	ldi	r22, 0x05	; 5
    16f2:	8a e0       	ldi	r24, 0x0A	; 10
    16f4:	0e 94 11 04 	call	0x822	; 0x822 <xQueueGenericCreate>
    16f8:	90 93 95 01 	sts	0x0195, r25	; 0x800195 <xTimerQueue+0x1>
    16fc:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <xTimerQueue>
    1700:	0f 90       	pop	r0
    1702:	0f be       	out	0x3f, r0	; 63
    1704:	08 95       	ret

00001706 <xTimerCreateTimerTask>:
    1706:	ef 92       	push	r14
    1708:	ff 92       	push	r15
    170a:	0f 93       	push	r16
    170c:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <prvCheckForValidListAndQueue>
    1710:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <xTimerQueue>
    1714:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <xTimerQueue+0x1>
    1718:	89 2b       	or	r24, r25
    171a:	91 f0       	breq	.+36     	; 0x1740 <xTimerCreateTimerTask+0x3a>
    171c:	0f 2e       	mov	r0, r31
    171e:	f2 e9       	ldi	r31, 0x92	; 146
    1720:	ef 2e       	mov	r14, r31
    1722:	f1 e0       	ldi	r31, 0x01	; 1
    1724:	ff 2e       	mov	r15, r31
    1726:	f0 2d       	mov	r31, r0
    1728:	03 e0       	ldi	r16, 0x03	; 3
    172a:	20 e0       	ldi	r18, 0x00	; 0
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	45 e5       	ldi	r20, 0x55	; 85
    1730:	50 e0       	ldi	r21, 0x00	; 0
    1732:	6b e1       	ldi	r22, 0x1B	; 27
    1734:	71 e0       	ldi	r23, 0x01	; 1
    1736:	8d e5       	ldi	r24, 0x5D	; 93
    1738:	9c e0       	ldi	r25, 0x0C	; 12
    173a:	0e 94 78 06 	call	0xcf0	; 0xcf0 <xTaskCreate>
    173e:	01 c0       	rjmp	.+2      	; 0x1742 <xTimerCreateTimerTask+0x3c>
    1740:	80 e0       	ldi	r24, 0x00	; 0
    1742:	0f 91       	pop	r16
    1744:	ff 90       	pop	r15
    1746:	ef 90       	pop	r14
    1748:	08 95       	ret

0000174a <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    174a:	0f 93       	push	r16
    174c:	1f 93       	push	r17
    174e:	cf 93       	push	r28
    1750:	df 93       	push	r29
    1752:	00 d0       	rcall	.+0      	; 0x1754 <xTimerGenericCommand+0xa>
    1754:	00 d0       	rcall	.+0      	; 0x1756 <xTimerGenericCommand+0xc>
    1756:	1f 92       	push	r1
    1758:	cd b7       	in	r28, 0x3d	; 61
    175a:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    175c:	e0 91 94 01 	lds	r30, 0x0194	; 0x800194 <xTimerQueue>
    1760:	f0 91 95 01 	lds	r31, 0x0195	; 0x800195 <xTimerQueue+0x1>
    1764:	30 97       	sbiw	r30, 0x00	; 0
    1766:	71 f1       	breq	.+92     	; 0x17c4 <xTimerGenericCommand+0x7a>
    1768:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    176a:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    176c:	5b 83       	std	Y+3, r21	; 0x03
    176e:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    1770:	9d 83       	std	Y+5, r25	; 0x05
    1772:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1774:	66 30       	cpi	r22, 0x06	; 6
    1776:	ec f4       	brge	.+58     	; 0x17b2 <xTimerGenericCommand+0x68>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1778:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <xTaskGetSchedulerState>
    177c:	82 30       	cpi	r24, 0x02	; 2
    177e:	61 f4       	brne	.+24     	; 0x1798 <xTimerGenericCommand+0x4e>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1780:	20 e0       	ldi	r18, 0x00	; 0
    1782:	a8 01       	movw	r20, r16
    1784:	be 01       	movw	r22, r28
    1786:	6f 5f       	subi	r22, 0xFF	; 255
    1788:	7f 4f       	sbci	r23, 0xFF	; 255
    178a:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <xTimerQueue>
    178e:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <xTimerQueue+0x1>
    1792:	0e 94 34 04 	call	0x868	; 0x868 <xQueueGenericSend>
    1796:	17 c0       	rjmp	.+46     	; 0x17c6 <xTimerGenericCommand+0x7c>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1798:	20 e0       	ldi	r18, 0x00	; 0
    179a:	40 e0       	ldi	r20, 0x00	; 0
    179c:	50 e0       	ldi	r21, 0x00	; 0
    179e:	be 01       	movw	r22, r28
    17a0:	6f 5f       	subi	r22, 0xFF	; 255
    17a2:	7f 4f       	sbci	r23, 0xFF	; 255
    17a4:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <xTimerQueue>
    17a8:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <xTimerQueue+0x1>
    17ac:	0e 94 34 04 	call	0x868	; 0x868 <xQueueGenericSend>
    17b0:	0a c0       	rjmp	.+20     	; 0x17c6 <xTimerGenericCommand+0x7c>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    17b2:	20 e0       	ldi	r18, 0x00	; 0
    17b4:	ad 01       	movw	r20, r26
    17b6:	be 01       	movw	r22, r28
    17b8:	6f 5f       	subi	r22, 0xFF	; 255
    17ba:	7f 4f       	sbci	r23, 0xFF	; 255
    17bc:	cf 01       	movw	r24, r30
    17be:	0e 94 d5 04 	call	0x9aa	; 0x9aa <xQueueGenericSendFromISR>
    17c2:	01 c0       	rjmp	.+2      	; 0x17c6 <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    17c4:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    17c6:	0f 90       	pop	r0
    17c8:	0f 90       	pop	r0
    17ca:	0f 90       	pop	r0
    17cc:	0f 90       	pop	r0
    17ce:	0f 90       	pop	r0
    17d0:	df 91       	pop	r29
    17d2:	cf 91       	pop	r28
    17d4:	1f 91       	pop	r17
    17d6:	0f 91       	pop	r16
    17d8:	08 95       	ret

000017da <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    17da:	af 92       	push	r10
    17dc:	bf 92       	push	r11
    17de:	cf 92       	push	r12
    17e0:	df 92       	push	r13
    17e2:	ef 92       	push	r14
    17e4:	ff 92       	push	r15
    17e6:	0f 93       	push	r16
    17e8:	1f 93       	push	r17
    17ea:	cf 93       	push	r28
    17ec:	df 93       	push	r29
    17ee:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    17f0:	0e 94 c8 07 	call	0xf90	; 0xf90 <xTaskGetTickCount>
    17f4:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    17f6:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <xLastTime.2416>
    17fa:	90 91 91 01 	lds	r25, 0x0191	; 0x800191 <xLastTime.2416+0x1>
    17fe:	e8 16       	cp	r14, r24
    1800:	f9 06       	cpc	r15, r25
    1802:	08 f0       	brcs	.+2      	; 0x1806 <prvSampleTimeNow+0x2c>
    1804:	48 c0       	rjmp	.+144    	; 0x1896 <prvSampleTimeNow+0xbc>
    1806:	30 c0       	rjmp	.+96     	; 0x1868 <prvSampleTimeNow+0x8e>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1808:	05 80       	ldd	r0, Z+5	; 0x05
    180a:	f6 81       	ldd	r31, Z+6	; 0x06
    180c:	e0 2d       	mov	r30, r0
    180e:	a0 80       	ld	r10, Z
    1810:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1812:	c6 81       	ldd	r28, Z+6	; 0x06
    1814:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1816:	8e 01       	movw	r16, r28
    1818:	0e 5f       	subi	r16, 0xFE	; 254
    181a:	1f 4f       	sbci	r17, 0xFF	; 255
    181c:	c8 01       	movw	r24, r16
    181e:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1822:	e8 89       	ldd	r30, Y+16	; 0x10
    1824:	f9 89       	ldd	r31, Y+17	; 0x11
    1826:	ce 01       	movw	r24, r28
    1828:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    182a:	8a 89       	ldd	r24, Y+18	; 0x12
    182c:	82 ff       	sbrs	r24, 2
    182e:	1c c0       	rjmp	.+56     	; 0x1868 <prvSampleTimeNow+0x8e>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1830:	8c 85       	ldd	r24, Y+12	; 0x0c
    1832:	9d 85       	ldd	r25, Y+13	; 0x0d
    1834:	8a 0d       	add	r24, r10
    1836:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    1838:	a8 16       	cp	r10, r24
    183a:	b9 06       	cpc	r11, r25
    183c:	60 f4       	brcc	.+24     	; 0x1856 <prvSampleTimeNow+0x7c>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    183e:	9b 83       	std	Y+3, r25	; 0x03
    1840:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1842:	d9 87       	std	Y+9, r29	; 0x09
    1844:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1846:	b8 01       	movw	r22, r16
    1848:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <pxCurrentTimerList>
    184c:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <pxCurrentTimerList+0x1>
    1850:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    1854:	09 c0       	rjmp	.+18     	; 0x1868 <prvSampleTimeNow+0x8e>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1856:	00 e0       	ldi	r16, 0x00	; 0
    1858:	10 e0       	ldi	r17, 0x00	; 0
    185a:	20 e0       	ldi	r18, 0x00	; 0
    185c:	30 e0       	ldi	r19, 0x00	; 0
    185e:	a5 01       	movw	r20, r10
    1860:	60 e0       	ldi	r22, 0x00	; 0
    1862:	ce 01       	movw	r24, r28
    1864:	0e 94 a5 0b 	call	0x174a	; 0x174a <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1868:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <pxCurrentTimerList>
    186c:	f0 91 99 01 	lds	r31, 0x0199	; 0x800199 <pxCurrentTimerList+0x1>
    1870:	80 81       	ld	r24, Z
    1872:	81 11       	cpse	r24, r1
    1874:	c9 cf       	rjmp	.-110    	; 0x1808 <prvSampleTimeNow+0x2e>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    1876:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <pxOverflowTimerList>
    187a:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <pxOverflowTimerList+0x1>
    187e:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxCurrentTimerList+0x1>
    1882:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    1886:	f0 93 97 01 	sts	0x0197, r31	; 0x800197 <pxOverflowTimerList+0x1>
    188a:	e0 93 96 01 	sts	0x0196, r30	; 0x800196 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    188e:	81 e0       	ldi	r24, 0x01	; 1
    1890:	f6 01       	movw	r30, r12
    1892:	80 83       	st	Z, r24
    1894:	02 c0       	rjmp	.+4      	; 0x189a <prvSampleTimeNow+0xc0>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    1896:	f6 01       	movw	r30, r12
    1898:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    189a:	f0 92 91 01 	sts	0x0191, r15	; 0x800191 <xLastTime.2416+0x1>
    189e:	e0 92 90 01 	sts	0x0190, r14	; 0x800190 <xLastTime.2416>

    return xTimeNow;
}
    18a2:	c7 01       	movw	r24, r14
    18a4:	df 91       	pop	r29
    18a6:	cf 91       	pop	r28
    18a8:	1f 91       	pop	r17
    18aa:	0f 91       	pop	r16
    18ac:	ff 90       	pop	r15
    18ae:	ef 90       	pop	r14
    18b0:	df 90       	pop	r13
    18b2:	cf 90       	pop	r12
    18b4:	bf 90       	pop	r11
    18b6:	af 90       	pop	r10
    18b8:	08 95       	ret

000018ba <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    18ba:	cf 93       	push	r28
    18bc:	df 93       	push	r29
    18be:	00 d0       	rcall	.+0      	; 0x18c0 <prvTimerTask+0x6>
    18c0:	00 d0       	rcall	.+0      	; 0x18c2 <prvTimerTask+0x8>
    18c2:	00 d0       	rcall	.+0      	; 0x18c4 <prvTimerTask+0xa>
    18c4:	cd b7       	in	r28, 0x3d	; 61
    18c6:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    18c8:	ce 01       	movw	r24, r28
    18ca:	01 96       	adiw	r24, 0x01	; 1
    18cc:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    18ce:	44 24       	eor	r4, r4
    18d0:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    18d2:	e1 2c       	mov	r14, r1
    18d4:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    18d6:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    18d8:	c8 2e       	mov	r12, r24
    18da:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    18dc:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <pxCurrentTimerList>
    18e0:	f0 91 99 01 	lds	r31, 0x0199	; 0x800199 <pxCurrentTimerList+0x1>
    18e4:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    18e6:	88 23       	and	r24, r24
    18e8:	09 f4       	brne	.+2      	; 0x18ec <prvTimerTask+0x32>
    18ea:	dc c0       	rjmp	.+440    	; 0x1aa4 <prvTimerTask+0x1ea>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    18ec:	05 80       	ldd	r0, Z+5	; 0x05
    18ee:	f6 81       	ldd	r31, Z+6	; 0x06
    18f0:	e0 2d       	mov	r30, r0
    18f2:	a0 80       	ld	r10, Z
    18f4:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    18f6:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    18fa:	c4 01       	movw	r24, r8
    18fc:	0e 94 ed 0b 	call	0x17da	; 0x17da <prvSampleTimeNow>
    1900:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    1902:	89 81       	ldd	r24, Y+1	; 0x01
    1904:	81 11       	cpse	r24, r1
    1906:	4b c0       	rjmp	.+150    	; 0x199e <prvTimerTask+0xe4>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1908:	0a 15       	cp	r16, r10
    190a:	1b 05       	cpc	r17, r11
    190c:	b8 f1       	brcs	.+110    	; 0x197c <prvTimerTask+0xc2>
            {
                ( void ) xTaskResumeAll();
    190e:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1912:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <pxCurrentTimerList>
    1916:	f0 91 99 01 	lds	r31, 0x0199	; 0x800199 <pxCurrentTimerList+0x1>
    191a:	05 80       	ldd	r0, Z+5	; 0x05
    191c:	f6 81       	ldd	r31, Z+6	; 0x06
    191e:	e0 2d       	mov	r30, r0
    1920:	66 80       	ldd	r6, Z+6	; 0x06
    1922:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1924:	c3 01       	movw	r24, r6
    1926:	02 96       	adiw	r24, 0x02	; 2
    1928:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto-reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    192c:	d3 01       	movw	r26, r6
    192e:	52 96       	adiw	r26, 0x12	; 18
    1930:	8c 91       	ld	r24, X
    1932:	52 97       	sbiw	r26, 0x12	; 18
    1934:	82 ff       	sbrs	r24, 2
    1936:	17 c0       	rjmp	.+46     	; 0x1966 <prvTimerTask+0xac>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1938:	1c 96       	adiw	r26, 0x0c	; 12
    193a:	6d 91       	ld	r22, X+
    193c:	7c 91       	ld	r23, X
    193e:	1d 97       	sbiw	r26, 0x0d	; 13
    1940:	6a 0d       	add	r22, r10
    1942:	7b 1d       	adc	r23, r11
    1944:	95 01       	movw	r18, r10
    1946:	a8 01       	movw	r20, r16
    1948:	c3 01       	movw	r24, r6
    194a:	0e 94 2b 0b 	call	0x1656	; 0x1656 <prvInsertTimerInActiveList>
    194e:	88 23       	and	r24, r24
    1950:	69 f0       	breq	.+26     	; 0x196c <prvTimerTask+0xb2>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1952:	0e 2d       	mov	r16, r14
    1954:	1f 2d       	mov	r17, r15
    1956:	2e 2d       	mov	r18, r14
    1958:	3f 2d       	mov	r19, r15
    195a:	a5 01       	movw	r20, r10
    195c:	65 2d       	mov	r22, r5
    195e:	c3 01       	movw	r24, r6
    1960:	0e 94 a5 0b 	call	0x174a	; 0x174a <xTimerGenericCommand>
    1964:	03 c0       	rjmp	.+6      	; 0x196c <prvTimerTask+0xb2>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1966:	8e 7f       	andi	r24, 0xFE	; 254
    1968:	f3 01       	movw	r30, r6
    196a:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    196c:	d3 01       	movw	r26, r6
    196e:	50 96       	adiw	r26, 0x10	; 16
    1970:	ed 91       	ld	r30, X+
    1972:	fc 91       	ld	r31, X
    1974:	51 97       	sbiw	r26, 0x11	; 17
    1976:	c3 01       	movw	r24, r6
    1978:	09 95       	icall
    197a:	87 c0       	rjmp	.+270    	; 0x1a8a <prvTimerTask+0x1d0>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    197c:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    197e:	b5 01       	movw	r22, r10
    1980:	60 1b       	sub	r22, r16
    1982:	71 0b       	sbc	r23, r17
    1984:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <xTimerQueue>
    1988:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <xTimerQueue+0x1>
    198c:	0e 94 aa 05 	call	0xb54	; 0xb54 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    1990:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
    1994:	81 11       	cpse	r24, r1
    1996:	79 c0       	rjmp	.+242    	; 0x1a8a <prvTimerTask+0x1d0>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    1998:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
    199c:	76 c0       	rjmp	.+236    	; 0x1a8a <prvTimerTask+0x1d0>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    199e:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskResumeAll>
    19a2:	73 c0       	rjmp	.+230    	; 0x1a8a <prvTimerTask+0x1d0>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    19a4:	89 81       	ldd	r24, Y+1	; 0x01
    19a6:	88 23       	and	r24, r24
    19a8:	0c f4       	brge	.+2      	; 0x19ac <prvTimerTask+0xf2>
    19aa:	6f c0       	rjmp	.+222    	; 0x1a8a <prvTimerTask+0x1d0>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    19ac:	ac 80       	ldd	r10, Y+4	; 0x04
    19ae:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    19b0:	f5 01       	movw	r30, r10
    19b2:	82 85       	ldd	r24, Z+10	; 0x0a
    19b4:	93 85       	ldd	r25, Z+11	; 0x0b
    19b6:	89 2b       	or	r24, r25
    19b8:	21 f0       	breq	.+8      	; 0x19c2 <prvTimerTask+0x108>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    19ba:	c5 01       	movw	r24, r10
    19bc:	02 96       	adiw	r24, 0x02	; 2
    19be:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    19c2:	ce 01       	movw	r24, r28
    19c4:	06 96       	adiw	r24, 0x06	; 6
    19c6:	0e 94 ed 0b 	call	0x17da	; 0x17da <prvSampleTimeNow>

            switch( xMessage.xMessageID )
    19ca:	e9 81       	ldd	r30, Y+1	; 0x01
    19cc:	0e 2e       	mov	r0, r30
    19ce:	00 0c       	add	r0, r0
    19d0:	ff 0b       	sbc	r31, r31
    19d2:	ea 30       	cpi	r30, 0x0A	; 10
    19d4:	f1 05       	cpc	r31, r1
    19d6:	08 f0       	brcs	.+2      	; 0x19da <prvTimerTask+0x120>
    19d8:	58 c0       	rjmp	.+176    	; 0x1a8a <prvTimerTask+0x1d0>
    19da:	ea 5a       	subi	r30, 0xAA	; 170
    19dc:	ff 4f       	sbci	r31, 0xFF	; 255
    19de:	0c 94 66 0d 	jmp	0x1acc	; 0x1acc <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    19e2:	d5 01       	movw	r26, r10
    19e4:	52 96       	adiw	r26, 0x12	; 18
    19e6:	2c 91       	ld	r18, X
    19e8:	52 97       	sbiw	r26, 0x12	; 18
    19ea:	21 60       	ori	r18, 0x01	; 1
    19ec:	52 96       	adiw	r26, 0x12	; 18
    19ee:	2c 93       	st	X, r18
    19f0:	52 97       	sbiw	r26, 0x12	; 18
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    19f2:	2a 81       	ldd	r18, Y+2	; 0x02
    19f4:	3b 81       	ldd	r19, Y+3	; 0x03
    19f6:	1c 96       	adiw	r26, 0x0c	; 12
    19f8:	6d 91       	ld	r22, X+
    19fa:	7c 91       	ld	r23, X
    19fc:	1d 97       	sbiw	r26, 0x0d	; 13
    19fe:	62 0f       	add	r22, r18
    1a00:	73 1f       	adc	r23, r19
    1a02:	ac 01       	movw	r20, r24
    1a04:	c5 01       	movw	r24, r10
    1a06:	0e 94 2b 0b 	call	0x1656	; 0x1656 <prvInsertTimerInActiveList>
    1a0a:	88 23       	and	r24, r24
    1a0c:	f1 f1       	breq	.+124    	; 0x1a8a <prvTimerTask+0x1d0>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1a0e:	d5 01       	movw	r26, r10
    1a10:	50 96       	adiw	r26, 0x10	; 16
    1a12:	ed 91       	ld	r30, X+
    1a14:	fc 91       	ld	r31, X
    1a16:	51 97       	sbiw	r26, 0x11	; 17
    1a18:	c5 01       	movw	r24, r10
    1a1a:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1a1c:	f5 01       	movw	r30, r10
    1a1e:	82 89       	ldd	r24, Z+18	; 0x12
    1a20:	82 ff       	sbrs	r24, 2
    1a22:	33 c0       	rjmp	.+102    	; 0x1a8a <prvTimerTask+0x1d0>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1a24:	4a 81       	ldd	r20, Y+2	; 0x02
    1a26:	5b 81       	ldd	r21, Y+3	; 0x03
    1a28:	84 85       	ldd	r24, Z+12	; 0x0c
    1a2a:	95 85       	ldd	r25, Z+13	; 0x0d
    1a2c:	48 0f       	add	r20, r24
    1a2e:	59 1f       	adc	r21, r25
    1a30:	0e 2d       	mov	r16, r14
    1a32:	1f 2d       	mov	r17, r15
    1a34:	2e 2d       	mov	r18, r14
    1a36:	3f 2d       	mov	r19, r15
    1a38:	65 2d       	mov	r22, r5
    1a3a:	c5 01       	movw	r24, r10
    1a3c:	0e 94 a5 0b 	call	0x174a	; 0x174a <xTimerGenericCommand>
    1a40:	24 c0       	rjmp	.+72     	; 0x1a8a <prvTimerTask+0x1d0>
                    break;

                case tmrCOMMAND_STOP :
                case tmrCOMMAND_STOP_FROM_ISR :
                    /* The timer has already been removed from the active list. */
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1a42:	d5 01       	movw	r26, r10
    1a44:	52 96       	adiw	r26, 0x12	; 18
    1a46:	8c 91       	ld	r24, X
    1a48:	52 97       	sbiw	r26, 0x12	; 18
    1a4a:	8e 7f       	andi	r24, 0xFE	; 254
    1a4c:	52 96       	adiw	r26, 0x12	; 18
    1a4e:	8c 93       	st	X, r24
    1a50:	1c c0       	rjmp	.+56     	; 0x1a8a <prvTimerTask+0x1d0>
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    1a52:	f5 01       	movw	r30, r10
    1a54:	22 89       	ldd	r18, Z+18	; 0x12
    1a56:	21 60       	ori	r18, 0x01	; 1
    1a58:	22 8b       	std	Z+18, r18	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1a5a:	6a 81       	ldd	r22, Y+2	; 0x02
    1a5c:	7b 81       	ldd	r23, Y+3	; 0x03
    1a5e:	75 87       	std	Z+13, r23	; 0x0d
    1a60:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1a62:	68 0f       	add	r22, r24
    1a64:	79 1f       	adc	r23, r25
    1a66:	9c 01       	movw	r18, r24
    1a68:	ac 01       	movw	r20, r24
    1a6a:	c5 01       	movw	r24, r10
    1a6c:	0e 94 2b 0b 	call	0x1656	; 0x1656 <prvInsertTimerInActiveList>
    1a70:	0c c0       	rjmp	.+24     	; 0x1a8a <prvTimerTask+0x1d0>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    1a72:	d5 01       	movw	r26, r10
    1a74:	52 96       	adiw	r26, 0x12	; 18
    1a76:	8c 91       	ld	r24, X
    1a78:	81 fd       	sbrc	r24, 1
    1a7a:	04 c0       	rjmp	.+8      	; 0x1a84 <prvTimerTask+0x1ca>
                        {
                            vPortFree( pxTimer );
    1a7c:	c5 01       	movw	r24, r10
    1a7e:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
    1a82:	03 c0       	rjmp	.+6      	; 0x1a8a <prvTimerTask+0x1d0>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1a84:	8e 7f       	andi	r24, 0xFE	; 254
    1a86:	f5 01       	movw	r30, r10
    1a88:	82 8b       	std	Z+18, r24	; 0x12
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1a8a:	4e 2d       	mov	r20, r14
    1a8c:	5f 2d       	mov	r21, r15
    1a8e:	6c 2d       	mov	r22, r12
    1a90:	7d 2d       	mov	r23, r13
    1a92:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <xTimerQueue>
    1a96:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <xTimerQueue+0x1>
    1a9a:	0e 94 11 05 	call	0xa22	; 0xa22 <xQueueReceive>
    1a9e:	81 11       	cpse	r24, r1
    1aa0:	81 cf       	rjmp	.-254    	; 0x19a4 <prvTimerTask+0xea>
    1aa2:	1c cf       	rjmp	.-456    	; 0x18dc <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    1aa4:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1aa8:	c4 01       	movw	r24, r8
    1aaa:	0e 94 ed 0b 	call	0x17da	; 0x17da <prvSampleTimeNow>
    1aae:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	81 11       	cpse	r24, r1
    1ab4:	74 cf       	rjmp	.-280    	; 0x199e <prvTimerTask+0xe4>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1ab6:	e0 91 96 01 	lds	r30, 0x0196	; 0x800196 <pxOverflowTimerList>
    1aba:	f0 91 97 01 	lds	r31, 0x0197	; 0x800197 <pxOverflowTimerList+0x1>
    1abe:	80 81       	ld	r24, Z
    1ac0:	44 2d       	mov	r20, r4
    1ac2:	81 11       	cpse	r24, r1
    1ac4:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    1ac6:	ae 2c       	mov	r10, r14
    1ac8:	bf 2c       	mov	r11, r15
    1aca:	59 cf       	rjmp	.-334    	; 0x197e <prvTimerTask+0xc4>

00001acc <__tablejump2__>:
    1acc:	ee 0f       	add	r30, r30
    1ace:	ff 1f       	adc	r31, r31
    1ad0:	05 90       	lpm	r0, Z+
    1ad2:	f4 91       	lpm	r31, Z
    1ad4:	e0 2d       	mov	r30, r0
    1ad6:	09 94       	ijmp

00001ad8 <malloc>:
    1ad8:	0f 93       	push	r16
    1ada:	1f 93       	push	r17
    1adc:	cf 93       	push	r28
    1ade:	df 93       	push	r29
    1ae0:	82 30       	cpi	r24, 0x02	; 2
    1ae2:	91 05       	cpc	r25, r1
    1ae4:	10 f4       	brcc	.+4      	; 0x1aea <malloc+0x12>
    1ae6:	82 e0       	ldi	r24, 0x02	; 2
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	e0 91 b0 01 	lds	r30, 0x01B0	; 0x8001b0 <__flp>
    1aee:	f0 91 b1 01 	lds	r31, 0x01B1	; 0x8001b1 <__flp+0x1>
    1af2:	20 e0       	ldi	r18, 0x00	; 0
    1af4:	30 e0       	ldi	r19, 0x00	; 0
    1af6:	a0 e0       	ldi	r26, 0x00	; 0
    1af8:	b0 e0       	ldi	r27, 0x00	; 0
    1afa:	30 97       	sbiw	r30, 0x00	; 0
    1afc:	19 f1       	breq	.+70     	; 0x1b44 <malloc+0x6c>
    1afe:	40 81       	ld	r20, Z
    1b00:	51 81       	ldd	r21, Z+1	; 0x01
    1b02:	02 81       	ldd	r16, Z+2	; 0x02
    1b04:	13 81       	ldd	r17, Z+3	; 0x03
    1b06:	48 17       	cp	r20, r24
    1b08:	59 07       	cpc	r21, r25
    1b0a:	c8 f0       	brcs	.+50     	; 0x1b3e <malloc+0x66>
    1b0c:	84 17       	cp	r24, r20
    1b0e:	95 07       	cpc	r25, r21
    1b10:	69 f4       	brne	.+26     	; 0x1b2c <malloc+0x54>
    1b12:	10 97       	sbiw	r26, 0x00	; 0
    1b14:	31 f0       	breq	.+12     	; 0x1b22 <malloc+0x4a>
    1b16:	12 96       	adiw	r26, 0x02	; 2
    1b18:	0c 93       	st	X, r16
    1b1a:	12 97       	sbiw	r26, 0x02	; 2
    1b1c:	13 96       	adiw	r26, 0x03	; 3
    1b1e:	1c 93       	st	X, r17
    1b20:	27 c0       	rjmp	.+78     	; 0x1b70 <malloc+0x98>
    1b22:	00 93 b0 01 	sts	0x01B0, r16	; 0x8001b0 <__flp>
    1b26:	10 93 b1 01 	sts	0x01B1, r17	; 0x8001b1 <__flp+0x1>
    1b2a:	22 c0       	rjmp	.+68     	; 0x1b70 <malloc+0x98>
    1b2c:	21 15       	cp	r18, r1
    1b2e:	31 05       	cpc	r19, r1
    1b30:	19 f0       	breq	.+6      	; 0x1b38 <malloc+0x60>
    1b32:	42 17       	cp	r20, r18
    1b34:	53 07       	cpc	r21, r19
    1b36:	18 f4       	brcc	.+6      	; 0x1b3e <malloc+0x66>
    1b38:	9a 01       	movw	r18, r20
    1b3a:	bd 01       	movw	r22, r26
    1b3c:	ef 01       	movw	r28, r30
    1b3e:	df 01       	movw	r26, r30
    1b40:	f8 01       	movw	r30, r16
    1b42:	db cf       	rjmp	.-74     	; 0x1afa <malloc+0x22>
    1b44:	21 15       	cp	r18, r1
    1b46:	31 05       	cpc	r19, r1
    1b48:	f9 f0       	breq	.+62     	; 0x1b88 <malloc+0xb0>
    1b4a:	28 1b       	sub	r18, r24
    1b4c:	39 0b       	sbc	r19, r25
    1b4e:	24 30       	cpi	r18, 0x04	; 4
    1b50:	31 05       	cpc	r19, r1
    1b52:	80 f4       	brcc	.+32     	; 0x1b74 <malloc+0x9c>
    1b54:	8a 81       	ldd	r24, Y+2	; 0x02
    1b56:	9b 81       	ldd	r25, Y+3	; 0x03
    1b58:	61 15       	cp	r22, r1
    1b5a:	71 05       	cpc	r23, r1
    1b5c:	21 f0       	breq	.+8      	; 0x1b66 <malloc+0x8e>
    1b5e:	fb 01       	movw	r30, r22
    1b60:	93 83       	std	Z+3, r25	; 0x03
    1b62:	82 83       	std	Z+2, r24	; 0x02
    1b64:	04 c0       	rjmp	.+8      	; 0x1b6e <malloc+0x96>
    1b66:	90 93 b1 01 	sts	0x01B1, r25	; 0x8001b1 <__flp+0x1>
    1b6a:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <__flp>
    1b6e:	fe 01       	movw	r30, r28
    1b70:	32 96       	adiw	r30, 0x02	; 2
    1b72:	44 c0       	rjmp	.+136    	; 0x1bfc <malloc+0x124>
    1b74:	fe 01       	movw	r30, r28
    1b76:	e2 0f       	add	r30, r18
    1b78:	f3 1f       	adc	r31, r19
    1b7a:	81 93       	st	Z+, r24
    1b7c:	91 93       	st	Z+, r25
    1b7e:	22 50       	subi	r18, 0x02	; 2
    1b80:	31 09       	sbc	r19, r1
    1b82:	39 83       	std	Y+1, r19	; 0x01
    1b84:	28 83       	st	Y, r18
    1b86:	3a c0       	rjmp	.+116    	; 0x1bfc <malloc+0x124>
    1b88:	20 91 ae 01 	lds	r18, 0x01AE	; 0x8001ae <__brkval>
    1b8c:	30 91 af 01 	lds	r19, 0x01AF	; 0x8001af <__brkval+0x1>
    1b90:	23 2b       	or	r18, r19
    1b92:	41 f4       	brne	.+16     	; 0x1ba4 <malloc+0xcc>
    1b94:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1b98:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1b9c:	30 93 af 01 	sts	0x01AF, r19	; 0x8001af <__brkval+0x1>
    1ba0:	20 93 ae 01 	sts	0x01AE, r18	; 0x8001ae <__brkval>
    1ba4:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    1ba8:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    1bac:	21 15       	cp	r18, r1
    1bae:	31 05       	cpc	r19, r1
    1bb0:	41 f4       	brne	.+16     	; 0x1bc2 <malloc+0xea>
    1bb2:	2d b7       	in	r18, 0x3d	; 61
    1bb4:	3e b7       	in	r19, 0x3e	; 62
    1bb6:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1bba:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1bbe:	24 1b       	sub	r18, r20
    1bc0:	35 0b       	sbc	r19, r21
    1bc2:	e0 91 ae 01 	lds	r30, 0x01AE	; 0x8001ae <__brkval>
    1bc6:	f0 91 af 01 	lds	r31, 0x01AF	; 0x8001af <__brkval+0x1>
    1bca:	e2 17       	cp	r30, r18
    1bcc:	f3 07       	cpc	r31, r19
    1bce:	a0 f4       	brcc	.+40     	; 0x1bf8 <malloc+0x120>
    1bd0:	2e 1b       	sub	r18, r30
    1bd2:	3f 0b       	sbc	r19, r31
    1bd4:	28 17       	cp	r18, r24
    1bd6:	39 07       	cpc	r19, r25
    1bd8:	78 f0       	brcs	.+30     	; 0x1bf8 <malloc+0x120>
    1bda:	ac 01       	movw	r20, r24
    1bdc:	4e 5f       	subi	r20, 0xFE	; 254
    1bde:	5f 4f       	sbci	r21, 0xFF	; 255
    1be0:	24 17       	cp	r18, r20
    1be2:	35 07       	cpc	r19, r21
    1be4:	48 f0       	brcs	.+18     	; 0x1bf8 <malloc+0x120>
    1be6:	4e 0f       	add	r20, r30
    1be8:	5f 1f       	adc	r21, r31
    1bea:	50 93 af 01 	sts	0x01AF, r21	; 0x8001af <__brkval+0x1>
    1bee:	40 93 ae 01 	sts	0x01AE, r20	; 0x8001ae <__brkval>
    1bf2:	81 93       	st	Z+, r24
    1bf4:	91 93       	st	Z+, r25
    1bf6:	02 c0       	rjmp	.+4      	; 0x1bfc <malloc+0x124>
    1bf8:	e0 e0       	ldi	r30, 0x00	; 0
    1bfa:	f0 e0       	ldi	r31, 0x00	; 0
    1bfc:	cf 01       	movw	r24, r30
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	08 95       	ret

00001c08 <free>:
    1c08:	cf 93       	push	r28
    1c0a:	df 93       	push	r29
    1c0c:	00 97       	sbiw	r24, 0x00	; 0
    1c0e:	09 f4       	brne	.+2      	; 0x1c12 <free+0xa>
    1c10:	81 c0       	rjmp	.+258    	; 0x1d14 <free+0x10c>
    1c12:	fc 01       	movw	r30, r24
    1c14:	32 97       	sbiw	r30, 0x02	; 2
    1c16:	13 82       	std	Z+3, r1	; 0x03
    1c18:	12 82       	std	Z+2, r1	; 0x02
    1c1a:	a0 91 b0 01 	lds	r26, 0x01B0	; 0x8001b0 <__flp>
    1c1e:	b0 91 b1 01 	lds	r27, 0x01B1	; 0x8001b1 <__flp+0x1>
    1c22:	10 97       	sbiw	r26, 0x00	; 0
    1c24:	81 f4       	brne	.+32     	; 0x1c46 <free+0x3e>
    1c26:	20 81       	ld	r18, Z
    1c28:	31 81       	ldd	r19, Z+1	; 0x01
    1c2a:	82 0f       	add	r24, r18
    1c2c:	93 1f       	adc	r25, r19
    1c2e:	20 91 ae 01 	lds	r18, 0x01AE	; 0x8001ae <__brkval>
    1c32:	30 91 af 01 	lds	r19, 0x01AF	; 0x8001af <__brkval+0x1>
    1c36:	28 17       	cp	r18, r24
    1c38:	39 07       	cpc	r19, r25
    1c3a:	51 f5       	brne	.+84     	; 0x1c90 <free+0x88>
    1c3c:	f0 93 af 01 	sts	0x01AF, r31	; 0x8001af <__brkval+0x1>
    1c40:	e0 93 ae 01 	sts	0x01AE, r30	; 0x8001ae <__brkval>
    1c44:	67 c0       	rjmp	.+206    	; 0x1d14 <free+0x10c>
    1c46:	ed 01       	movw	r28, r26
    1c48:	20 e0       	ldi	r18, 0x00	; 0
    1c4a:	30 e0       	ldi	r19, 0x00	; 0
    1c4c:	ce 17       	cp	r28, r30
    1c4e:	df 07       	cpc	r29, r31
    1c50:	40 f4       	brcc	.+16     	; 0x1c62 <free+0x5a>
    1c52:	4a 81       	ldd	r20, Y+2	; 0x02
    1c54:	5b 81       	ldd	r21, Y+3	; 0x03
    1c56:	9e 01       	movw	r18, r28
    1c58:	41 15       	cp	r20, r1
    1c5a:	51 05       	cpc	r21, r1
    1c5c:	f1 f0       	breq	.+60     	; 0x1c9a <free+0x92>
    1c5e:	ea 01       	movw	r28, r20
    1c60:	f5 cf       	rjmp	.-22     	; 0x1c4c <free+0x44>
    1c62:	d3 83       	std	Z+3, r29	; 0x03
    1c64:	c2 83       	std	Z+2, r28	; 0x02
    1c66:	40 81       	ld	r20, Z
    1c68:	51 81       	ldd	r21, Z+1	; 0x01
    1c6a:	84 0f       	add	r24, r20
    1c6c:	95 1f       	adc	r25, r21
    1c6e:	c8 17       	cp	r28, r24
    1c70:	d9 07       	cpc	r29, r25
    1c72:	59 f4       	brne	.+22     	; 0x1c8a <free+0x82>
    1c74:	88 81       	ld	r24, Y
    1c76:	99 81       	ldd	r25, Y+1	; 0x01
    1c78:	84 0f       	add	r24, r20
    1c7a:	95 1f       	adc	r25, r21
    1c7c:	02 96       	adiw	r24, 0x02	; 2
    1c7e:	91 83       	std	Z+1, r25	; 0x01
    1c80:	80 83       	st	Z, r24
    1c82:	8a 81       	ldd	r24, Y+2	; 0x02
    1c84:	9b 81       	ldd	r25, Y+3	; 0x03
    1c86:	93 83       	std	Z+3, r25	; 0x03
    1c88:	82 83       	std	Z+2, r24	; 0x02
    1c8a:	21 15       	cp	r18, r1
    1c8c:	31 05       	cpc	r19, r1
    1c8e:	29 f4       	brne	.+10     	; 0x1c9a <free+0x92>
    1c90:	f0 93 b1 01 	sts	0x01B1, r31	; 0x8001b1 <__flp+0x1>
    1c94:	e0 93 b0 01 	sts	0x01B0, r30	; 0x8001b0 <__flp>
    1c98:	3d c0       	rjmp	.+122    	; 0x1d14 <free+0x10c>
    1c9a:	e9 01       	movw	r28, r18
    1c9c:	fb 83       	std	Y+3, r31	; 0x03
    1c9e:	ea 83       	std	Y+2, r30	; 0x02
    1ca0:	49 91       	ld	r20, Y+
    1ca2:	59 91       	ld	r21, Y+
    1ca4:	c4 0f       	add	r28, r20
    1ca6:	d5 1f       	adc	r29, r21
    1ca8:	ec 17       	cp	r30, r28
    1caa:	fd 07       	cpc	r31, r29
    1cac:	61 f4       	brne	.+24     	; 0x1cc6 <free+0xbe>
    1cae:	80 81       	ld	r24, Z
    1cb0:	91 81       	ldd	r25, Z+1	; 0x01
    1cb2:	84 0f       	add	r24, r20
    1cb4:	95 1f       	adc	r25, r21
    1cb6:	02 96       	adiw	r24, 0x02	; 2
    1cb8:	e9 01       	movw	r28, r18
    1cba:	99 83       	std	Y+1, r25	; 0x01
    1cbc:	88 83       	st	Y, r24
    1cbe:	82 81       	ldd	r24, Z+2	; 0x02
    1cc0:	93 81       	ldd	r25, Z+3	; 0x03
    1cc2:	9b 83       	std	Y+3, r25	; 0x03
    1cc4:	8a 83       	std	Y+2, r24	; 0x02
    1cc6:	e0 e0       	ldi	r30, 0x00	; 0
    1cc8:	f0 e0       	ldi	r31, 0x00	; 0
    1cca:	12 96       	adiw	r26, 0x02	; 2
    1ccc:	8d 91       	ld	r24, X+
    1cce:	9c 91       	ld	r25, X
    1cd0:	13 97       	sbiw	r26, 0x03	; 3
    1cd2:	00 97       	sbiw	r24, 0x00	; 0
    1cd4:	19 f0       	breq	.+6      	; 0x1cdc <free+0xd4>
    1cd6:	fd 01       	movw	r30, r26
    1cd8:	dc 01       	movw	r26, r24
    1cda:	f7 cf       	rjmp	.-18     	; 0x1cca <free+0xc2>
    1cdc:	8d 91       	ld	r24, X+
    1cde:	9c 91       	ld	r25, X
    1ce0:	11 97       	sbiw	r26, 0x01	; 1
    1ce2:	9d 01       	movw	r18, r26
    1ce4:	2e 5f       	subi	r18, 0xFE	; 254
    1ce6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ce8:	82 0f       	add	r24, r18
    1cea:	93 1f       	adc	r25, r19
    1cec:	20 91 ae 01 	lds	r18, 0x01AE	; 0x8001ae <__brkval>
    1cf0:	30 91 af 01 	lds	r19, 0x01AF	; 0x8001af <__brkval+0x1>
    1cf4:	28 17       	cp	r18, r24
    1cf6:	39 07       	cpc	r19, r25
    1cf8:	69 f4       	brne	.+26     	; 0x1d14 <free+0x10c>
    1cfa:	30 97       	sbiw	r30, 0x00	; 0
    1cfc:	29 f4       	brne	.+10     	; 0x1d08 <free+0x100>
    1cfe:	10 92 b1 01 	sts	0x01B1, r1	; 0x8001b1 <__flp+0x1>
    1d02:	10 92 b0 01 	sts	0x01B0, r1	; 0x8001b0 <__flp>
    1d06:	02 c0       	rjmp	.+4      	; 0x1d0c <free+0x104>
    1d08:	13 82       	std	Z+3, r1	; 0x03
    1d0a:	12 82       	std	Z+2, r1	; 0x02
    1d0c:	b0 93 af 01 	sts	0x01AF, r27	; 0x8001af <__brkval+0x1>
    1d10:	a0 93 ae 01 	sts	0x01AE, r26	; 0x8001ae <__brkval>
    1d14:	df 91       	pop	r29
    1d16:	cf 91       	pop	r28
    1d18:	08 95       	ret

00001d1a <memcpy>:
    1d1a:	fb 01       	movw	r30, r22
    1d1c:	dc 01       	movw	r26, r24
    1d1e:	02 c0       	rjmp	.+4      	; 0x1d24 <memcpy+0xa>
    1d20:	01 90       	ld	r0, Z+
    1d22:	0d 92       	st	X+, r0
    1d24:	41 50       	subi	r20, 0x01	; 1
    1d26:	50 40       	sbci	r21, 0x00	; 0
    1d28:	d8 f7       	brcc	.-10     	; 0x1d20 <memcpy+0x6>
    1d2a:	08 95       	ret

00001d2c <memset>:
    1d2c:	dc 01       	movw	r26, r24
    1d2e:	01 c0       	rjmp	.+2      	; 0x1d32 <memset+0x6>
    1d30:	6d 93       	st	X+, r22
    1d32:	41 50       	subi	r20, 0x01	; 1
    1d34:	50 40       	sbci	r21, 0x00	; 0
    1d36:	e0 f7       	brcc	.-8      	; 0x1d30 <memset+0x4>
    1d38:	08 95       	ret

00001d3a <_exit>:
    1d3a:	f8 94       	cli

00001d3c <__stop_program>:
    1d3c:	ff cf       	rjmp	.-2      	; 0x1d3c <__stop_program>
