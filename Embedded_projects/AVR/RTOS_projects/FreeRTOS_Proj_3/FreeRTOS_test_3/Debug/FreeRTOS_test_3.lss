
FreeRTOS_test_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00001f3c  00001fd0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f3c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000008d  00800124  00800124  00001ff4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001ff4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002024  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000428  00000000  00000000  00002064  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000607b  00000000  00000000  0000248c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017ca  00000000  00000000  00008507  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002e69  00000000  00000000  00009cd1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d00  00000000  00000000  0000cb3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001cb4  00000000  00000000  0000d83c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000527f  00000000  00000000  0000f4f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000510  00000000  00000000  0001476f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__ctors_end>
       4:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       8:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
       c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      10:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      14:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      18:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      1c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      20:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      24:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      28:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      2c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      30:	0c 94 d1 02 	jmp	0x5a2	; 0x5a2 <__vector_12>
      34:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      38:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      3c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      40:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      44:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      48:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      4c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      50:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      54:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      58:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      5c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      60:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      64:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      68:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      6c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      70:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      74:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      78:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      7c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      80:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      84:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      88:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      8c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      90:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      94:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      98:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      9c:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a0:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a4:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      a8:	0c 94 7d 00 	jmp	0xfa	; 0xfa <__bad_interrupt>
      ac:	f0 0d       	add	r31, r0
      ae:	f0 0d       	add	r31, r0
      b0:	f0 0d       	add	r31, r0
      b2:	20 0e       	add	r2, r16
      b4:	28 0e       	add	r2, r24
      b6:	38 0e       	add	r3, r24
      b8:	f0 0d       	add	r31, r0
      ba:	f0 0d       	add	r31, r0
      bc:	20 0e       	add	r2, r16
      be:	28 0e       	add	r2, r24

000000c0 <__ctors_end>:
      c0:	11 24       	eor	r1, r1
      c2:	1f be       	out	0x3f, r1	; 63
      c4:	cf ef       	ldi	r28, 0xFF	; 255
      c6:	da e0       	ldi	r29, 0x0A	; 10
      c8:	de bf       	out	0x3e, r29	; 62
      ca:	cd bf       	out	0x3d, r28	; 61

000000cc <__do_copy_data>:
      cc:	11 e0       	ldi	r17, 0x01	; 1
      ce:	a0 e0       	ldi	r26, 0x00	; 0
      d0:	b1 e0       	ldi	r27, 0x01	; 1
      d2:	ec e3       	ldi	r30, 0x3C	; 60
      d4:	ff e1       	ldi	r31, 0x1F	; 31
      d6:	02 c0       	rjmp	.+4      	; 0xdc <__do_copy_data+0x10>
      d8:	05 90       	lpm	r0, Z+
      da:	0d 92       	st	X+, r0
      dc:	a4 32       	cpi	r26, 0x24	; 36
      de:	b1 07       	cpc	r27, r17
      e0:	d9 f7       	brne	.-10     	; 0xd8 <__do_copy_data+0xc>

000000e2 <__do_clear_bss>:
      e2:	21 e0       	ldi	r18, 0x01	; 1
      e4:	a4 e2       	ldi	r26, 0x24	; 36
      e6:	b1 e0       	ldi	r27, 0x01	; 1
      e8:	01 c0       	rjmp	.+2      	; 0xec <.do_clear_bss_start>

000000ea <.do_clear_bss_loop>:
      ea:	1d 92       	st	X+, r1

000000ec <.do_clear_bss_start>:
      ec:	a1 3b       	cpi	r26, 0xB1	; 177
      ee:	b2 07       	cpc	r27, r18
      f0:	e1 f7       	brne	.-8      	; 0xea <.do_clear_bss_loop>
      f2:	0e 94 9c 01 	call	0x338	; 0x338 <main>
      f6:	0c 94 9c 0f 	jmp	0x1f38	; 0x1f38 <_exit>

000000fa <__bad_interrupt>:
      fa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000fe <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      fe:	cf 93       	push	r28
     100:	df 93       	push	r29
     102:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
     104:	0e 94 69 08 	call	0x10d2	; 0x10d2 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
     108:	ce 01       	movw	r24, r28
     10a:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <malloc>
     10e:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     110:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
     114:	20 97       	sbiw	r28, 0x00	; 0
     116:	11 f4       	brne	.+4      	; 0x11c <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
     118:	0e 94 bb 00 	call	0x176	; 0x176 <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
     11c:	ce 01       	movw	r24, r28
     11e:	df 91       	pop	r29
     120:	cf 91       	pop	r28
     122:	08 95       	ret

00000124 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     124:	cf 93       	push	r28
     126:	df 93       	push	r29
    if( pv )
     128:	00 97       	sbiw	r24, 0x00	; 0
     12a:	41 f0       	breq	.+16     	; 0x13c <vPortFree+0x18>
     12c:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
     12e:	0e 94 69 08 	call	0x10d2	; 0x10d2 <vTaskSuspendAll>
        {
            free( pv );
     132:	ce 01       	movw	r24, r28
     134:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
     138:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
    }
}
     13c:	df 91       	pop	r29
     13e:	cf 91       	pop	r28
     140:	08 95       	ret

00000142 <vApplicationIdleHook>:

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino with 328p
    DIDR0 = 0x3F;

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DIDR0 = 0xF3;
     142:	83 ef       	ldi	r24, 0xF3	; 243
     144:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
    DIDR2 = 0x3F;
     148:	8f e3       	ldi	r24, 0x3F	; 63
     14a:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7f807d>
    // When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
    // This bit can be set at any time to turn off the Analogue Comparator.
    // This will reduce power consumption in Active and Idle mode.
    // When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
    // Otherwise an interrupt can occur when the ACD bit is changed.
    ACSR &= ~_BV(ACIE);
     14e:	80 b7       	in	r24, 0x30	; 48
     150:	87 7f       	andi	r24, 0xF7	; 247
     152:	80 bf       	out	0x30, r24	; 48
    ACSR |=  _BV(ACD);
     154:	80 b7       	in	r24, 0x30	; 48
     156:	80 68       	ori	r24, 0x80	; 128
     158:	80 bf       	out	0x30, r24	; 48
    // SLEEP_MODE_PWR_DOWN     _BV(SM1)
    // SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
    // SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
    // SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

    set_sleep_mode( SLEEP_MODE_IDLE );
     15a:	83 b7       	in	r24, 0x33	; 51
     15c:	81 7f       	andi	r24, 0xF1	; 241
     15e:	83 bf       	out	0x33, r24	; 51

    portENTER_CRITICAL();
     160:	0f b6       	in	r0, 0x3f	; 63
     162:	f8 94       	cli
     164:	0f 92       	push	r0
    sleep_enable();
     166:	83 b7       	in	r24, 0x33	; 51
     168:	81 60       	ori	r24, 0x01	; 1
     16a:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
    sleep_bod_disable();
#endif

    portEXIT_CRITICAL();
     16c:	0f 90       	pop	r0
     16e:	0f be       	out	0x3f, r0	; 63
    sleep_cpu();            // good night.
     170:	88 95       	sleep

    sleep_reset();          // reset the sleep_mode() faster than sleep_disable();
     172:	13 be       	out	0x33, r1	; 51
     174:	08 95       	ret

00000176 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DDRC  |= _BV(DDC7);
     176:	3f 9a       	sbi	0x07, 7	; 7
    PORTC |= _BV(PORTC7);       // Main (red PC7) LED on. Main LED on.
     178:	47 9a       	sbi	0x08, 7	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     17a:	83 ed       	ldi	r24, 0xD3	; 211
     17c:	90 e3       	ldi	r25, 0x30	; 48
     17e:	01 97       	sbiw	r24, 0x01	; 1
     180:	f1 f7       	brne	.-4      	; 0x17e <vApplicationMallocFailedHook+0x8>
     182:	00 c0       	rjmp	.+0      	; 0x184 <vApplicationMallocFailedHook+0xe>
     184:	00 00       	nop

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
        PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED fast blink.
     186:	37 9a       	sbi	0x06, 7	; 6
     188:	f8 cf       	rjmp	.-16     	; 0x17a <vApplicationMallocFailedHook+0x4>

0000018a <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
    DDRC  |= _BV(DDC7);
     18a:	3f 9a       	sbi	0x07, 7	; 7
    PORTC |= _BV(PORTC7);       // Main (red PC7) LED on. Main LED on.
     18c:	47 9a       	sbi	0x08, 7	; 8
     18e:	2f e7       	ldi	r18, 0x7F	; 127
     190:	8a e1       	ldi	r24, 0x1A	; 26
     192:	96 e0       	ldi	r25, 0x06	; 6
     194:	21 50       	subi	r18, 0x01	; 1
     196:	80 40       	sbci	r24, 0x00	; 0
     198:	90 40       	sbci	r25, 0x00	; 0
     19a:	e1 f7       	brne	.-8      	; 0x194 <vApplicationStackOverflowHook+0xa>
     19c:	00 c0       	rjmp	.+0      	; 0x19e <vApplicationStackOverflowHook+0x14>
     19e:	00 00       	nop

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
        PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED slow blink.
     1a0:	37 9a       	sbi	0x06, 7	; 6
     1a2:	f5 cf       	rjmp	.-22     	; 0x18e <vApplicationStackOverflowHook+0x4>

000001a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     1a4:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1a6:	03 96       	adiw	r24, 0x03	; 3
     1a8:	92 83       	std	Z+2, r25	; 0x02
     1aa:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     1ac:	2f ef       	ldi	r18, 0xFF	; 255
     1ae:	3f ef       	ldi	r19, 0xFF	; 255
     1b0:	34 83       	std	Z+4, r19	; 0x04
     1b2:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1b4:	96 83       	std	Z+6, r25	; 0x06
     1b6:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1b8:	90 87       	std	Z+8, r25	; 0x08
     1ba:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1bc:	10 82       	st	Z, r1
     1be:	08 95       	ret

000001c0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     1c0:	fc 01       	movw	r30, r24
     1c2:	11 86       	std	Z+9, r1	; 0x09
     1c4:	10 86       	std	Z+8, r1	; 0x08
     1c6:	08 95       	ret

000001c8 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	9c 01       	movw	r18, r24
     1ce:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     1d0:	dc 01       	movw	r26, r24
     1d2:	11 96       	adiw	r26, 0x01	; 1
     1d4:	cd 91       	ld	r28, X+
     1d6:	dc 91       	ld	r29, X
     1d8:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     1da:	d3 83       	std	Z+3, r29	; 0x03
     1dc:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     1de:	8c 81       	ldd	r24, Y+4	; 0x04
     1e0:	9d 81       	ldd	r25, Y+5	; 0x05
     1e2:	95 83       	std	Z+5, r25	; 0x05
     1e4:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     1e6:	8c 81       	ldd	r24, Y+4	; 0x04
     1e8:	9d 81       	ldd	r25, Y+5	; 0x05
     1ea:	dc 01       	movw	r26, r24
     1ec:	13 96       	adiw	r26, 0x03	; 3
     1ee:	7c 93       	st	X, r23
     1f0:	6e 93       	st	-X, r22
     1f2:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
     1f4:	7d 83       	std	Y+5, r23	; 0x05
     1f6:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     1f8:	31 87       	std	Z+9, r19	; 0x09
     1fa:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
     1fc:	f9 01       	movw	r30, r18
     1fe:	80 81       	ld	r24, Z
     200:	8f 5f       	subi	r24, 0xFF	; 255
     202:	80 83       	st	Z, r24
}
     204:	df 91       	pop	r29
     206:	cf 91       	pop	r28
     208:	08 95       	ret

0000020a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     20a:	cf 93       	push	r28
     20c:	df 93       	push	r29
     20e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     210:	48 81       	ld	r20, Y
     212:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     214:	4f 3f       	cpi	r20, 0xFF	; 255
     216:	2f ef       	ldi	r18, 0xFF	; 255
     218:	52 07       	cpc	r21, r18
     21a:	21 f4       	brne	.+8      	; 0x224 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     21c:	fc 01       	movw	r30, r24
     21e:	a7 81       	ldd	r26, Z+7	; 0x07
     220:	b0 85       	ldd	r27, Z+8	; 0x08
     222:	0d c0       	rjmp	.+26     	; 0x23e <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     224:	dc 01       	movw	r26, r24
     226:	13 96       	adiw	r26, 0x03	; 3
     228:	01 c0       	rjmp	.+2      	; 0x22c <vListInsert+0x22>
     22a:	df 01       	movw	r26, r30
     22c:	12 96       	adiw	r26, 0x02	; 2
     22e:	ed 91       	ld	r30, X+
     230:	fc 91       	ld	r31, X
     232:	13 97       	sbiw	r26, 0x03	; 3
     234:	20 81       	ld	r18, Z
     236:	31 81       	ldd	r19, Z+1	; 0x01
     238:	42 17       	cp	r20, r18
     23a:	53 07       	cpc	r21, r19
     23c:	b0 f7       	brcc	.-20     	; 0x22a <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     23e:	12 96       	adiw	r26, 0x02	; 2
     240:	ed 91       	ld	r30, X+
     242:	fc 91       	ld	r31, X
     244:	13 97       	sbiw	r26, 0x03	; 3
     246:	fb 83       	std	Y+3, r31	; 0x03
     248:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     24a:	d5 83       	std	Z+5, r29	; 0x05
     24c:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     24e:	bd 83       	std	Y+5, r27	; 0x05
     250:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
     252:	13 96       	adiw	r26, 0x03	; 3
     254:	dc 93       	st	X, r29
     256:	ce 93       	st	-X, r28
     258:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
     25a:	99 87       	std	Y+9, r25	; 0x09
     25c:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     25e:	fc 01       	movw	r30, r24
     260:	20 81       	ld	r18, Z
     262:	2f 5f       	subi	r18, 0xFF	; 255
     264:	20 83       	st	Z, r18
}
     266:	df 91       	pop	r29
     268:	cf 91       	pop	r28
     26a:	08 95       	ret

0000026c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     272:	a0 85       	ldd	r26, Z+8	; 0x08
     274:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     276:	c2 81       	ldd	r28, Z+2	; 0x02
     278:	d3 81       	ldd	r29, Z+3	; 0x03
     27a:	84 81       	ldd	r24, Z+4	; 0x04
     27c:	95 81       	ldd	r25, Z+5	; 0x05
     27e:	9d 83       	std	Y+5, r25	; 0x05
     280:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     282:	c4 81       	ldd	r28, Z+4	; 0x04
     284:	d5 81       	ldd	r29, Z+5	; 0x05
     286:	82 81       	ldd	r24, Z+2	; 0x02
     288:	93 81       	ldd	r25, Z+3	; 0x03
     28a:	9b 83       	std	Y+3, r25	; 0x03
     28c:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     28e:	11 96       	adiw	r26, 0x01	; 1
     290:	8d 91       	ld	r24, X+
     292:	9c 91       	ld	r25, X
     294:	12 97       	sbiw	r26, 0x02	; 2
     296:	e8 17       	cp	r30, r24
     298:	f9 07       	cpc	r31, r25
     29a:	31 f4       	brne	.+12     	; 0x2a8 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     29c:	84 81       	ldd	r24, Z+4	; 0x04
     29e:	95 81       	ldd	r25, Z+5	; 0x05
     2a0:	12 96       	adiw	r26, 0x02	; 2
     2a2:	9c 93       	st	X, r25
     2a4:	8e 93       	st	-X, r24
     2a6:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     2a8:	11 86       	std	Z+9, r1	; 0x09
     2aa:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
     2ac:	8c 91       	ld	r24, X
     2ae:	81 50       	subi	r24, 0x01	; 1
     2b0:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
     2b2:	8c 91       	ld	r24, X
}
     2b4:	df 91       	pop	r29
     2b6:	cf 91       	pop	r28
     2b8:	08 95       	ret

000002ba <task1_code>:
	return 0;
}
/*Task1 Code  */
void task1_code(void*pvParamter)
{
	xSemaphoreTake(sem_handel_1,0xffff);
     2ba:	6f ef       	ldi	r22, 0xFF	; 255
     2bc:	7f ef       	ldi	r23, 0xFF	; 255
     2be:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <sem_handel_1>
     2c2:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <sem_handel_1+0x1>
     2c6:	0e 94 84 05 	call	0xb08	; 0xb08 <xQueueSemaphoreTake>
	for (;;)
	{
		if(xSemaphoreTake(sem_handel_1,0xffff))
     2ca:	6f ef       	ldi	r22, 0xFF	; 255
     2cc:	7f ef       	ldi	r23, 0xFF	; 255
     2ce:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <sem_handel_1>
     2d2:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <sem_handel_1+0x1>
     2d6:	0e 94 84 05 	call	0xb08	; 0xb08 <xQueueSemaphoreTake>
     2da:	88 23       	and	r24, r24
     2dc:	b1 f3       	breq	.-20     	; 0x2ca <task1_code+0x10>
		{
			SET_BIT(PORTD,PIND0);
     2de:	58 9a       	sbi	0x0b, 0	; 11
			vTaskDelay(5000);
     2e0:	88 e8       	ldi	r24, 0x88	; 136
     2e2:	93 e1       	ldi	r25, 0x13	; 19
     2e4:	0e 94 bb 09 	call	0x1376	; 0x1376 <vTaskDelay>
			CLEAR_BIT(PORTD,PIND0);
     2e8:	58 98       	cbi	0x0b, 0	; 11
			vTaskDelay(5000);
     2ea:	88 e8       	ldi	r24, 0x88	; 136
     2ec:	93 e1       	ldi	r25, 0x13	; 19
     2ee:	0e 94 bb 09 	call	0x1376	; 0x1376 <vTaskDelay>
			SET_BIT(PORTB,PIND0);
     2f2:	28 9a       	sbi	0x05, 0	; 5
			xSemaphoreGive(sem_handel_1);
     2f4:	20 e0       	ldi	r18, 0x00	; 0
     2f6:	40 e0       	ldi	r20, 0x00	; 0
     2f8:	50 e0       	ldi	r21, 0x00	; 0
     2fa:	60 e0       	ldi	r22, 0x00	; 0
     2fc:	70 e0       	ldi	r23, 0x00	; 0
     2fe:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <sem_handel_1>
     302:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <sem_handel_1+0x1>
     306:	0e 94 0e 04 	call	0x81c	; 0x81c <xQueueGenericSend>
     30a:	df cf       	rjmp	.-66     	; 0x2ca <task1_code+0x10>

0000030c <task2_code>:
/*Task2 Code */
void task2_code(void*pvParamter)
{
	for (;;)
	{
		SET_BIT(PORTD,PIND1);
     30c:	59 9a       	sbi	0x0b, 1	; 11
		vTaskDelay(5000);
     30e:	88 e8       	ldi	r24, 0x88	; 136
     310:	93 e1       	ldi	r25, 0x13	; 19
     312:	0e 94 bb 09 	call	0x1376	; 0x1376 <vTaskDelay>
		CLEAR_BIT(PORTD,PIND1);
     316:	59 98       	cbi	0x0b, 1	; 11
		vTaskDelay(5000);
     318:	88 e8       	ldi	r24, 0x88	; 136
     31a:	93 e1       	ldi	r25, 0x13	; 19
     31c:	0e 94 bb 09 	call	0x1376	; 0x1376 <vTaskDelay>
		xSemaphoreGive(sem_handel_1);
     320:	20 e0       	ldi	r18, 0x00	; 0
     322:	40 e0       	ldi	r20, 0x00	; 0
     324:	50 e0       	ldi	r21, 0x00	; 0
     326:	60 e0       	ldi	r22, 0x00	; 0
     328:	70 e0       	ldi	r23, 0x00	; 0
     32a:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <sem_handel_1>
     32e:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <sem_handel_1+0x1>
     332:	0e 94 0e 04 	call	0x81c	; 0x81c <xQueueGenericSend>
     336:	ea cf       	rjmp	.-44     	; 0x30c <task2_code>

00000338 <main>:
void task1_code(void*pvParamter);
void task2_code(void*pvParamter);

int main(void)
{
	DDRB=0XFF;
     338:	8f ef       	ldi	r24, 0xFF	; 255
     33a:	84 b9       	out	0x04, r24	; 4
	PORTB=0X00;
     33c:	15 b8       	out	0x05, r1	; 5
	DDRD=0XFF;
     33e:	8a b9       	out	0x0a, r24	; 10
	PORTD=0X00;
     340:	1b b8       	out	0x0b, r1	; 11
	xTaskCreate(task1_code,"pcTask1",85,task1_handle,TASK1_PRIORITY,NULL);
     342:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <task1_handle>
     346:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <task1_handle+0x1>
     34a:	e1 2c       	mov	r14, r1
     34c:	f1 2c       	mov	r15, r1
     34e:	03 e0       	ldi	r16, 0x03	; 3
     350:	45 e5       	ldi	r20, 0x55	; 85
     352:	50 e0       	ldi	r21, 0x00	; 0
     354:	66 e0       	ldi	r22, 0x06	; 6
     356:	71 e0       	ldi	r23, 0x01	; 1
     358:	8d e5       	ldi	r24, 0x5D	; 93
     35a:	91 e0       	ldi	r25, 0x01	; 1
     35c:	0e 94 1f 07 	call	0xe3e	; 0xe3e <xTaskCreate>
	xTaskCreate(task2_code,"pcTask2",85,task2_handle,TASK2_PRIORITY,NULL);
     360:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <__data_end>
     364:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <__data_end+0x1>
     368:	02 e0       	ldi	r16, 0x02	; 2
     36a:	45 e5       	ldi	r20, 0x55	; 85
     36c:	50 e0       	ldi	r21, 0x00	; 0
     36e:	6e e0       	ldi	r22, 0x0E	; 14
     370:	71 e0       	ldi	r23, 0x01	; 1
     372:	86 e8       	ldi	r24, 0x86	; 134
     374:	91 e0       	ldi	r25, 0x01	; 1
     376:	0e 94 1f 07 	call	0xe3e	; 0xe3e <xTaskCreate>
	vSemaphoreCreateBinary(sem_handel_1);
     37a:	43 e0       	ldi	r20, 0x03	; 3
     37c:	60 e0       	ldi	r22, 0x00	; 0
     37e:	81 e0       	ldi	r24, 0x01	; 1
     380:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <xQueueGenericCreate>
     384:	90 93 ac 01 	sts	0x01AC, r25	; 0x8001ac <sem_handel_1+0x1>
     388:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <sem_handel_1>
     38c:	00 97       	sbiw	r24, 0x00	; 0
     38e:	39 f0       	breq	.+14     	; 0x39e <main+0x66>
     390:	20 e0       	ldi	r18, 0x00	; 0
     392:	40 e0       	ldi	r20, 0x00	; 0
     394:	50 e0       	ldi	r21, 0x00	; 0
     396:	60 e0       	ldi	r22, 0x00	; 0
     398:	70 e0       	ldi	r23, 0x00	; 0
     39a:	0e 94 0e 04 	call	0x81c	; 0x81c <xQueueGenericSend>
	vTaskStartScheduler();
     39e:	0e 94 3b 08 	call	0x1076	; 0x1076 <vTaskStartScheduler>
     3a2:	ff cf       	rjmp	.-2      	; 0x3a2 <main+0x6a>

000003a4 <pxPortInitialiseStack>:
{
    portSAVE_CONTEXT();
    vTaskSwitchContext();
    portRESTORE_CONTEXT();

    __asm__ __volatile__ ( "reti" );
     3a4:	fc 01       	movw	r30, r24
     3a6:	60 83       	st	Z, r22
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	70 83       	st	Z, r23
     3ac:	31 97       	sbiw	r30, 0x01	; 1
     3ae:	10 82       	st	Z, r1
     3b0:	31 97       	sbiw	r30, 0x01	; 1
     3b2:	20 e8       	ldi	r18, 0x80	; 128
     3b4:	20 83       	st	Z, r18
     3b6:	31 97       	sbiw	r30, 0x01	; 1
     3b8:	10 82       	st	Z, r1
     3ba:	77 97       	sbiw	r30, 0x17	; 23
     3bc:	40 83       	st	Z, r20
     3be:	31 97       	sbiw	r30, 0x01	; 1
     3c0:	50 83       	st	Z, r21
     3c2:	83 97       	sbiw	r24, 0x23	; 35
     3c4:	08 95       	ret

000003c6 <xPortStartScheduler>:
     3c6:	a8 95       	wdr
     3c8:	90 ec       	ldi	r25, 0xC0	; 192
     3ca:	88 e1       	ldi	r24, 0x18	; 24
     3cc:	0f b6       	in	r0, 0x3f	; 63
     3ce:	f8 94       	cli
     3d0:	a8 95       	wdr
     3d2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7f8060>
     3d6:	0f be       	out	0x3f, r0	; 63
     3d8:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7f8060>
     3dc:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
     3e0:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     3e4:	cd 91       	ld	r28, X+
     3e6:	cd bf       	out	0x3d, r28	; 61
     3e8:	dd 91       	ld	r29, X+
     3ea:	de bf       	out	0x3e, r29	; 62
     3ec:	ff 91       	pop	r31
     3ee:	ef 91       	pop	r30
     3f0:	df 91       	pop	r29
     3f2:	cf 91       	pop	r28
     3f4:	bf 91       	pop	r27
     3f6:	af 91       	pop	r26
     3f8:	9f 91       	pop	r25
     3fa:	8f 91       	pop	r24
     3fc:	7f 91       	pop	r23
     3fe:	6f 91       	pop	r22
     400:	5f 91       	pop	r21
     402:	4f 91       	pop	r20
     404:	3f 91       	pop	r19
     406:	2f 91       	pop	r18
     408:	1f 91       	pop	r17
     40a:	0f 91       	pop	r16
     40c:	ff 90       	pop	r15
     40e:	ef 90       	pop	r14
     410:	df 90       	pop	r13
     412:	cf 90       	pop	r12
     414:	bf 90       	pop	r11
     416:	af 90       	pop	r10
     418:	9f 90       	pop	r9
     41a:	8f 90       	pop	r8
     41c:	7f 90       	pop	r7
     41e:	6f 90       	pop	r6
     420:	5f 90       	pop	r5
     422:	4f 90       	pop	r4
     424:	3f 90       	pop	r3
     426:	2f 90       	pop	r2
     428:	1f 90       	pop	r1
     42a:	0f 90       	pop	r0
     42c:	0f be       	out	0x3f, r0	; 63
     42e:	0f 90       	pop	r0
     430:	08 95       	ret
     432:	81 e0       	ldi	r24, 0x01	; 1
     434:	08 95       	ret

00000436 <vPortYield>:
     436:	0f 92       	push	r0
     438:	0f b6       	in	r0, 0x3f	; 63
     43a:	f8 94       	cli
     43c:	0f 92       	push	r0
     43e:	1f 92       	push	r1
     440:	11 24       	eor	r1, r1
     442:	2f 92       	push	r2
     444:	3f 92       	push	r3
     446:	4f 92       	push	r4
     448:	5f 92       	push	r5
     44a:	6f 92       	push	r6
     44c:	7f 92       	push	r7
     44e:	8f 92       	push	r8
     450:	9f 92       	push	r9
     452:	af 92       	push	r10
     454:	bf 92       	push	r11
     456:	cf 92       	push	r12
     458:	df 92       	push	r13
     45a:	ef 92       	push	r14
     45c:	ff 92       	push	r15
     45e:	0f 93       	push	r16
     460:	1f 93       	push	r17
     462:	2f 93       	push	r18
     464:	3f 93       	push	r19
     466:	4f 93       	push	r20
     468:	5f 93       	push	r21
     46a:	6f 93       	push	r22
     46c:	7f 93       	push	r23
     46e:	8f 93       	push	r24
     470:	9f 93       	push	r25
     472:	af 93       	push	r26
     474:	bf 93       	push	r27
     476:	cf 93       	push	r28
     478:	df 93       	push	r29
     47a:	ef 93       	push	r30
     47c:	ff 93       	push	r31
     47e:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
     482:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     486:	0d b6       	in	r0, 0x3d	; 61
     488:	0d 92       	st	X+, r0
     48a:	0e b6       	in	r0, 0x3e	; 62
     48c:	0d 92       	st	X+, r0
     48e:	0e 94 cf 09 	call	0x139e	; 0x139e <vTaskSwitchContext>
     492:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
     496:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     49a:	cd 91       	ld	r28, X+
     49c:	cd bf       	out	0x3d, r28	; 61
     49e:	dd 91       	ld	r29, X+
     4a0:	de bf       	out	0x3e, r29	; 62
     4a2:	ff 91       	pop	r31
     4a4:	ef 91       	pop	r30
     4a6:	df 91       	pop	r29
     4a8:	cf 91       	pop	r28
     4aa:	bf 91       	pop	r27
     4ac:	af 91       	pop	r26
     4ae:	9f 91       	pop	r25
     4b0:	8f 91       	pop	r24
     4b2:	7f 91       	pop	r23
     4b4:	6f 91       	pop	r22
     4b6:	5f 91       	pop	r21
     4b8:	4f 91       	pop	r20
     4ba:	3f 91       	pop	r19
     4bc:	2f 91       	pop	r18
     4be:	1f 91       	pop	r17
     4c0:	0f 91       	pop	r16
     4c2:	ff 90       	pop	r15
     4c4:	ef 90       	pop	r14
     4c6:	df 90       	pop	r13
     4c8:	cf 90       	pop	r12
     4ca:	bf 90       	pop	r11
     4cc:	af 90       	pop	r10
     4ce:	9f 90       	pop	r9
     4d0:	8f 90       	pop	r8
     4d2:	7f 90       	pop	r7
     4d4:	6f 90       	pop	r6
     4d6:	5f 90       	pop	r5
     4d8:	4f 90       	pop	r4
     4da:	3f 90       	pop	r3
     4dc:	2f 90       	pop	r2
     4de:	1f 90       	pop	r1
     4e0:	0f 90       	pop	r0
     4e2:	0f be       	out	0x3f, r0	; 63
     4e4:	0f 90       	pop	r0
     4e6:	08 95       	ret

000004e8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
     4e8:	0f 92       	push	r0
     4ea:	0f b6       	in	r0, 0x3f	; 63
     4ec:	f8 94       	cli
     4ee:	0f 92       	push	r0
     4f0:	1f 92       	push	r1
     4f2:	11 24       	eor	r1, r1
     4f4:	2f 92       	push	r2
     4f6:	3f 92       	push	r3
     4f8:	4f 92       	push	r4
     4fa:	5f 92       	push	r5
     4fc:	6f 92       	push	r6
     4fe:	7f 92       	push	r7
     500:	8f 92       	push	r8
     502:	9f 92       	push	r9
     504:	af 92       	push	r10
     506:	bf 92       	push	r11
     508:	cf 92       	push	r12
     50a:	df 92       	push	r13
     50c:	ef 92       	push	r14
     50e:	ff 92       	push	r15
     510:	0f 93       	push	r16
     512:	1f 93       	push	r17
     514:	2f 93       	push	r18
     516:	3f 93       	push	r19
     518:	4f 93       	push	r20
     51a:	5f 93       	push	r21
     51c:	6f 93       	push	r22
     51e:	7f 93       	push	r23
     520:	8f 93       	push	r24
     522:	9f 93       	push	r25
     524:	af 93       	push	r26
     526:	bf 93       	push	r27
     528:	cf 93       	push	r28
     52a:	df 93       	push	r29
     52c:	ef 93       	push	r30
     52e:	ff 93       	push	r31
     530:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
     534:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     538:	0d b6       	in	r0, 0x3d	; 61
     53a:	0d 92       	st	X+, r0
     53c:	0e b6       	in	r0, 0x3e	; 62
     53e:	0d 92       	st	X+, r0
    sleep_reset();        /* reset the sleep_mode() faster than sleep_disable(); */
     540:	13 be       	out	0x33, r1	; 51
    if( xTaskIncrementTick() != pdFALSE )
     542:	0e 94 79 08 	call	0x10f2	; 0x10f2 <xTaskIncrementTick>
     546:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
     548:	0e 94 cf 09 	call	0x139e	; 0x139e <vTaskSwitchContext>
    }
    portRESTORE_CONTEXT();
     54c:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
     550:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     554:	cd 91       	ld	r28, X+
     556:	cd bf       	out	0x3d, r28	; 61
     558:	dd 91       	ld	r29, X+
     55a:	de bf       	out	0x3e, r29	; 62
     55c:	ff 91       	pop	r31
     55e:	ef 91       	pop	r30
     560:	df 91       	pop	r29
     562:	cf 91       	pop	r28
     564:	bf 91       	pop	r27
     566:	af 91       	pop	r26
     568:	9f 91       	pop	r25
     56a:	8f 91       	pop	r24
     56c:	7f 91       	pop	r23
     56e:	6f 91       	pop	r22
     570:	5f 91       	pop	r21
     572:	4f 91       	pop	r20
     574:	3f 91       	pop	r19
     576:	2f 91       	pop	r18
     578:	1f 91       	pop	r17
     57a:	0f 91       	pop	r16
     57c:	ff 90       	pop	r15
     57e:	ef 90       	pop	r14
     580:	df 90       	pop	r13
     582:	cf 90       	pop	r12
     584:	bf 90       	pop	r11
     586:	af 90       	pop	r10
     588:	9f 90       	pop	r9
     58a:	8f 90       	pop	r8
     58c:	7f 90       	pop	r7
     58e:	6f 90       	pop	r6
     590:	5f 90       	pop	r5
     592:	4f 90       	pop	r4
     594:	3f 90       	pop	r3
     596:	2f 90       	pop	r2
     598:	1f 90       	pop	r1
     59a:	0f 90       	pop	r0
     59c:	0f be       	out	0x3f, r0	; 63
     59e:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
     5a0:	08 95       	ret

000005a2 <__vector_12>:
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
/*  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
 */
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
     5a2:	0e 94 74 02 	call	0x4e8	; 0x4e8 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
     5a6:	18 95       	reti

000005a8 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     5a8:	0f b6       	in	r0, 0x3f	; 63
     5aa:	f8 94       	cli
     5ac:	0f 92       	push	r0
     5ae:	fc 01       	movw	r30, r24
     5b0:	92 8d       	ldd	r25, Z+26	; 0x1a
     5b2:	0f 90       	pop	r0
     5b4:	0f be       	out	0x3f, r0	; 63
     5b6:	81 e0       	ldi	r24, 0x01	; 1
     5b8:	91 11       	cpse	r25, r1
     5ba:	80 e0       	ldi	r24, 0x00	; 0
     5bc:	08 95       	ret

000005be <prvCopyDataToQueue>:
     5be:	0f 93       	push	r16
     5c0:	1f 93       	push	r17
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	ec 01       	movw	r28, r24
     5c8:	04 2f       	mov	r16, r20
     5ca:	1a 8d       	ldd	r17, Y+26	; 0x1a
     5cc:	4c 8d       	ldd	r20, Y+28	; 0x1c
     5ce:	41 11       	cpse	r20, r1
     5d0:	0c c0       	rjmp	.+24     	; 0x5ea <prvCopyDataToQueue+0x2c>
     5d2:	88 81       	ld	r24, Y
     5d4:	99 81       	ldd	r25, Y+1	; 0x01
     5d6:	89 2b       	or	r24, r25
     5d8:	09 f0       	breq	.+2      	; 0x5dc <prvCopyDataToQueue+0x1e>
     5da:	42 c0       	rjmp	.+132    	; 0x660 <prvCopyDataToQueue+0xa2>
     5dc:	8c 81       	ldd	r24, Y+4	; 0x04
     5de:	9d 81       	ldd	r25, Y+5	; 0x05
     5e0:	0e 94 88 0b 	call	0x1710	; 0x1710 <xTaskPriorityDisinherit>
     5e4:	1d 82       	std	Y+5, r1	; 0x05
     5e6:	1c 82       	std	Y+4, r1	; 0x04
     5e8:	42 c0       	rjmp	.+132    	; 0x66e <prvCopyDataToQueue+0xb0>
     5ea:	01 11       	cpse	r16, r1
     5ec:	17 c0       	rjmp	.+46     	; 0x61c <prvCopyDataToQueue+0x5e>
     5ee:	50 e0       	ldi	r21, 0x00	; 0
     5f0:	8a 81       	ldd	r24, Y+2	; 0x02
     5f2:	9b 81       	ldd	r25, Y+3	; 0x03
     5f4:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <memcpy>
     5f8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     5fa:	8a 81       	ldd	r24, Y+2	; 0x02
     5fc:	9b 81       	ldd	r25, Y+3	; 0x03
     5fe:	82 0f       	add	r24, r18
     600:	91 1d       	adc	r25, r1
     602:	9b 83       	std	Y+3, r25	; 0x03
     604:	8a 83       	std	Y+2, r24	; 0x02
     606:	2c 81       	ldd	r18, Y+4	; 0x04
     608:	3d 81       	ldd	r19, Y+5	; 0x05
     60a:	82 17       	cp	r24, r18
     60c:	93 07       	cpc	r25, r19
     60e:	50 f1       	brcs	.+84     	; 0x664 <prvCopyDataToQueue+0xa6>
     610:	88 81       	ld	r24, Y
     612:	99 81       	ldd	r25, Y+1	; 0x01
     614:	9b 83       	std	Y+3, r25	; 0x03
     616:	8a 83       	std	Y+2, r24	; 0x02
     618:	80 e0       	ldi	r24, 0x00	; 0
     61a:	29 c0       	rjmp	.+82     	; 0x66e <prvCopyDataToQueue+0xb0>
     61c:	50 e0       	ldi	r21, 0x00	; 0
     61e:	8e 81       	ldd	r24, Y+6	; 0x06
     620:	9f 81       	ldd	r25, Y+7	; 0x07
     622:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <memcpy>
     626:	8c 8d       	ldd	r24, Y+28	; 0x1c
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	91 95       	neg	r25
     62c:	81 95       	neg	r24
     62e:	91 09       	sbc	r25, r1
     630:	2e 81       	ldd	r18, Y+6	; 0x06
     632:	3f 81       	ldd	r19, Y+7	; 0x07
     634:	28 0f       	add	r18, r24
     636:	39 1f       	adc	r19, r25
     638:	3f 83       	std	Y+7, r19	; 0x07
     63a:	2e 83       	std	Y+6, r18	; 0x06
     63c:	48 81       	ld	r20, Y
     63e:	59 81       	ldd	r21, Y+1	; 0x01
     640:	24 17       	cp	r18, r20
     642:	35 07       	cpc	r19, r21
     644:	30 f4       	brcc	.+12     	; 0x652 <prvCopyDataToQueue+0x94>
     646:	2c 81       	ldd	r18, Y+4	; 0x04
     648:	3d 81       	ldd	r19, Y+5	; 0x05
     64a:	82 0f       	add	r24, r18
     64c:	93 1f       	adc	r25, r19
     64e:	9f 83       	std	Y+7, r25	; 0x07
     650:	8e 83       	std	Y+6, r24	; 0x06
     652:	02 30       	cpi	r16, 0x02	; 2
     654:	49 f4       	brne	.+18     	; 0x668 <prvCopyDataToQueue+0xaa>
     656:	11 23       	and	r17, r17
     658:	49 f0       	breq	.+18     	; 0x66c <prvCopyDataToQueue+0xae>
     65a:	11 50       	subi	r17, 0x01	; 1
     65c:	80 e0       	ldi	r24, 0x00	; 0
     65e:	07 c0       	rjmp	.+14     	; 0x66e <prvCopyDataToQueue+0xb0>
     660:	80 e0       	ldi	r24, 0x00	; 0
     662:	05 c0       	rjmp	.+10     	; 0x66e <prvCopyDataToQueue+0xb0>
     664:	80 e0       	ldi	r24, 0x00	; 0
     666:	03 c0       	rjmp	.+6      	; 0x66e <prvCopyDataToQueue+0xb0>
     668:	80 e0       	ldi	r24, 0x00	; 0
     66a:	01 c0       	rjmp	.+2      	; 0x66e <prvCopyDataToQueue+0xb0>
     66c:	80 e0       	ldi	r24, 0x00	; 0
     66e:	1f 5f       	subi	r17, 0xFF	; 255
     670:	1a 8f       	std	Y+26, r17	; 0x1a
     672:	df 91       	pop	r29
     674:	cf 91       	pop	r28
     676:	1f 91       	pop	r17
     678:	0f 91       	pop	r16
     67a:	08 95       	ret

0000067c <prvCopyDataFromQueue>:
     67c:	fc 01       	movw	r30, r24
     67e:	44 8d       	ldd	r20, Z+28	; 0x1c
     680:	44 23       	and	r20, r20
     682:	a9 f0       	breq	.+42     	; 0x6ae <prvCopyDataFromQueue+0x32>
     684:	50 e0       	ldi	r21, 0x00	; 0
     686:	26 81       	ldd	r18, Z+6	; 0x06
     688:	37 81       	ldd	r19, Z+7	; 0x07
     68a:	24 0f       	add	r18, r20
     68c:	35 1f       	adc	r19, r21
     68e:	37 83       	std	Z+7, r19	; 0x07
     690:	26 83       	std	Z+6, r18	; 0x06
     692:	84 81       	ldd	r24, Z+4	; 0x04
     694:	95 81       	ldd	r25, Z+5	; 0x05
     696:	28 17       	cp	r18, r24
     698:	39 07       	cpc	r19, r25
     69a:	20 f0       	brcs	.+8      	; 0x6a4 <prvCopyDataFromQueue+0x28>
     69c:	80 81       	ld	r24, Z
     69e:	91 81       	ldd	r25, Z+1	; 0x01
     6a0:	97 83       	std	Z+7, r25	; 0x07
     6a2:	86 83       	std	Z+6, r24	; 0x06
     6a4:	cb 01       	movw	r24, r22
     6a6:	66 81       	ldd	r22, Z+6	; 0x06
     6a8:	77 81       	ldd	r23, Z+7	; 0x07
     6aa:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <memcpy>
     6ae:	08 95       	ret

000006b0 <prvUnlockQueue>:
     6b0:	ef 92       	push	r14
     6b2:	ff 92       	push	r15
     6b4:	0f 93       	push	r16
     6b6:	1f 93       	push	r17
     6b8:	cf 93       	push	r28
     6ba:	8c 01       	movw	r16, r24
     6bc:	0f b6       	in	r0, 0x3f	; 63
     6be:	f8 94       	cli
     6c0:	0f 92       	push	r0
     6c2:	fc 01       	movw	r30, r24
     6c4:	c6 8d       	ldd	r28, Z+30	; 0x1e
     6c6:	1c 16       	cp	r1, r28
     6c8:	ac f4       	brge	.+42     	; 0x6f4 <prvUnlockQueue+0x44>
     6ca:	81 89       	ldd	r24, Z+17	; 0x11
     6cc:	81 11       	cpse	r24, r1
     6ce:	06 c0       	rjmp	.+12     	; 0x6dc <prvUnlockQueue+0x2c>
     6d0:	11 c0       	rjmp	.+34     	; 0x6f4 <prvUnlockQueue+0x44>
     6d2:	f8 01       	movw	r30, r16
     6d4:	81 89       	ldd	r24, Z+17	; 0x11
     6d6:	81 11       	cpse	r24, r1
     6d8:	05 c0       	rjmp	.+10     	; 0x6e4 <prvUnlockQueue+0x34>
     6da:	0c c0       	rjmp	.+24     	; 0x6f4 <prvUnlockQueue+0x44>
     6dc:	78 01       	movw	r14, r16
     6de:	f1 e1       	ldi	r31, 0x11	; 17
     6e0:	ef 0e       	add	r14, r31
     6e2:	f1 1c       	adc	r15, r1
     6e4:	c7 01       	movw	r24, r14
     6e6:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskRemoveFromEventList>
     6ea:	81 11       	cpse	r24, r1
     6ec:	0e 94 04 0b 	call	0x1608	; 0x1608 <vTaskMissedYield>
     6f0:	c1 50       	subi	r28, 0x01	; 1
     6f2:	79 f7       	brne	.-34     	; 0x6d2 <prvUnlockQueue+0x22>
     6f4:	8f ef       	ldi	r24, 0xFF	; 255
     6f6:	f8 01       	movw	r30, r16
     6f8:	86 8f       	std	Z+30, r24	; 0x1e
     6fa:	0f 90       	pop	r0
     6fc:	0f be       	out	0x3f, r0	; 63
     6fe:	0f b6       	in	r0, 0x3f	; 63
     700:	f8 94       	cli
     702:	0f 92       	push	r0
     704:	c5 8d       	ldd	r28, Z+29	; 0x1d
     706:	1c 16       	cp	r1, r28
     708:	ac f4       	brge	.+42     	; 0x734 <prvUnlockQueue+0x84>
     70a:	80 85       	ldd	r24, Z+8	; 0x08
     70c:	81 11       	cpse	r24, r1
     70e:	06 c0       	rjmp	.+12     	; 0x71c <prvUnlockQueue+0x6c>
     710:	11 c0       	rjmp	.+34     	; 0x734 <prvUnlockQueue+0x84>
     712:	f8 01       	movw	r30, r16
     714:	80 85       	ldd	r24, Z+8	; 0x08
     716:	81 11       	cpse	r24, r1
     718:	05 c0       	rjmp	.+10     	; 0x724 <prvUnlockQueue+0x74>
     71a:	0c c0       	rjmp	.+24     	; 0x734 <prvUnlockQueue+0x84>
     71c:	78 01       	movw	r14, r16
     71e:	f8 e0       	ldi	r31, 0x08	; 8
     720:	ef 0e       	add	r14, r31
     722:	f1 1c       	adc	r15, r1
     724:	c7 01       	movw	r24, r14
     726:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskRemoveFromEventList>
     72a:	81 11       	cpse	r24, r1
     72c:	0e 94 04 0b 	call	0x1608	; 0x1608 <vTaskMissedYield>
     730:	c1 50       	subi	r28, 0x01	; 1
     732:	79 f7       	brne	.-34     	; 0x712 <prvUnlockQueue+0x62>
     734:	8f ef       	ldi	r24, 0xFF	; 255
     736:	f8 01       	movw	r30, r16
     738:	85 8f       	std	Z+29, r24	; 0x1d
     73a:	0f 90       	pop	r0
     73c:	0f be       	out	0x3f, r0	; 63
     73e:	cf 91       	pop	r28
     740:	1f 91       	pop	r17
     742:	0f 91       	pop	r16
     744:	ff 90       	pop	r15
     746:	ef 90       	pop	r14
     748:	08 95       	ret

0000074a <xQueueGenericReset>:
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	ec 01       	movw	r28, r24
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	f8 94       	cli
     754:	0f 92       	push	r0
     756:	e8 81       	ld	r30, Y
     758:	f9 81       	ldd	r31, Y+1	; 0x01
     75a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     75c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	30 e0       	ldi	r19, 0x00	; 0
     762:	82 9f       	mul	r24, r18
     764:	a0 01       	movw	r20, r0
     766:	83 9f       	mul	r24, r19
     768:	50 0d       	add	r21, r0
     76a:	92 9f       	mul	r25, r18
     76c:	50 0d       	add	r21, r0
     76e:	11 24       	eor	r1, r1
     770:	4e 0f       	add	r20, r30
     772:	5f 1f       	adc	r21, r31
     774:	5d 83       	std	Y+5, r21	; 0x05
     776:	4c 83       	std	Y+4, r20	; 0x04
     778:	1a 8e       	std	Y+26, r1	; 0x1a
     77a:	fb 83       	std	Y+3, r31	; 0x03
     77c:	ea 83       	std	Y+2, r30	; 0x02
     77e:	01 97       	sbiw	r24, 0x01	; 1
     780:	82 9f       	mul	r24, r18
     782:	a0 01       	movw	r20, r0
     784:	83 9f       	mul	r24, r19
     786:	50 0d       	add	r21, r0
     788:	92 9f       	mul	r25, r18
     78a:	50 0d       	add	r21, r0
     78c:	11 24       	eor	r1, r1
     78e:	cf 01       	movw	r24, r30
     790:	84 0f       	add	r24, r20
     792:	95 1f       	adc	r25, r21
     794:	9f 83       	std	Y+7, r25	; 0x07
     796:	8e 83       	std	Y+6, r24	; 0x06
     798:	8f ef       	ldi	r24, 0xFF	; 255
     79a:	8d 8f       	std	Y+29, r24	; 0x1d
     79c:	8e 8f       	std	Y+30, r24	; 0x1e
     79e:	61 11       	cpse	r22, r1
     7a0:	0c c0       	rjmp	.+24     	; 0x7ba <xQueueGenericReset+0x70>
     7a2:	88 85       	ldd	r24, Y+8	; 0x08
     7a4:	88 23       	and	r24, r24
     7a6:	89 f0       	breq	.+34     	; 0x7ca <xQueueGenericReset+0x80>
     7a8:	ce 01       	movw	r24, r28
     7aa:	08 96       	adiw	r24, 0x08	; 8
     7ac:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskRemoveFromEventList>
     7b0:	88 23       	and	r24, r24
     7b2:	59 f0       	breq	.+22     	; 0x7ca <xQueueGenericReset+0x80>
     7b4:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     7b8:	08 c0       	rjmp	.+16     	; 0x7ca <xQueueGenericReset+0x80>
     7ba:	ce 01       	movw	r24, r28
     7bc:	08 96       	adiw	r24, 0x08	; 8
     7be:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     7c2:	ce 01       	movw	r24, r28
     7c4:	41 96       	adiw	r24, 0x11	; 17
     7c6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     7ca:	0f 90       	pop	r0
     7cc:	0f be       	out	0x3f, r0	; 63
     7ce:	81 e0       	ldi	r24, 0x01	; 1
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	08 95       	ret

000007d6 <xQueueGenericCreate>:
     7d6:	0f 93       	push	r16
     7d8:	1f 93       	push	r17
     7da:	cf 93       	push	r28
     7dc:	df 93       	push	r29
     7de:	08 2f       	mov	r16, r24
     7e0:	16 2f       	mov	r17, r22
     7e2:	86 9f       	mul	r24, r22
     7e4:	c0 01       	movw	r24, r0
     7e6:	11 24       	eor	r1, r1
     7e8:	4f 96       	adiw	r24, 0x1f	; 31
     7ea:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     7ee:	ec 01       	movw	r28, r24
     7f0:	00 97       	sbiw	r24, 0x00	; 0
     7f2:	71 f0       	breq	.+28     	; 0x810 <xQueueGenericCreate+0x3a>
     7f4:	11 11       	cpse	r17, r1
     7f6:	03 c0       	rjmp	.+6      	; 0x7fe <xQueueGenericCreate+0x28>
     7f8:	99 83       	std	Y+1, r25	; 0x01
     7fa:	88 83       	st	Y, r24
     7fc:	03 c0       	rjmp	.+6      	; 0x804 <xQueueGenericCreate+0x2e>
     7fe:	4f 96       	adiw	r24, 0x1f	; 31
     800:	99 83       	std	Y+1, r25	; 0x01
     802:	88 83       	st	Y, r24
     804:	0b 8f       	std	Y+27, r16	; 0x1b
     806:	1c 8f       	std	Y+28, r17	; 0x1c
     808:	61 e0       	ldi	r22, 0x01	; 1
     80a:	ce 01       	movw	r24, r28
     80c:	0e 94 a5 03 	call	0x74a	; 0x74a <xQueueGenericReset>
     810:	ce 01       	movw	r24, r28
     812:	df 91       	pop	r29
     814:	cf 91       	pop	r28
     816:	1f 91       	pop	r17
     818:	0f 91       	pop	r16
     81a:	08 95       	ret

0000081c <xQueueGenericSend>:
     81c:	9f 92       	push	r9
     81e:	af 92       	push	r10
     820:	bf 92       	push	r11
     822:	cf 92       	push	r12
     824:	df 92       	push	r13
     826:	ef 92       	push	r14
     828:	ff 92       	push	r15
     82a:	0f 93       	push	r16
     82c:	1f 93       	push	r17
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	00 d0       	rcall	.+0      	; 0x834 <xQueueGenericSend+0x18>
     834:	00 d0       	rcall	.+0      	; 0x836 <xQueueGenericSend+0x1a>
     836:	1f 92       	push	r1
     838:	cd b7       	in	r28, 0x3d	; 61
     83a:	de b7       	in	r29, 0x3e	; 62
     83c:	8c 01       	movw	r16, r24
     83e:	6b 01       	movw	r12, r22
     840:	5d 83       	std	Y+5, r21	; 0x05
     842:	4c 83       	std	Y+4, r20	; 0x04
     844:	a2 2e       	mov	r10, r18
     846:	b1 2c       	mov	r11, r1
     848:	99 24       	eor	r9, r9
     84a:	93 94       	inc	r9
     84c:	7c 01       	movw	r14, r24
     84e:	88 e0       	ldi	r24, 0x08	; 8
     850:	e8 0e       	add	r14, r24
     852:	f1 1c       	adc	r15, r1
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	f8 94       	cli
     858:	0f 92       	push	r0
     85a:	f8 01       	movw	r30, r16
     85c:	92 8d       	ldd	r25, Z+26	; 0x1a
     85e:	83 8d       	ldd	r24, Z+27	; 0x1b
     860:	98 17       	cp	r25, r24
     862:	18 f0       	brcs	.+6      	; 0x86a <xQueueGenericSend+0x4e>
     864:	f2 e0       	ldi	r31, 0x02	; 2
     866:	af 12       	cpse	r10, r31
     868:	19 c0       	rjmp	.+50     	; 0x89c <xQueueGenericSend+0x80>
     86a:	4a 2d       	mov	r20, r10
     86c:	b6 01       	movw	r22, r12
     86e:	c8 01       	movw	r24, r16
     870:	0e 94 df 02 	call	0x5be	; 0x5be <prvCopyDataToQueue>
     874:	f8 01       	movw	r30, r16
     876:	91 89       	ldd	r25, Z+17	; 0x11
     878:	99 23       	and	r25, r25
     87a:	49 f0       	breq	.+18     	; 0x88e <xQueueGenericSend+0x72>
     87c:	c8 01       	movw	r24, r16
     87e:	41 96       	adiw	r24, 0x11	; 17
     880:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskRemoveFromEventList>
     884:	88 23       	and	r24, r24
     886:	31 f0       	breq	.+12     	; 0x894 <xQueueGenericSend+0x78>
     888:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     88c:	03 c0       	rjmp	.+6      	; 0x894 <xQueueGenericSend+0x78>
     88e:	81 11       	cpse	r24, r1
     890:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     894:	0f 90       	pop	r0
     896:	0f be       	out	0x3f, r0	; 63
     898:	81 e0       	ldi	r24, 0x01	; 1
     89a:	50 c0       	rjmp	.+160    	; 0x93c <xQueueGenericSend+0x120>
     89c:	8c 81       	ldd	r24, Y+4	; 0x04
     89e:	9d 81       	ldd	r25, Y+5	; 0x05
     8a0:	89 2b       	or	r24, r25
     8a2:	21 f4       	brne	.+8      	; 0x8ac <xQueueGenericSend+0x90>
     8a4:	0f 90       	pop	r0
     8a6:	0f be       	out	0x3f, r0	; 63
     8a8:	80 e0       	ldi	r24, 0x00	; 0
     8aa:	48 c0       	rjmp	.+144    	; 0x93c <xQueueGenericSend+0x120>
     8ac:	b1 10       	cpse	r11, r1
     8ae:	05 c0       	rjmp	.+10     	; 0x8ba <xQueueGenericSend+0x9e>
     8b0:	ce 01       	movw	r24, r28
     8b2:	01 96       	adiw	r24, 0x01	; 1
     8b4:	0e 94 c3 0a 	call	0x1586	; 0x1586 <vTaskInternalSetTimeOutState>
     8b8:	b9 2c       	mov	r11, r9
     8ba:	0f 90       	pop	r0
     8bc:	0f be       	out	0x3f, r0	; 63
     8be:	0e 94 69 08 	call	0x10d2	; 0x10d2 <vTaskSuspendAll>
     8c2:	0f b6       	in	r0, 0x3f	; 63
     8c4:	f8 94       	cli
     8c6:	0f 92       	push	r0
     8c8:	f8 01       	movw	r30, r16
     8ca:	85 8d       	ldd	r24, Z+29	; 0x1d
     8cc:	8f 3f       	cpi	r24, 0xFF	; 255
     8ce:	09 f4       	brne	.+2      	; 0x8d2 <xQueueGenericSend+0xb6>
     8d0:	15 8e       	std	Z+29, r1	; 0x1d
     8d2:	f8 01       	movw	r30, r16
     8d4:	86 8d       	ldd	r24, Z+30	; 0x1e
     8d6:	8f 3f       	cpi	r24, 0xFF	; 255
     8d8:	09 f4       	brne	.+2      	; 0x8dc <xQueueGenericSend+0xc0>
     8da:	16 8e       	std	Z+30, r1	; 0x1e
     8dc:	0f 90       	pop	r0
     8de:	0f be       	out	0x3f, r0	; 63
     8e0:	be 01       	movw	r22, r28
     8e2:	6c 5f       	subi	r22, 0xFC	; 252
     8e4:	7f 4f       	sbci	r23, 0xFF	; 255
     8e6:	ce 01       	movw	r24, r28
     8e8:	01 96       	adiw	r24, 0x01	; 1
     8ea:	0e 94 ce 0a 	call	0x159c	; 0x159c <xTaskCheckForTimeOut>
     8ee:	81 11       	cpse	r24, r1
     8f0:	1f c0       	rjmp	.+62     	; 0x930 <xQueueGenericSend+0x114>
     8f2:	0f b6       	in	r0, 0x3f	; 63
     8f4:	f8 94       	cli
     8f6:	0f 92       	push	r0
     8f8:	f8 01       	movw	r30, r16
     8fa:	92 8d       	ldd	r25, Z+26	; 0x1a
     8fc:	83 8d       	ldd	r24, Z+27	; 0x1b
     8fe:	0f 90       	pop	r0
     900:	0f be       	out	0x3f, r0	; 63
     902:	98 13       	cpse	r25, r24
     904:	0f c0       	rjmp	.+30     	; 0x924 <xQueueGenericSend+0x108>
     906:	6c 81       	ldd	r22, Y+4	; 0x04
     908:	7d 81       	ldd	r23, Y+5	; 0x05
     90a:	c7 01       	movw	r24, r14
     90c:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <vTaskPlaceOnEventList>
     910:	c8 01       	movw	r24, r16
     912:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     916:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     91a:	81 11       	cpse	r24, r1
     91c:	9b cf       	rjmp	.-202    	; 0x854 <xQueueGenericSend+0x38>
     91e:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     922:	98 cf       	rjmp	.-208    	; 0x854 <xQueueGenericSend+0x38>
     924:	c8 01       	movw	r24, r16
     926:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     92a:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     92e:	92 cf       	rjmp	.-220    	; 0x854 <xQueueGenericSend+0x38>
     930:	c8 01       	movw	r24, r16
     932:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     936:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     93a:	80 e0       	ldi	r24, 0x00	; 0
     93c:	0f 90       	pop	r0
     93e:	0f 90       	pop	r0
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	0f 90       	pop	r0
     946:	df 91       	pop	r29
     948:	cf 91       	pop	r28
     94a:	1f 91       	pop	r17
     94c:	0f 91       	pop	r16
     94e:	ff 90       	pop	r15
     950:	ef 90       	pop	r14
     952:	df 90       	pop	r13
     954:	cf 90       	pop	r12
     956:	bf 90       	pop	r11
     958:	af 90       	pop	r10
     95a:	9f 90       	pop	r9
     95c:	08 95       	ret

0000095e <xQueueGenericSendFromISR>:
     95e:	ef 92       	push	r14
     960:	ff 92       	push	r15
     962:	0f 93       	push	r16
     964:	1f 93       	push	r17
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
     96a:	8a 01       	movw	r16, r20
     96c:	fc 01       	movw	r30, r24
     96e:	52 8d       	ldd	r21, Z+26	; 0x1a
     970:	33 8d       	ldd	r19, Z+27	; 0x1b
     972:	53 17       	cp	r21, r19
     974:	10 f0       	brcs	.+4      	; 0x97a <xQueueGenericSendFromISR+0x1c>
     976:	22 30       	cpi	r18, 0x02	; 2
     978:	01 f5       	brne	.+64     	; 0x9ba <xQueueGenericSendFromISR+0x5c>
     97a:	42 2f       	mov	r20, r18
     97c:	78 01       	movw	r14, r16
     97e:	ec 01       	movw	r28, r24
     980:	1e 8d       	ldd	r17, Y+30	; 0x1e
     982:	8a 8d       	ldd	r24, Y+26	; 0x1a
     984:	ce 01       	movw	r24, r28
     986:	0e 94 df 02 	call	0x5be	; 0x5be <prvCopyDataToQueue>
     98a:	1f 3f       	cpi	r17, 0xFF	; 255
     98c:	81 f4       	brne	.+32     	; 0x9ae <xQueueGenericSendFromISR+0x50>
     98e:	89 89       	ldd	r24, Y+17	; 0x11
     990:	88 23       	and	r24, r24
     992:	a9 f0       	breq	.+42     	; 0x9be <xQueueGenericSendFromISR+0x60>
     994:	ce 01       	movw	r24, r28
     996:	41 96       	adiw	r24, 0x11	; 17
     998:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskRemoveFromEventList>
     99c:	88 23       	and	r24, r24
     99e:	89 f0       	breq	.+34     	; 0x9c2 <xQueueGenericSendFromISR+0x64>
     9a0:	e1 14       	cp	r14, r1
     9a2:	f1 04       	cpc	r15, r1
     9a4:	81 f0       	breq	.+32     	; 0x9c6 <xQueueGenericSendFromISR+0x68>
     9a6:	81 e0       	ldi	r24, 0x01	; 1
     9a8:	f7 01       	movw	r30, r14
     9aa:	80 83       	st	Z, r24
     9ac:	0d c0       	rjmp	.+26     	; 0x9c8 <xQueueGenericSendFromISR+0x6a>
     9ae:	ff 24       	eor	r15, r15
     9b0:	f3 94       	inc	r15
     9b2:	f1 0e       	add	r15, r17
     9b4:	fe 8e       	std	Y+30, r15	; 0x1e
     9b6:	81 e0       	ldi	r24, 0x01	; 1
     9b8:	07 c0       	rjmp	.+14     	; 0x9c8 <xQueueGenericSendFromISR+0x6a>
     9ba:	80 e0       	ldi	r24, 0x00	; 0
     9bc:	05 c0       	rjmp	.+10     	; 0x9c8 <xQueueGenericSendFromISR+0x6a>
     9be:	81 e0       	ldi	r24, 0x01	; 1
     9c0:	03 c0       	rjmp	.+6      	; 0x9c8 <xQueueGenericSendFromISR+0x6a>
     9c2:	81 e0       	ldi	r24, 0x01	; 1
     9c4:	01 c0       	rjmp	.+2      	; 0x9c8 <xQueueGenericSendFromISR+0x6a>
     9c6:	81 e0       	ldi	r24, 0x01	; 1
     9c8:	df 91       	pop	r29
     9ca:	cf 91       	pop	r28
     9cc:	1f 91       	pop	r17
     9ce:	0f 91       	pop	r16
     9d0:	ff 90       	pop	r15
     9d2:	ef 90       	pop	r14
     9d4:	08 95       	ret

000009d6 <xQueueReceive>:
     9d6:	9f 92       	push	r9
     9d8:	af 92       	push	r10
     9da:	bf 92       	push	r11
     9dc:	cf 92       	push	r12
     9de:	df 92       	push	r13
     9e0:	ef 92       	push	r14
     9e2:	ff 92       	push	r15
     9e4:	0f 93       	push	r16
     9e6:	1f 93       	push	r17
     9e8:	cf 93       	push	r28
     9ea:	df 93       	push	r29
     9ec:	00 d0       	rcall	.+0      	; 0x9ee <xQueueReceive+0x18>
     9ee:	00 d0       	rcall	.+0      	; 0x9f0 <xQueueReceive+0x1a>
     9f0:	1f 92       	push	r1
     9f2:	cd b7       	in	r28, 0x3d	; 61
     9f4:	de b7       	in	r29, 0x3e	; 62
     9f6:	8c 01       	movw	r16, r24
     9f8:	5b 01       	movw	r10, r22
     9fa:	5d 83       	std	Y+5, r21	; 0x05
     9fc:	4c 83       	std	Y+4, r20	; 0x04
     9fe:	e1 2c       	mov	r14, r1
     a00:	99 24       	eor	r9, r9
     a02:	93 94       	inc	r9
     a04:	6c 01       	movw	r12, r24
     a06:	81 e1       	ldi	r24, 0x11	; 17
     a08:	c8 0e       	add	r12, r24
     a0a:	d1 1c       	adc	r13, r1
     a0c:	0f b6       	in	r0, 0x3f	; 63
     a0e:	f8 94       	cli
     a10:	0f 92       	push	r0
     a12:	f8 01       	movw	r30, r16
     a14:	f2 8c       	ldd	r15, Z+26	; 0x1a
     a16:	ff 20       	and	r15, r15
     a18:	a9 f0       	breq	.+42     	; 0xa44 <__DATA_REGION_LENGTH__+0x44>
     a1a:	b5 01       	movw	r22, r10
     a1c:	c8 01       	movw	r24, r16
     a1e:	0e 94 3e 03 	call	0x67c	; 0x67c <prvCopyDataFromQueue>
     a22:	fa 94       	dec	r15
     a24:	f8 01       	movw	r30, r16
     a26:	f2 8e       	std	Z+26, r15	; 0x1a
     a28:	80 85       	ldd	r24, Z+8	; 0x08
     a2a:	88 23       	and	r24, r24
     a2c:	39 f0       	breq	.+14     	; 0xa3c <__DATA_REGION_LENGTH__+0x3c>
     a2e:	c8 01       	movw	r24, r16
     a30:	08 96       	adiw	r24, 0x08	; 8
     a32:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskRemoveFromEventList>
     a36:	81 11       	cpse	r24, r1
     a38:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     a3c:	0f 90       	pop	r0
     a3e:	0f be       	out	0x3f, r0	; 63
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	51 c0       	rjmp	.+162    	; 0xae6 <__DATA_REGION_LENGTH__+0xe6>
     a44:	8c 81       	ldd	r24, Y+4	; 0x04
     a46:	9d 81       	ldd	r25, Y+5	; 0x05
     a48:	89 2b       	or	r24, r25
     a4a:	21 f4       	brne	.+8      	; 0xa54 <__DATA_REGION_LENGTH__+0x54>
     a4c:	0f 90       	pop	r0
     a4e:	0f be       	out	0x3f, r0	; 63
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	49 c0       	rjmp	.+146    	; 0xae6 <__DATA_REGION_LENGTH__+0xe6>
     a54:	e1 10       	cpse	r14, r1
     a56:	05 c0       	rjmp	.+10     	; 0xa62 <__DATA_REGION_LENGTH__+0x62>
     a58:	ce 01       	movw	r24, r28
     a5a:	01 96       	adiw	r24, 0x01	; 1
     a5c:	0e 94 c3 0a 	call	0x1586	; 0x1586 <vTaskInternalSetTimeOutState>
     a60:	e9 2c       	mov	r14, r9
     a62:	0f 90       	pop	r0
     a64:	0f be       	out	0x3f, r0	; 63
     a66:	0e 94 69 08 	call	0x10d2	; 0x10d2 <vTaskSuspendAll>
     a6a:	0f b6       	in	r0, 0x3f	; 63
     a6c:	f8 94       	cli
     a6e:	0f 92       	push	r0
     a70:	f8 01       	movw	r30, r16
     a72:	85 8d       	ldd	r24, Z+29	; 0x1d
     a74:	8f 3f       	cpi	r24, 0xFF	; 255
     a76:	09 f4       	brne	.+2      	; 0xa7a <__DATA_REGION_LENGTH__+0x7a>
     a78:	15 8e       	std	Z+29, r1	; 0x1d
     a7a:	f8 01       	movw	r30, r16
     a7c:	86 8d       	ldd	r24, Z+30	; 0x1e
     a7e:	8f 3f       	cpi	r24, 0xFF	; 255
     a80:	09 f4       	brne	.+2      	; 0xa84 <__DATA_REGION_LENGTH__+0x84>
     a82:	16 8e       	std	Z+30, r1	; 0x1e
     a84:	0f 90       	pop	r0
     a86:	0f be       	out	0x3f, r0	; 63
     a88:	be 01       	movw	r22, r28
     a8a:	6c 5f       	subi	r22, 0xFC	; 252
     a8c:	7f 4f       	sbci	r23, 0xFF	; 255
     a8e:	ce 01       	movw	r24, r28
     a90:	01 96       	adiw	r24, 0x01	; 1
     a92:	0e 94 ce 0a 	call	0x159c	; 0x159c <xTaskCheckForTimeOut>
     a96:	81 11       	cpse	r24, r1
     a98:	1a c0       	rjmp	.+52     	; 0xace <__DATA_REGION_LENGTH__+0xce>
     a9a:	c8 01       	movw	r24, r16
     a9c:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <prvIsQueueEmpty>
     aa0:	88 23       	and	r24, r24
     aa2:	79 f0       	breq	.+30     	; 0xac2 <__DATA_REGION_LENGTH__+0xc2>
     aa4:	6c 81       	ldd	r22, Y+4	; 0x04
     aa6:	7d 81       	ldd	r23, Y+5	; 0x05
     aa8:	c6 01       	movw	r24, r12
     aaa:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <vTaskPlaceOnEventList>
     aae:	c8 01       	movw	r24, r16
     ab0:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     ab4:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     ab8:	81 11       	cpse	r24, r1
     aba:	a8 cf       	rjmp	.-176    	; 0xa0c <__DATA_REGION_LENGTH__+0xc>
     abc:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     ac0:	a5 cf       	rjmp	.-182    	; 0xa0c <__DATA_REGION_LENGTH__+0xc>
     ac2:	c8 01       	movw	r24, r16
     ac4:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     ac8:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     acc:	9f cf       	rjmp	.-194    	; 0xa0c <__DATA_REGION_LENGTH__+0xc>
     ace:	c8 01       	movw	r24, r16
     ad0:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     ad4:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     ad8:	c8 01       	movw	r24, r16
     ada:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <prvIsQueueEmpty>
     ade:	88 23       	and	r24, r24
     ae0:	09 f4       	brne	.+2      	; 0xae4 <__DATA_REGION_LENGTH__+0xe4>
     ae2:	94 cf       	rjmp	.-216    	; 0xa0c <__DATA_REGION_LENGTH__+0xc>
     ae4:	80 e0       	ldi	r24, 0x00	; 0
     ae6:	0f 90       	pop	r0
     ae8:	0f 90       	pop	r0
     aea:	0f 90       	pop	r0
     aec:	0f 90       	pop	r0
     aee:	0f 90       	pop	r0
     af0:	df 91       	pop	r29
     af2:	cf 91       	pop	r28
     af4:	1f 91       	pop	r17
     af6:	0f 91       	pop	r16
     af8:	ff 90       	pop	r15
     afa:	ef 90       	pop	r14
     afc:	df 90       	pop	r13
     afe:	cf 90       	pop	r12
     b00:	bf 90       	pop	r11
     b02:	af 90       	pop	r10
     b04:	9f 90       	pop	r9
     b06:	08 95       	ret

00000b08 <xQueueSemaphoreTake>:
     b08:	bf 92       	push	r11
     b0a:	cf 92       	push	r12
     b0c:	df 92       	push	r13
     b0e:	ef 92       	push	r14
     b10:	ff 92       	push	r15
     b12:	0f 93       	push	r16
     b14:	1f 93       	push	r17
     b16:	cf 93       	push	r28
     b18:	df 93       	push	r29
     b1a:	00 d0       	rcall	.+0      	; 0xb1c <xQueueSemaphoreTake+0x14>
     b1c:	00 d0       	rcall	.+0      	; 0xb1e <xQueueSemaphoreTake+0x16>
     b1e:	1f 92       	push	r1
     b20:	cd b7       	in	r28, 0x3d	; 61
     b22:	de b7       	in	r29, 0x3e	; 62
     b24:	8c 01       	movw	r16, r24
     b26:	7d 83       	std	Y+5, r23	; 0x05
     b28:	6c 83       	std	Y+4, r22	; 0x04
     b2a:	b1 2c       	mov	r11, r1
     b2c:	d1 2c       	mov	r13, r1
     b2e:	cc 24       	eor	r12, r12
     b30:	c3 94       	inc	r12
     b32:	7c 01       	movw	r14, r24
     b34:	81 e1       	ldi	r24, 0x11	; 17
     b36:	e8 0e       	add	r14, r24
     b38:	f1 1c       	adc	r15, r1
     b3a:	0f b6       	in	r0, 0x3f	; 63
     b3c:	f8 94       	cli
     b3e:	0f 92       	push	r0
     b40:	d8 01       	movw	r26, r16
     b42:	5a 96       	adiw	r26, 0x1a	; 26
     b44:	8c 91       	ld	r24, X
     b46:	5a 97       	sbiw	r26, 0x1a	; 26
     b48:	88 23       	and	r24, r24
     b4a:	e9 f0       	breq	.+58     	; 0xb86 <xQueueSemaphoreTake+0x7e>
     b4c:	81 50       	subi	r24, 0x01	; 1
     b4e:	5a 96       	adiw	r26, 0x1a	; 26
     b50:	8c 93       	st	X, r24
     b52:	5a 97       	sbiw	r26, 0x1a	; 26
     b54:	8d 91       	ld	r24, X+
     b56:	9c 91       	ld	r25, X
     b58:	89 2b       	or	r24, r25
     b5a:	29 f4       	brne	.+10     	; 0xb66 <xQueueSemaphoreTake+0x5e>
     b5c:	0e 94 18 0c 	call	0x1830	; 0x1830 <pvTaskIncrementMutexHeldCount>
     b60:	f8 01       	movw	r30, r16
     b62:	95 83       	std	Z+5, r25	; 0x05
     b64:	84 83       	std	Z+4, r24	; 0x04
     b66:	d8 01       	movw	r26, r16
     b68:	18 96       	adiw	r26, 0x08	; 8
     b6a:	8c 91       	ld	r24, X
     b6c:	88 23       	and	r24, r24
     b6e:	39 f0       	breq	.+14     	; 0xb7e <xQueueSemaphoreTake+0x76>
     b70:	c8 01       	movw	r24, r16
     b72:	08 96       	adiw	r24, 0x08	; 8
     b74:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskRemoveFromEventList>
     b78:	81 11       	cpse	r24, r1
     b7a:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     b7e:	0f 90       	pop	r0
     b80:	0f be       	out	0x3f, r0	; 63
     b82:	81 e0       	ldi	r24, 0x01	; 1
     b84:	7f c0       	rjmp	.+254    	; 0xc84 <xQueueSemaphoreTake+0x17c>
     b86:	8c 81       	ldd	r24, Y+4	; 0x04
     b88:	9d 81       	ldd	r25, Y+5	; 0x05
     b8a:	89 2b       	or	r24, r25
     b8c:	21 f4       	brne	.+8      	; 0xb96 <xQueueSemaphoreTake+0x8e>
     b8e:	0f 90       	pop	r0
     b90:	0f be       	out	0x3f, r0	; 63
     b92:	80 e0       	ldi	r24, 0x00	; 0
     b94:	77 c0       	rjmp	.+238    	; 0xc84 <xQueueSemaphoreTake+0x17c>
     b96:	d1 10       	cpse	r13, r1
     b98:	05 c0       	rjmp	.+10     	; 0xba4 <xQueueSemaphoreTake+0x9c>
     b9a:	ce 01       	movw	r24, r28
     b9c:	01 96       	adiw	r24, 0x01	; 1
     b9e:	0e 94 c3 0a 	call	0x1586	; 0x1586 <vTaskInternalSetTimeOutState>
     ba2:	dc 2c       	mov	r13, r12
     ba4:	0f 90       	pop	r0
     ba6:	0f be       	out	0x3f, r0	; 63
     ba8:	0e 94 69 08 	call	0x10d2	; 0x10d2 <vTaskSuspendAll>
     bac:	0f b6       	in	r0, 0x3f	; 63
     bae:	f8 94       	cli
     bb0:	0f 92       	push	r0
     bb2:	f8 01       	movw	r30, r16
     bb4:	85 8d       	ldd	r24, Z+29	; 0x1d
     bb6:	8f 3f       	cpi	r24, 0xFF	; 255
     bb8:	09 f4       	brne	.+2      	; 0xbbc <xQueueSemaphoreTake+0xb4>
     bba:	15 8e       	std	Z+29, r1	; 0x1d
     bbc:	d8 01       	movw	r26, r16
     bbe:	5e 96       	adiw	r26, 0x1e	; 30
     bc0:	8c 91       	ld	r24, X
     bc2:	5e 97       	sbiw	r26, 0x1e	; 30
     bc4:	8f 3f       	cpi	r24, 0xFF	; 255
     bc6:	11 f4       	brne	.+4      	; 0xbcc <xQueueSemaphoreTake+0xc4>
     bc8:	5e 96       	adiw	r26, 0x1e	; 30
     bca:	1c 92       	st	X, r1
     bcc:	0f 90       	pop	r0
     bce:	0f be       	out	0x3f, r0	; 63
     bd0:	be 01       	movw	r22, r28
     bd2:	6c 5f       	subi	r22, 0xFC	; 252
     bd4:	7f 4f       	sbci	r23, 0xFF	; 255
     bd6:	ce 01       	movw	r24, r28
     bd8:	01 96       	adiw	r24, 0x01	; 1
     bda:	0e 94 ce 0a 	call	0x159c	; 0x159c <xTaskCheckForTimeOut>
     bde:	81 11       	cpse	r24, r1
     be0:	29 c0       	rjmp	.+82     	; 0xc34 <xQueueSemaphoreTake+0x12c>
     be2:	c8 01       	movw	r24, r16
     be4:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <prvIsQueueEmpty>
     be8:	88 23       	and	r24, r24
     bea:	f1 f0       	breq	.+60     	; 0xc28 <xQueueSemaphoreTake+0x120>
     bec:	f8 01       	movw	r30, r16
     bee:	80 81       	ld	r24, Z
     bf0:	91 81       	ldd	r25, Z+1	; 0x01
     bf2:	89 2b       	or	r24, r25
     bf4:	51 f4       	brne	.+20     	; 0xc0a <xQueueSemaphoreTake+0x102>
     bf6:	0f b6       	in	r0, 0x3f	; 63
     bf8:	f8 94       	cli
     bfa:	0f 92       	push	r0
     bfc:	84 81       	ldd	r24, Z+4	; 0x04
     bfe:	95 81       	ldd	r25, Z+5	; 0x05
     c00:	0e 94 16 0b 	call	0x162c	; 0x162c <xTaskPriorityInherit>
     c04:	b8 2e       	mov	r11, r24
     c06:	0f 90       	pop	r0
     c08:	0f be       	out	0x3f, r0	; 63
     c0a:	6c 81       	ldd	r22, Y+4	; 0x04
     c0c:	7d 81       	ldd	r23, Y+5	; 0x05
     c0e:	c7 01       	movw	r24, r14
     c10:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <vTaskPlaceOnEventList>
     c14:	c8 01       	movw	r24, r16
     c16:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     c1a:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     c1e:	81 11       	cpse	r24, r1
     c20:	8c cf       	rjmp	.-232    	; 0xb3a <xQueueSemaphoreTake+0x32>
     c22:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     c26:	89 cf       	rjmp	.-238    	; 0xb3a <xQueueSemaphoreTake+0x32>
     c28:	c8 01       	movw	r24, r16
     c2a:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     c2e:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     c32:	83 cf       	rjmp	.-250    	; 0xb3a <xQueueSemaphoreTake+0x32>
     c34:	c8 01       	movw	r24, r16
     c36:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
     c3a:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
     c3e:	c8 01       	movw	r24, r16
     c40:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <prvIsQueueEmpty>
     c44:	88 23       	and	r24, r24
     c46:	09 f4       	brne	.+2      	; 0xc4a <xQueueSemaphoreTake+0x142>
     c48:	78 cf       	rjmp	.-272    	; 0xb3a <xQueueSemaphoreTake+0x32>
     c4a:	bb 20       	and	r11, r11
     c4c:	d1 f0       	breq	.+52     	; 0xc82 <xQueueSemaphoreTake+0x17a>
     c4e:	0f b6       	in	r0, 0x3f	; 63
     c50:	f8 94       	cli
     c52:	0f 92       	push	r0
     c54:	f8 01       	movw	r30, r16
     c56:	81 89       	ldd	r24, Z+17	; 0x11
     c58:	88 23       	and	r24, r24
     c5a:	39 f0       	breq	.+14     	; 0xc6a <xQueueSemaphoreTake+0x162>
     c5c:	06 88       	ldd	r0, Z+22	; 0x16
     c5e:	f7 89       	ldd	r31, Z+23	; 0x17
     c60:	e0 2d       	mov	r30, r0
     c62:	80 81       	ld	r24, Z
     c64:	64 e0       	ldi	r22, 0x04	; 4
     c66:	68 1b       	sub	r22, r24
     c68:	01 c0       	rjmp	.+2      	; 0xc6c <xQueueSemaphoreTake+0x164>
     c6a:	60 e0       	ldi	r22, 0x00	; 0
     c6c:	d8 01       	movw	r26, r16
     c6e:	14 96       	adiw	r26, 0x04	; 4
     c70:	8d 91       	ld	r24, X+
     c72:	9c 91       	ld	r25, X
     c74:	15 97       	sbiw	r26, 0x05	; 5
     c76:	0e 94 c8 0b 	call	0x1790	; 0x1790 <vTaskPriorityDisinheritAfterTimeout>
     c7a:	0f 90       	pop	r0
     c7c:	0f be       	out	0x3f, r0	; 63
     c7e:	80 e0       	ldi	r24, 0x00	; 0
     c80:	01 c0       	rjmp	.+2      	; 0xc84 <xQueueSemaphoreTake+0x17c>
     c82:	80 e0       	ldi	r24, 0x00	; 0
     c84:	0f 90       	pop	r0
     c86:	0f 90       	pop	r0
     c88:	0f 90       	pop	r0
     c8a:	0f 90       	pop	r0
     c8c:	0f 90       	pop	r0
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	ff 90       	pop	r15
     c98:	ef 90       	pop	r14
     c9a:	df 90       	pop	r13
     c9c:	cf 90       	pop	r12
     c9e:	bf 90       	pop	r11
     ca0:	08 95       	ret

00000ca2 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
     ca2:	cf 93       	push	r28
     ca4:	df 93       	push	r29
     ca6:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	0f 92       	push	r0
     cae:	8d 8d       	ldd	r24, Y+29	; 0x1d
     cb0:	8f 3f       	cpi	r24, 0xFF	; 255
     cb2:	09 f4       	brne	.+2      	; 0xcb6 <vQueueWaitForMessageRestricted+0x14>
     cb4:	1d 8e       	std	Y+29, r1	; 0x1d
     cb6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     cb8:	8f 3f       	cpi	r24, 0xFF	; 255
     cba:	09 f4       	brne	.+2      	; 0xcbe <vQueueWaitForMessageRestricted+0x1c>
     cbc:	1e 8e       	std	Y+30, r1	; 0x1e
     cbe:	0f 90       	pop	r0
     cc0:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     cc2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     cc4:	81 11       	cpse	r24, r1
     cc6:	04 c0       	rjmp	.+8      	; 0xcd0 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     cc8:	ce 01       	movw	r24, r28
     cca:	41 96       	adiw	r24, 0x11	; 17
     ccc:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
     cd0:	ce 01       	movw	r24, r28
     cd2:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvUnlockQueue>
    }
     cd6:	df 91       	pop	r29
     cd8:	cf 91       	pop	r28
     cda:	08 95       	ret

00000cdc <prvResetNextTaskUnblockTime>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
     cdc:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <pxDelayedTaskList>
     ce0:	f0 91 56 01 	lds	r31, 0x0156	; 0x800156 <pxDelayedTaskList+0x1>
     ce4:	80 81       	ld	r24, Z
     ce6:	81 11       	cpse	r24, r1
     ce8:	07 c0       	rjmp	.+14     	; 0xcf8 <prvResetNextTaskUnblockTime+0x1c>
     cea:	8f ef       	ldi	r24, 0xFF	; 255
     cec:	9f ef       	ldi	r25, 0xFF	; 255
     cee:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <xNextTaskUnblockTime+0x1>
     cf2:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xNextTaskUnblockTime>
     cf6:	08 95       	ret
     cf8:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <pxDelayedTaskList>
     cfc:	f0 91 56 01 	lds	r31, 0x0156	; 0x800156 <pxDelayedTaskList+0x1>
     d00:	05 80       	ldd	r0, Z+5	; 0x05
     d02:	f6 81       	ldd	r31, Z+6	; 0x06
     d04:	e0 2d       	mov	r30, r0
     d06:	06 80       	ldd	r0, Z+6	; 0x06
     d08:	f7 81       	ldd	r31, Z+7	; 0x07
     d0a:	e0 2d       	mov	r30, r0
     d0c:	82 81       	ldd	r24, Z+2	; 0x02
     d0e:	93 81       	ldd	r25, Z+3	; 0x03
     d10:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <xNextTaskUnblockTime+0x1>
     d14:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xNextTaskUnblockTime>
     d18:	08 95       	ret

00000d1a <prvAddCurrentTaskToDelayedList>:
     d1a:	ff 92       	push	r15
     d1c:	0f 93       	push	r16
     d1e:	1f 93       	push	r17
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	ec 01       	movw	r28, r24
     d26:	f6 2e       	mov	r15, r22
     d28:	00 91 34 01 	lds	r16, 0x0134	; 0x800134 <xTickCount>
     d2c:	10 91 35 01 	lds	r17, 0x0135	; 0x800135 <xTickCount+0x1>
     d30:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
     d34:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     d38:	02 96       	adiw	r24, 0x02	; 2
     d3a:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
     d3e:	cf 3f       	cpi	r28, 0xFF	; 255
     d40:	8f ef       	ldi	r24, 0xFF	; 255
     d42:	d8 07       	cpc	r29, r24
     d44:	69 f4       	brne	.+26     	; 0xd60 <prvAddCurrentTaskToDelayedList+0x46>
     d46:	ff 20       	and	r15, r15
     d48:	59 f0       	breq	.+22     	; 0xd60 <prvAddCurrentTaskToDelayedList+0x46>
     d4a:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
     d4e:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     d52:	6e 5f       	subi	r22, 0xFE	; 254
     d54:	7f 4f       	sbci	r23, 0xFF	; 255
     d56:	87 e3       	ldi	r24, 0x37	; 55
     d58:	91 e0       	ldi	r25, 0x01	; 1
     d5a:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
     d5e:	2f c0       	rjmp	.+94     	; 0xdbe <prvAddCurrentTaskToDelayedList+0xa4>
     d60:	c0 0f       	add	r28, r16
     d62:	d1 1f       	adc	r29, r17
     d64:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
     d68:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     d6c:	d3 83       	std	Z+3, r29	; 0x03
     d6e:	c2 83       	std	Z+2, r28	; 0x02
     d70:	c0 17       	cp	r28, r16
     d72:	d1 07       	cpc	r29, r17
     d74:	68 f4       	brcc	.+26     	; 0xd90 <prvAddCurrentTaskToDelayedList+0x76>
     d76:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
     d7a:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     d7e:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <pxOverflowDelayedTaskList>
     d82:	90 91 54 01 	lds	r25, 0x0154	; 0x800154 <pxOverflowDelayedTaskList+0x1>
     d86:	6e 5f       	subi	r22, 0xFE	; 254
     d88:	7f 4f       	sbci	r23, 0xFF	; 255
     d8a:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
     d8e:	17 c0       	rjmp	.+46     	; 0xdbe <prvAddCurrentTaskToDelayedList+0xa4>
     d90:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
     d94:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     d98:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <pxDelayedTaskList>
     d9c:	90 91 56 01 	lds	r25, 0x0156	; 0x800156 <pxDelayedTaskList+0x1>
     da0:	6e 5f       	subi	r22, 0xFE	; 254
     da2:	7f 4f       	sbci	r23, 0xFF	; 255
     da4:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
     da8:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xNextTaskUnblockTime>
     dac:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <xNextTaskUnblockTime+0x1>
     db0:	c8 17       	cp	r28, r24
     db2:	d9 07       	cpc	r29, r25
     db4:	20 f4       	brcc	.+8      	; 0xdbe <prvAddCurrentTaskToDelayedList+0xa4>
     db6:	d0 93 2c 01 	sts	0x012C, r29	; 0x80012c <xNextTaskUnblockTime+0x1>
     dba:	c0 93 2b 01 	sts	0x012B, r28	; 0x80012b <xNextTaskUnblockTime>
     dbe:	df 91       	pop	r29
     dc0:	cf 91       	pop	r28
     dc2:	1f 91       	pop	r17
     dc4:	0f 91       	pop	r16
     dc6:	ff 90       	pop	r15
     dc8:	08 95       	ret

00000dca <prvIdleTask>:
     dca:	01 e4       	ldi	r16, 0x41	; 65
     dcc:	11 e0       	ldi	r17, 0x01	; 1
     dce:	0f 2e       	mov	r0, r31
     dd0:	f9 e6       	ldi	r31, 0x69	; 105
     dd2:	ef 2e       	mov	r14, r31
     dd4:	f1 e0       	ldi	r31, 0x01	; 1
     dd6:	ff 2e       	mov	r15, r31
     dd8:	f0 2d       	mov	r31, r0
     dda:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxDeletedTasksWaitingCleanUp>
     dde:	88 23       	and	r24, r24
     de0:	29 f1       	breq	.+74     	; 0xe2c <prvIdleTask+0x62>
     de2:	0f b6       	in	r0, 0x3f	; 63
     de4:	f8 94       	cli
     de6:	0f 92       	push	r0
     de8:	d8 01       	movw	r26, r16
     dea:	15 96       	adiw	r26, 0x05	; 5
     dec:	ed 91       	ld	r30, X+
     dee:	fc 91       	ld	r31, X
     df0:	16 97       	sbiw	r26, 0x06	; 6
     df2:	c6 81       	ldd	r28, Z+6	; 0x06
     df4:	d7 81       	ldd	r29, Z+7	; 0x07
     df6:	ce 01       	movw	r24, r28
     df8:	02 96       	adiw	r24, 0x02	; 2
     dfa:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
     dfe:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxCurrentNumberOfTasks>
     e02:	81 50       	subi	r24, 0x01	; 1
     e04:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <uxCurrentNumberOfTasks>
     e08:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxDeletedTasksWaitingCleanUp>
     e0c:	81 50       	subi	r24, 0x01	; 1
     e0e:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxDeletedTasksWaitingCleanUp>
     e12:	0f 90       	pop	r0
     e14:	0f be       	out	0x3f, r0	; 63
     e16:	8f 89       	ldd	r24, Y+23	; 0x17
     e18:	98 8d       	ldd	r25, Y+24	; 0x18
     e1a:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     e1e:	ce 01       	movw	r24, r28
     e20:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     e24:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxDeletedTasksWaitingCleanUp>
     e28:	81 11       	cpse	r24, r1
     e2a:	db cf       	rjmp	.-74     	; 0xde2 <prvIdleTask+0x18>
     e2c:	f7 01       	movw	r30, r14
     e2e:	80 81       	ld	r24, Z
     e30:	82 30       	cpi	r24, 0x02	; 2
     e32:	10 f0       	brcs	.+4      	; 0xe38 <prvIdleTask+0x6e>
     e34:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
     e38:	0e 94 a1 00 	call	0x142	; 0x142 <vApplicationIdleHook>
     e3c:	ce cf       	rjmp	.-100    	; 0xdda <prvIdleTask+0x10>

00000e3e <xTaskCreate>:
     e3e:	4f 92       	push	r4
     e40:	5f 92       	push	r5
     e42:	6f 92       	push	r6
     e44:	7f 92       	push	r7
     e46:	8f 92       	push	r8
     e48:	9f 92       	push	r9
     e4a:	af 92       	push	r10
     e4c:	bf 92       	push	r11
     e4e:	cf 92       	push	r12
     e50:	df 92       	push	r13
     e52:	ef 92       	push	r14
     e54:	ff 92       	push	r15
     e56:	0f 93       	push	r16
     e58:	cf 93       	push	r28
     e5a:	df 93       	push	r29
     e5c:	4c 01       	movw	r8, r24
     e5e:	6b 01       	movw	r12, r22
     e60:	5a 01       	movw	r10, r20
     e62:	29 01       	movw	r4, r18
     e64:	ca 01       	movw	r24, r20
     e66:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     e6a:	3c 01       	movw	r6, r24
     e6c:	89 2b       	or	r24, r25
     e6e:	09 f4       	brne	.+2      	; 0xe72 <xTaskCreate+0x34>
     e70:	f1 c0       	rjmp	.+482    	; 0x1054 <xTaskCreate+0x216>
     e72:	88 e2       	ldi	r24, 0x28	; 40
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	0e 94 7f 00 	call	0xfe	; 0xfe <pvPortMalloc>
     e7a:	ec 01       	movw	r28, r24
     e7c:	89 2b       	or	r24, r25
     e7e:	99 f0       	breq	.+38     	; 0xea6 <xTaskCreate+0x68>
     e80:	78 8e       	std	Y+24, r7	; 0x18
     e82:	6f 8a       	std	Y+23, r6	; 0x17
     e84:	a5 01       	movw	r20, r10
     e86:	65 ea       	ldi	r22, 0xA5	; 165
     e88:	70 e0       	ldi	r23, 0x00	; 0
     e8a:	c3 01       	movw	r24, r6
     e8c:	0e 94 95 0f 	call	0x1f2a	; 0x1f2a <memset>
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	a8 1a       	sub	r10, r24
     e94:	b1 08       	sbc	r11, r1
     e96:	8f 89       	ldd	r24, Y+23	; 0x17
     e98:	98 8d       	ldd	r25, Y+24	; 0x18
     e9a:	a8 0e       	add	r10, r24
     e9c:	b9 1e       	adc	r11, r25
     e9e:	c1 14       	cp	r12, r1
     ea0:	d1 04       	cpc	r13, r1
     ea2:	29 f4       	brne	.+10     	; 0xeae <xTaskCreate+0x70>
     ea4:	20 c0       	rjmp	.+64     	; 0xee6 <xTaskCreate+0xa8>
     ea6:	c3 01       	movw	r24, r6
     ea8:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
     eac:	d3 c0       	rjmp	.+422    	; 0x1054 <xTaskCreate+0x216>
     eae:	d6 01       	movw	r26, r12
     eb0:	8c 91       	ld	r24, X
     eb2:	89 8f       	std	Y+25, r24	; 0x19
     eb4:	8c 91       	ld	r24, X
     eb6:	88 23       	and	r24, r24
     eb8:	a1 f0       	breq	.+40     	; 0xee2 <xTaskCreate+0xa4>
     eba:	ae 01       	movw	r20, r28
     ebc:	46 5e       	subi	r20, 0xE6	; 230
     ebe:	5f 4f       	sbci	r21, 0xFF	; 255
     ec0:	f6 01       	movw	r30, r12
     ec2:	31 96       	adiw	r30, 0x01	; 1
     ec4:	b8 e0       	ldi	r27, 0x08	; 8
     ec6:	cb 0e       	add	r12, r27
     ec8:	d1 1c       	adc	r13, r1
     eca:	cf 01       	movw	r24, r30
     ecc:	21 91       	ld	r18, Z+
     ece:	da 01       	movw	r26, r20
     ed0:	2d 93       	st	X+, r18
     ed2:	ad 01       	movw	r20, r26
     ed4:	dc 01       	movw	r26, r24
     ed6:	8c 91       	ld	r24, X
     ed8:	88 23       	and	r24, r24
     eda:	19 f0       	breq	.+6      	; 0xee2 <xTaskCreate+0xa4>
     edc:	ec 15       	cp	r30, r12
     ede:	fd 05       	cpc	r31, r13
     ee0:	a1 f7       	brne	.-24     	; 0xeca <xTaskCreate+0x8c>
     ee2:	18 a2       	std	Y+32, r1	; 0x20
     ee4:	01 c0       	rjmp	.+2      	; 0xee8 <xTaskCreate+0xaa>
     ee6:	19 8e       	std	Y+25, r1	; 0x19
     ee8:	04 30       	cpi	r16, 0x04	; 4
     eea:	08 f0       	brcs	.+2      	; 0xeee <xTaskCreate+0xb0>
     eec:	03 e0       	ldi	r16, 0x03	; 3
     eee:	0e 8b       	std	Y+22, r16	; 0x16
     ef0:	09 a3       	std	Y+33, r16	; 0x21
     ef2:	1a a2       	std	Y+34, r1	; 0x22
     ef4:	6e 01       	movw	r12, r28
     ef6:	b2 e0       	ldi	r27, 0x02	; 2
     ef8:	cb 0e       	add	r12, r27
     efa:	d1 1c       	adc	r13, r1
     efc:	c6 01       	movw	r24, r12
     efe:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vListInitialiseItem>
     f02:	ce 01       	movw	r24, r28
     f04:	0c 96       	adiw	r24, 0x0c	; 12
     f06:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vListInitialiseItem>
     f0a:	d9 87       	std	Y+9, r29	; 0x09
     f0c:	c8 87       	std	Y+8, r28	; 0x08
     f0e:	84 e0       	ldi	r24, 0x04	; 4
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	80 1b       	sub	r24, r16
     f14:	91 09       	sbc	r25, r1
     f16:	9d 87       	std	Y+13, r25	; 0x0d
     f18:	8c 87       	std	Y+12, r24	; 0x0c
     f1a:	db 8b       	std	Y+19, r29	; 0x13
     f1c:	ca 8b       	std	Y+18, r28	; 0x12
     f1e:	1b a2       	std	Y+35, r1	; 0x23
     f20:	1c a2       	std	Y+36, r1	; 0x24
     f22:	1d a2       	std	Y+37, r1	; 0x25
     f24:	1e a2       	std	Y+38, r1	; 0x26
     f26:	1f a2       	std	Y+39, r1	; 0x27
     f28:	a2 01       	movw	r20, r4
     f2a:	b4 01       	movw	r22, r8
     f2c:	c5 01       	movw	r24, r10
     f2e:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <pxPortInitialiseStack>
     f32:	99 83       	std	Y+1, r25	; 0x01
     f34:	88 83       	st	Y, r24
     f36:	e1 14       	cp	r14, r1
     f38:	f1 04       	cpc	r15, r1
     f3a:	19 f0       	breq	.+6      	; 0xf42 <xTaskCreate+0x104>
     f3c:	f7 01       	movw	r30, r14
     f3e:	d1 83       	std	Z+1, r29	; 0x01
     f40:	c0 83       	st	Z, r28
     f42:	0f b6       	in	r0, 0x3f	; 63
     f44:	f8 94       	cli
     f46:	0f 92       	push	r0
     f48:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxCurrentNumberOfTasks>
     f4c:	8f 5f       	subi	r24, 0xFF	; 255
     f4e:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <uxCurrentNumberOfTasks>
     f52:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
     f56:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     f5a:	89 2b       	or	r24, r25
     f5c:	d1 f5       	brne	.+116    	; 0xfd2 <xTaskCreate+0x194>
     f5e:	d0 93 8e 01 	sts	0x018E, r29	; 0x80018e <pxCurrentTCB+0x1>
     f62:	c0 93 8d 01 	sts	0x018D, r28	; 0x80018d <pxCurrentTCB>
     f66:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxCurrentNumberOfTasks>
     f6a:	81 30       	cpi	r24, 0x01	; 1
     f6c:	09 f0       	breq	.+2      	; 0xf70 <xTaskCreate+0x132>
     f6e:	41 c0       	rjmp	.+130    	; 0xff2 <xTaskCreate+0x1b4>
     f70:	89 e6       	ldi	r24, 0x69	; 105
     f72:	91 e0       	ldi	r25, 0x01	; 1
     f74:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     f78:	82 e7       	ldi	r24, 0x72	; 114
     f7a:	91 e0       	ldi	r25, 0x01	; 1
     f7c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     f80:	8b e7       	ldi	r24, 0x7B	; 123
     f82:	91 e0       	ldi	r25, 0x01	; 1
     f84:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     f88:	84 e8       	ldi	r24, 0x84	; 132
     f8a:	91 e0       	ldi	r25, 0x01	; 1
     f8c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     f90:	80 e6       	ldi	r24, 0x60	; 96
     f92:	91 e0       	ldi	r25, 0x01	; 1
     f94:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     f98:	87 e5       	ldi	r24, 0x57	; 87
     f9a:	91 e0       	ldi	r25, 0x01	; 1
     f9c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     fa0:	8a e4       	ldi	r24, 0x4A	; 74
     fa2:	91 e0       	ldi	r25, 0x01	; 1
     fa4:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     fa8:	81 e4       	ldi	r24, 0x41	; 65
     faa:	91 e0       	ldi	r25, 0x01	; 1
     fac:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     fb0:	87 e3       	ldi	r24, 0x37	; 55
     fb2:	91 e0       	ldi	r25, 0x01	; 1
     fb4:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
     fb8:	80 e6       	ldi	r24, 0x60	; 96
     fba:	91 e0       	ldi	r25, 0x01	; 1
     fbc:	90 93 56 01 	sts	0x0156, r25	; 0x800156 <pxDelayedTaskList+0x1>
     fc0:	80 93 55 01 	sts	0x0155, r24	; 0x800155 <pxDelayedTaskList>
     fc4:	87 e5       	ldi	r24, 0x57	; 87
     fc6:	91 e0       	ldi	r25, 0x01	; 1
     fc8:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <pxOverflowDelayedTaskList+0x1>
     fcc:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <pxOverflowDelayedTaskList>
     fd0:	10 c0       	rjmp	.+32     	; 0xff2 <xTaskCreate+0x1b4>
     fd2:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xSchedulerRunning>
     fd6:	81 11       	cpse	r24, r1
     fd8:	0c c0       	rjmp	.+24     	; 0xff2 <xTaskCreate+0x1b4>
     fda:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
     fde:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
     fe2:	96 89       	ldd	r25, Z+22	; 0x16
     fe4:	8e 89       	ldd	r24, Y+22	; 0x16
     fe6:	89 17       	cp	r24, r25
     fe8:	20 f0       	brcs	.+8      	; 0xff2 <xTaskCreate+0x1b4>
     fea:	d0 93 8e 01 	sts	0x018E, r29	; 0x80018e <pxCurrentTCB+0x1>
     fee:	c0 93 8d 01 	sts	0x018D, r28	; 0x80018d <pxCurrentTCB>
     ff2:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <uxTaskNumber>
     ff6:	8f 5f       	subi	r24, 0xFF	; 255
     ff8:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <uxTaskNumber>
     ffc:	8e 89       	ldd	r24, Y+22	; 0x16
     ffe:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <uxTopReadyPriority>
    1002:	98 17       	cp	r25, r24
    1004:	10 f4       	brcc	.+4      	; 0x100a <xTaskCreate+0x1cc>
    1006:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <uxTopReadyPriority>
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	9c 01       	movw	r18, r24
    100e:	22 0f       	add	r18, r18
    1010:	33 1f       	adc	r19, r19
    1012:	22 0f       	add	r18, r18
    1014:	33 1f       	adc	r19, r19
    1016:	22 0f       	add	r18, r18
    1018:	33 1f       	adc	r19, r19
    101a:	82 0f       	add	r24, r18
    101c:	93 1f       	adc	r25, r19
    101e:	b6 01       	movw	r22, r12
    1020:	87 59       	subi	r24, 0x97	; 151
    1022:	9e 4f       	sbci	r25, 0xFE	; 254
    1024:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1028:	0f 90       	pop	r0
    102a:	0f be       	out	0x3f, r0	; 63
    102c:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xSchedulerRunning>
    1030:	88 23       	and	r24, r24
    1032:	61 f0       	breq	.+24     	; 0x104c <xTaskCreate+0x20e>
    1034:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1038:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    103c:	96 89       	ldd	r25, Z+22	; 0x16
    103e:	8e 89       	ldd	r24, Y+22	; 0x16
    1040:	98 17       	cp	r25, r24
    1042:	30 f4       	brcc	.+12     	; 0x1050 <xTaskCreate+0x212>
    1044:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	05 c0       	rjmp	.+10     	; 0x1056 <xTaskCreate+0x218>
    104c:	81 e0       	ldi	r24, 0x01	; 1
    104e:	03 c0       	rjmp	.+6      	; 0x1056 <xTaskCreate+0x218>
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	01 c0       	rjmp	.+2      	; 0x1056 <xTaskCreate+0x218>
    1054:	8f ef       	ldi	r24, 0xFF	; 255
    1056:	df 91       	pop	r29
    1058:	cf 91       	pop	r28
    105a:	0f 91       	pop	r16
    105c:	ff 90       	pop	r15
    105e:	ef 90       	pop	r14
    1060:	df 90       	pop	r13
    1062:	cf 90       	pop	r12
    1064:	bf 90       	pop	r11
    1066:	af 90       	pop	r10
    1068:	9f 90       	pop	r9
    106a:	8f 90       	pop	r8
    106c:	7f 90       	pop	r7
    106e:	6f 90       	pop	r6
    1070:	5f 90       	pop	r5
    1072:	4f 90       	pop	r4
    1074:	08 95       	ret

00001076 <vTaskStartScheduler>:
    1076:	ef 92       	push	r14
    1078:	ff 92       	push	r15
    107a:	0f 93       	push	r16
    107c:	0f 2e       	mov	r0, r31
    107e:	f9 e2       	ldi	r31, 0x29	; 41
    1080:	ef 2e       	mov	r14, r31
    1082:	f1 e0       	ldi	r31, 0x01	; 1
    1084:	ff 2e       	mov	r15, r31
    1086:	f0 2d       	mov	r31, r0
    1088:	00 e0       	ldi	r16, 0x00	; 0
    108a:	20 e0       	ldi	r18, 0x00	; 0
    108c:	30 e0       	ldi	r19, 0x00	; 0
    108e:	45 e5       	ldi	r20, 0x55	; 85
    1090:	50 e0       	ldi	r21, 0x00	; 0
    1092:	66 e1       	ldi	r22, 0x16	; 22
    1094:	71 e0       	ldi	r23, 0x01	; 1
    1096:	85 ee       	ldi	r24, 0xE5	; 229
    1098:	96 e0       	ldi	r25, 0x06	; 6
    109a:	0e 94 1f 07 	call	0xe3e	; 0xe3e <xTaskCreate>
    109e:	81 30       	cpi	r24, 0x01	; 1
    10a0:	a1 f4       	brne	.+40     	; 0x10ca <vTaskStartScheduler+0x54>
    10a2:	0e 94 82 0c 	call	0x1904	; 0x1904 <xTimerCreateTimerTask>
    10a6:	81 30       	cpi	r24, 0x01	; 1
    10a8:	81 f4       	brne	.+32     	; 0x10ca <vTaskStartScheduler+0x54>
    10aa:	f8 94       	cli
    10ac:	8f ef       	ldi	r24, 0xFF	; 255
    10ae:	9f ef       	ldi	r25, 0xFF	; 255
    10b0:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <xNextTaskUnblockTime+0x1>
    10b4:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xNextTaskUnblockTime>
    10b8:	81 e0       	ldi	r24, 0x01	; 1
    10ba:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xSchedulerRunning>
    10be:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <xTickCount+0x1>
    10c2:	10 92 34 01 	sts	0x0134, r1	; 0x800134 <xTickCount>
    10c6:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <xPortStartScheduler>
    10ca:	0f 91       	pop	r16
    10cc:	ff 90       	pop	r15
    10ce:	ef 90       	pop	r14
    10d0:	08 95       	ret

000010d2 <vTaskSuspendAll>:
    10d2:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    10d6:	8f 5f       	subi	r24, 0xFF	; 255
    10d8:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <uxSchedulerSuspended>
    10dc:	08 95       	ret

000010de <xTaskGetTickCount>:
    10de:	0f b6       	in	r0, 0x3f	; 63
    10e0:	f8 94       	cli
    10e2:	0f 92       	push	r0
    10e4:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <xTickCount>
    10e8:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <xTickCount+0x1>
    10ec:	0f 90       	pop	r0
    10ee:	0f be       	out	0x3f, r0	; 63
    10f0:	08 95       	ret

000010f2 <xTaskIncrementTick>:
    10f2:	cf 92       	push	r12
    10f4:	df 92       	push	r13
    10f6:	ef 92       	push	r14
    10f8:	ff 92       	push	r15
    10fa:	0f 93       	push	r16
    10fc:	1f 93       	push	r17
    10fe:	cf 93       	push	r28
    1100:	df 93       	push	r29
    1102:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    1106:	81 11       	cpse	r24, r1
    1108:	9f c0       	rjmp	.+318    	; 0x1248 <xTaskIncrementTick+0x156>
    110a:	e0 90 34 01 	lds	r14, 0x0134	; 0x800134 <xTickCount>
    110e:	f0 90 35 01 	lds	r15, 0x0135	; 0x800135 <xTickCount+0x1>
    1112:	8f ef       	ldi	r24, 0xFF	; 255
    1114:	e8 1a       	sub	r14, r24
    1116:	f8 0a       	sbc	r15, r24
    1118:	f0 92 35 01 	sts	0x0135, r15	; 0x800135 <xTickCount+0x1>
    111c:	e0 92 34 01 	sts	0x0134, r14	; 0x800134 <xTickCount>
    1120:	e1 14       	cp	r14, r1
    1122:	f1 04       	cpc	r15, r1
    1124:	b9 f4       	brne	.+46     	; 0x1154 <xTaskIncrementTick+0x62>
    1126:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <pxDelayedTaskList>
    112a:	90 91 56 01 	lds	r25, 0x0156	; 0x800156 <pxDelayedTaskList+0x1>
    112e:	20 91 53 01 	lds	r18, 0x0153	; 0x800153 <pxOverflowDelayedTaskList>
    1132:	30 91 54 01 	lds	r19, 0x0154	; 0x800154 <pxOverflowDelayedTaskList+0x1>
    1136:	30 93 56 01 	sts	0x0156, r19	; 0x800156 <pxDelayedTaskList+0x1>
    113a:	20 93 55 01 	sts	0x0155, r18	; 0x800155 <pxDelayedTaskList>
    113e:	90 93 54 01 	sts	0x0154, r25	; 0x800154 <pxOverflowDelayedTaskList+0x1>
    1142:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <pxOverflowDelayedTaskList>
    1146:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xNumOfOverflows>
    114a:	8f 5f       	subi	r24, 0xFF	; 255
    114c:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <xNumOfOverflows>
    1150:	0e 94 6e 06 	call	0xcdc	; 0xcdc <prvResetNextTaskUnblockTime>
    1154:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xNextTaskUnblockTime>
    1158:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <xNextTaskUnblockTime+0x1>
    115c:	e8 16       	cp	r14, r24
    115e:	f9 06       	cpc	r15, r25
    1160:	10 f4       	brcc	.+4      	; 0x1166 <xTaskIncrementTick+0x74>
    1162:	d1 2c       	mov	r13, r1
    1164:	53 c0       	rjmp	.+166    	; 0x120c <xTaskIncrementTick+0x11a>
    1166:	d1 2c       	mov	r13, r1
    1168:	cc 24       	eor	r12, r12
    116a:	c3 94       	inc	r12
    116c:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <pxDelayedTaskList>
    1170:	f0 91 56 01 	lds	r31, 0x0156	; 0x800156 <pxDelayedTaskList+0x1>
    1174:	80 81       	ld	r24, Z
    1176:	81 11       	cpse	r24, r1
    1178:	07 c0       	rjmp	.+14     	; 0x1188 <xTaskIncrementTick+0x96>
    117a:	8f ef       	ldi	r24, 0xFF	; 255
    117c:	9f ef       	ldi	r25, 0xFF	; 255
    117e:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <xNextTaskUnblockTime+0x1>
    1182:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xNextTaskUnblockTime>
    1186:	42 c0       	rjmp	.+132    	; 0x120c <xTaskIncrementTick+0x11a>
    1188:	e0 91 55 01 	lds	r30, 0x0155	; 0x800155 <pxDelayedTaskList>
    118c:	f0 91 56 01 	lds	r31, 0x0156	; 0x800156 <pxDelayedTaskList+0x1>
    1190:	05 80       	ldd	r0, Z+5	; 0x05
    1192:	f6 81       	ldd	r31, Z+6	; 0x06
    1194:	e0 2d       	mov	r30, r0
    1196:	c6 81       	ldd	r28, Z+6	; 0x06
    1198:	d7 81       	ldd	r29, Z+7	; 0x07
    119a:	8a 81       	ldd	r24, Y+2	; 0x02
    119c:	9b 81       	ldd	r25, Y+3	; 0x03
    119e:	e8 16       	cp	r14, r24
    11a0:	f9 06       	cpc	r15, r25
    11a2:	28 f4       	brcc	.+10     	; 0x11ae <xTaskIncrementTick+0xbc>
    11a4:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <xNextTaskUnblockTime+0x1>
    11a8:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xNextTaskUnblockTime>
    11ac:	2f c0       	rjmp	.+94     	; 0x120c <xTaskIncrementTick+0x11a>
    11ae:	8e 01       	movw	r16, r28
    11b0:	0e 5f       	subi	r16, 0xFE	; 254
    11b2:	1f 4f       	sbci	r17, 0xFF	; 255
    11b4:	c8 01       	movw	r24, r16
    11b6:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    11ba:	8c 89       	ldd	r24, Y+20	; 0x14
    11bc:	9d 89       	ldd	r25, Y+21	; 0x15
    11be:	89 2b       	or	r24, r25
    11c0:	21 f0       	breq	.+8      	; 0x11ca <xTaskIncrementTick+0xd8>
    11c2:	ce 01       	movw	r24, r28
    11c4:	0c 96       	adiw	r24, 0x0c	; 12
    11c6:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    11ca:	8e 89       	ldd	r24, Y+22	; 0x16
    11cc:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <uxTopReadyPriority>
    11d0:	98 17       	cp	r25, r24
    11d2:	10 f4       	brcc	.+4      	; 0x11d8 <xTaskIncrementTick+0xe6>
    11d4:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <uxTopReadyPriority>
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	9c 01       	movw	r18, r24
    11dc:	22 0f       	add	r18, r18
    11de:	33 1f       	adc	r19, r19
    11e0:	22 0f       	add	r18, r18
    11e2:	33 1f       	adc	r19, r19
    11e4:	22 0f       	add	r18, r18
    11e6:	33 1f       	adc	r19, r19
    11e8:	82 0f       	add	r24, r18
    11ea:	93 1f       	adc	r25, r19
    11ec:	b8 01       	movw	r22, r16
    11ee:	87 59       	subi	r24, 0x97	; 151
    11f0:	9e 4f       	sbci	r25, 0xFE	; 254
    11f2:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    11f6:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    11fa:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    11fe:	9e 89       	ldd	r25, Y+22	; 0x16
    1200:	86 89       	ldd	r24, Z+22	; 0x16
    1202:	98 17       	cp	r25, r24
    1204:	08 f4       	brcc	.+2      	; 0x1208 <xTaskIncrementTick+0x116>
    1206:	b2 cf       	rjmp	.-156    	; 0x116c <xTaskIncrementTick+0x7a>
    1208:	dc 2c       	mov	r13, r12
    120a:	b0 cf       	rjmp	.-160    	; 0x116c <xTaskIncrementTick+0x7a>
    120c:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1210:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1214:	86 89       	ldd	r24, Z+22	; 0x16
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	fc 01       	movw	r30, r24
    121a:	ee 0f       	add	r30, r30
    121c:	ff 1f       	adc	r31, r31
    121e:	ee 0f       	add	r30, r30
    1220:	ff 1f       	adc	r31, r31
    1222:	ee 0f       	add	r30, r30
    1224:	ff 1f       	adc	r31, r31
    1226:	8e 0f       	add	r24, r30
    1228:	9f 1f       	adc	r25, r31
    122a:	fc 01       	movw	r30, r24
    122c:	e7 59       	subi	r30, 0x97	; 151
    122e:	fe 4f       	sbci	r31, 0xFE	; 254
    1230:	80 81       	ld	r24, Z
    1232:	82 30       	cpi	r24, 0x02	; 2
    1234:	10 f0       	brcs	.+4      	; 0x123a <xTaskIncrementTick+0x148>
    1236:	dd 24       	eor	r13, r13
    1238:	d3 94       	inc	r13
    123a:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <xYieldPending>
    123e:	88 23       	and	r24, r24
    1240:	69 f0       	breq	.+26     	; 0x125c <xTaskIncrementTick+0x16a>
    1242:	dd 24       	eor	r13, r13
    1244:	d3 94       	inc	r13
    1246:	0a c0       	rjmp	.+20     	; 0x125c <xTaskIncrementTick+0x16a>
    1248:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <xPendedTicks>
    124c:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <xPendedTicks+0x1>
    1250:	01 96       	adiw	r24, 0x01	; 1
    1252:	90 93 31 01 	sts	0x0131, r25	; 0x800131 <xPendedTicks+0x1>
    1256:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <xPendedTicks>
    125a:	d1 2c       	mov	r13, r1
    125c:	8d 2d       	mov	r24, r13
    125e:	df 91       	pop	r29
    1260:	cf 91       	pop	r28
    1262:	1f 91       	pop	r17
    1264:	0f 91       	pop	r16
    1266:	ff 90       	pop	r15
    1268:	ef 90       	pop	r14
    126a:	df 90       	pop	r13
    126c:	cf 90       	pop	r12
    126e:	08 95       	ret

00001270 <xTaskResumeAll>:
    1270:	df 92       	push	r13
    1272:	ef 92       	push	r14
    1274:	ff 92       	push	r15
    1276:	0f 93       	push	r16
    1278:	1f 93       	push	r17
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	0f b6       	in	r0, 0x3f	; 63
    1280:	f8 94       	cli
    1282:	0f 92       	push	r0
    1284:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    1288:	81 50       	subi	r24, 0x01	; 1
    128a:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <uxSchedulerSuspended>
    128e:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    1292:	81 11       	cpse	r24, r1
    1294:	63 c0       	rjmp	.+198    	; 0x135c <xTaskResumeAll+0xec>
    1296:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <uxCurrentNumberOfTasks>
    129a:	81 11       	cpse	r24, r1
    129c:	33 c0       	rjmp	.+102    	; 0x1304 <xTaskResumeAll+0x94>
    129e:	61 c0       	rjmp	.+194    	; 0x1362 <xTaskResumeAll+0xf2>
    12a0:	d7 01       	movw	r26, r14
    12a2:	15 96       	adiw	r26, 0x05	; 5
    12a4:	ed 91       	ld	r30, X+
    12a6:	fc 91       	ld	r31, X
    12a8:	16 97       	sbiw	r26, 0x06	; 6
    12aa:	c6 81       	ldd	r28, Z+6	; 0x06
    12ac:	d7 81       	ldd	r29, Z+7	; 0x07
    12ae:	ce 01       	movw	r24, r28
    12b0:	0c 96       	adiw	r24, 0x0c	; 12
    12b2:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    12b6:	8e 01       	movw	r16, r28
    12b8:	0e 5f       	subi	r16, 0xFE	; 254
    12ba:	1f 4f       	sbci	r17, 0xFF	; 255
    12bc:	c8 01       	movw	r24, r16
    12be:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    12c2:	8e 89       	ldd	r24, Y+22	; 0x16
    12c4:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <uxTopReadyPriority>
    12c8:	98 17       	cp	r25, r24
    12ca:	10 f4       	brcc	.+4      	; 0x12d0 <xTaskResumeAll+0x60>
    12cc:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <uxTopReadyPriority>
    12d0:	90 e0       	ldi	r25, 0x00	; 0
    12d2:	9c 01       	movw	r18, r24
    12d4:	22 0f       	add	r18, r18
    12d6:	33 1f       	adc	r19, r19
    12d8:	22 0f       	add	r18, r18
    12da:	33 1f       	adc	r19, r19
    12dc:	22 0f       	add	r18, r18
    12de:	33 1f       	adc	r19, r19
    12e0:	82 0f       	add	r24, r18
    12e2:	93 1f       	adc	r25, r19
    12e4:	b8 01       	movw	r22, r16
    12e6:	87 59       	subi	r24, 0x97	; 151
    12e8:	9e 4f       	sbci	r25, 0xFE	; 254
    12ea:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    12ee:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    12f2:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    12f6:	9e 89       	ldd	r25, Y+22	; 0x16
    12f8:	86 89       	ldd	r24, Z+22	; 0x16
    12fa:	98 17       	cp	r25, r24
    12fc:	68 f0       	brcs	.+26     	; 0x1318 <xTaskResumeAll+0xa8>
    12fe:	d0 92 2f 01 	sts	0x012F, r13	; 0x80012f <xYieldPending>
    1302:	0a c0       	rjmp	.+20     	; 0x1318 <xTaskResumeAll+0xa8>
    1304:	c0 e0       	ldi	r28, 0x00	; 0
    1306:	d0 e0       	ldi	r29, 0x00	; 0
    1308:	0f 2e       	mov	r0, r31
    130a:	fa e4       	ldi	r31, 0x4A	; 74
    130c:	ef 2e       	mov	r14, r31
    130e:	f1 e0       	ldi	r31, 0x01	; 1
    1310:	ff 2e       	mov	r15, r31
    1312:	f0 2d       	mov	r31, r0
    1314:	dd 24       	eor	r13, r13
    1316:	d3 94       	inc	r13
    1318:	f7 01       	movw	r30, r14
    131a:	80 81       	ld	r24, Z
    131c:	81 11       	cpse	r24, r1
    131e:	c0 cf       	rjmp	.-128    	; 0x12a0 <xTaskResumeAll+0x30>
    1320:	cd 2b       	or	r28, r29
    1322:	11 f0       	breq	.+4      	; 0x1328 <xTaskResumeAll+0xb8>
    1324:	0e 94 6e 06 	call	0xcdc	; 0xcdc <prvResetNextTaskUnblockTime>
    1328:	c0 91 30 01 	lds	r28, 0x0130	; 0x800130 <xPendedTicks>
    132c:	d0 91 31 01 	lds	r29, 0x0131	; 0x800131 <xPendedTicks+0x1>
    1330:	20 97       	sbiw	r28, 0x00	; 0
    1332:	61 f0       	breq	.+24     	; 0x134c <xTaskResumeAll+0xdc>
    1334:	11 e0       	ldi	r17, 0x01	; 1
    1336:	0e 94 79 08 	call	0x10f2	; 0x10f2 <xTaskIncrementTick>
    133a:	81 11       	cpse	r24, r1
    133c:	10 93 2f 01 	sts	0x012F, r17	; 0x80012f <xYieldPending>
    1340:	21 97       	sbiw	r28, 0x01	; 1
    1342:	c9 f7       	brne	.-14     	; 0x1336 <xTaskResumeAll+0xc6>
    1344:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <xPendedTicks+0x1>
    1348:	10 92 30 01 	sts	0x0130, r1	; 0x800130 <xPendedTicks>
    134c:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <xYieldPending>
    1350:	88 23       	and	r24, r24
    1352:	31 f0       	breq	.+12     	; 0x1360 <xTaskResumeAll+0xf0>
    1354:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
    1358:	81 e0       	ldi	r24, 0x01	; 1
    135a:	03 c0       	rjmp	.+6      	; 0x1362 <xTaskResumeAll+0xf2>
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	01 c0       	rjmp	.+2      	; 0x1362 <xTaskResumeAll+0xf2>
    1360:	80 e0       	ldi	r24, 0x00	; 0
    1362:	0f 90       	pop	r0
    1364:	0f be       	out	0x3f, r0	; 63
    1366:	df 91       	pop	r29
    1368:	cf 91       	pop	r28
    136a:	1f 91       	pop	r17
    136c:	0f 91       	pop	r16
    136e:	ff 90       	pop	r15
    1370:	ef 90       	pop	r14
    1372:	df 90       	pop	r13
    1374:	08 95       	ret

00001376 <vTaskDelay>:
    1376:	cf 93       	push	r28
    1378:	df 93       	push	r29
    137a:	ec 01       	movw	r28, r24
    137c:	89 2b       	or	r24, r25
    137e:	51 f0       	breq	.+20     	; 0x1394 <vTaskDelay+0x1e>
    1380:	0e 94 69 08 	call	0x10d2	; 0x10d2 <vTaskSuspendAll>
    1384:	60 e0       	ldi	r22, 0x00	; 0
    1386:	ce 01       	movw	r24, r28
    1388:	0e 94 8d 06 	call	0xd1a	; 0xd1a <prvAddCurrentTaskToDelayedList>
    138c:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
    1390:	81 11       	cpse	r24, r1
    1392:	02 c0       	rjmp	.+4      	; 0x1398 <vTaskDelay+0x22>
    1394:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
    1398:	df 91       	pop	r29
    139a:	cf 91       	pop	r28
    139c:	08 95       	ret

0000139e <vTaskSwitchContext>:
    139e:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    13a2:	88 23       	and	r24, r24
    13a4:	21 f0       	breq	.+8      	; 0x13ae <vTaskSwitchContext+0x10>
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
    13ac:	08 95       	ret
    13ae:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <xYieldPending>
    13b2:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    13b6:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    13ba:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    13be:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    13c2:	2d 91       	ld	r18, X+
    13c4:	3c 91       	ld	r19, X
    13c6:	87 89       	ldd	r24, Z+23	; 0x17
    13c8:	90 8d       	ldd	r25, Z+24	; 0x18
    13ca:	82 17       	cp	r24, r18
    13cc:	93 07       	cpc	r25, r19
    13ce:	60 f0       	brcs	.+24     	; 0x13e8 <vTaskSwitchContext+0x4a>
    13d0:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
    13d4:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    13d8:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
    13dc:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    13e0:	67 5e       	subi	r22, 0xE7	; 231
    13e2:	7f 4f       	sbci	r23, 0xFF	; 255
    13e4:	0e 94 c5 00 	call	0x18a	; 0x18a <vApplicationStackOverflowHook>
    13e8:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <uxTopReadyPriority>
    13ec:	82 2f       	mov	r24, r18
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	fc 01       	movw	r30, r24
    13f2:	ee 0f       	add	r30, r30
    13f4:	ff 1f       	adc	r31, r31
    13f6:	ee 0f       	add	r30, r30
    13f8:	ff 1f       	adc	r31, r31
    13fa:	ee 0f       	add	r30, r30
    13fc:	ff 1f       	adc	r31, r31
    13fe:	e8 0f       	add	r30, r24
    1400:	f9 1f       	adc	r31, r25
    1402:	e7 59       	subi	r30, 0x97	; 151
    1404:	fe 4f       	sbci	r31, 0xFE	; 254
    1406:	30 81       	ld	r19, Z
    1408:	31 11       	cpse	r19, r1
    140a:	11 c0       	rjmp	.+34     	; 0x142e <vTaskSwitchContext+0x90>
    140c:	21 50       	subi	r18, 0x01	; 1
    140e:	82 2f       	mov	r24, r18
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	fc 01       	movw	r30, r24
    1414:	ee 0f       	add	r30, r30
    1416:	ff 1f       	adc	r31, r31
    1418:	ee 0f       	add	r30, r30
    141a:	ff 1f       	adc	r31, r31
    141c:	ee 0f       	add	r30, r30
    141e:	ff 1f       	adc	r31, r31
    1420:	e8 0f       	add	r30, r24
    1422:	f9 1f       	adc	r31, r25
    1424:	e7 59       	subi	r30, 0x97	; 151
    1426:	fe 4f       	sbci	r31, 0xFE	; 254
    1428:	30 81       	ld	r19, Z
    142a:	33 23       	and	r19, r19
    142c:	79 f3       	breq	.-34     	; 0x140c <vTaskSwitchContext+0x6e>
    142e:	ac 01       	movw	r20, r24
    1430:	44 0f       	add	r20, r20
    1432:	55 1f       	adc	r21, r21
    1434:	44 0f       	add	r20, r20
    1436:	55 1f       	adc	r21, r21
    1438:	44 0f       	add	r20, r20
    143a:	55 1f       	adc	r21, r21
    143c:	48 0f       	add	r20, r24
    143e:	59 1f       	adc	r21, r25
    1440:	da 01       	movw	r26, r20
    1442:	a7 59       	subi	r26, 0x97	; 151
    1444:	be 4f       	sbci	r27, 0xFE	; 254
    1446:	11 96       	adiw	r26, 0x01	; 1
    1448:	ed 91       	ld	r30, X+
    144a:	fc 91       	ld	r31, X
    144c:	12 97       	sbiw	r26, 0x02	; 2
    144e:	02 80       	ldd	r0, Z+2	; 0x02
    1450:	f3 81       	ldd	r31, Z+3	; 0x03
    1452:	e0 2d       	mov	r30, r0
    1454:	12 96       	adiw	r26, 0x02	; 2
    1456:	fc 93       	st	X, r31
    1458:	ee 93       	st	-X, r30
    145a:	11 97       	sbiw	r26, 0x01	; 1
    145c:	44 59       	subi	r20, 0x94	; 148
    145e:	5e 4f       	sbci	r21, 0xFE	; 254
    1460:	e4 17       	cp	r30, r20
    1462:	f5 07       	cpc	r31, r21
    1464:	29 f4       	brne	.+10     	; 0x1470 <vTaskSwitchContext+0xd2>
    1466:	42 81       	ldd	r20, Z+2	; 0x02
    1468:	53 81       	ldd	r21, Z+3	; 0x03
    146a:	fd 01       	movw	r30, r26
    146c:	52 83       	std	Z+2, r21	; 0x02
    146e:	41 83       	std	Z+1, r20	; 0x01
    1470:	fc 01       	movw	r30, r24
    1472:	ee 0f       	add	r30, r30
    1474:	ff 1f       	adc	r31, r31
    1476:	ee 0f       	add	r30, r30
    1478:	ff 1f       	adc	r31, r31
    147a:	ee 0f       	add	r30, r30
    147c:	ff 1f       	adc	r31, r31
    147e:	8e 0f       	add	r24, r30
    1480:	9f 1f       	adc	r25, r31
    1482:	fc 01       	movw	r30, r24
    1484:	e7 59       	subi	r30, 0x97	; 151
    1486:	fe 4f       	sbci	r31, 0xFE	; 254
    1488:	01 80       	ldd	r0, Z+1	; 0x01
    148a:	f2 81       	ldd	r31, Z+2	; 0x02
    148c:	e0 2d       	mov	r30, r0
    148e:	86 81       	ldd	r24, Z+6	; 0x06
    1490:	97 81       	ldd	r25, Z+7	; 0x07
    1492:	90 93 8e 01 	sts	0x018E, r25	; 0x80018e <pxCurrentTCB+0x1>
    1496:	80 93 8d 01 	sts	0x018D, r24	; 0x80018d <pxCurrentTCB>
    149a:	20 93 33 01 	sts	0x0133, r18	; 0x800133 <uxTopReadyPriority>
    149e:	08 95       	ret

000014a0 <vTaskPlaceOnEventList>:
    14a0:	cf 93       	push	r28
    14a2:	df 93       	push	r29
    14a4:	eb 01       	movw	r28, r22
    14a6:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
    14aa:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    14ae:	64 5f       	subi	r22, 0xF4	; 244
    14b0:	7f 4f       	sbci	r23, 0xFF	; 255
    14b2:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    14b6:	61 e0       	ldi	r22, 0x01	; 1
    14b8:	ce 01       	movw	r24, r28
    14ba:	0e 94 8d 06 	call	0xd1a	; 0xd1a <prvAddCurrentTaskToDelayedList>
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	08 95       	ret

000014c4 <vTaskPlaceOnEventListRestricted>:
    14c4:	0f 93       	push	r16
    14c6:	1f 93       	push	r17
    14c8:	cf 93       	push	r28
    14ca:	8b 01       	movw	r16, r22
    14cc:	c4 2f       	mov	r28, r20
    14ce:	60 91 8d 01 	lds	r22, 0x018D	; 0x80018d <pxCurrentTCB>
    14d2:	70 91 8e 01 	lds	r23, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    14d6:	64 5f       	subi	r22, 0xF4	; 244
    14d8:	7f 4f       	sbci	r23, 0xFF	; 255
    14da:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    14de:	cc 23       	and	r28, r28
    14e0:	11 f0       	breq	.+4      	; 0x14e6 <vTaskPlaceOnEventListRestricted+0x22>
    14e2:	0f ef       	ldi	r16, 0xFF	; 255
    14e4:	1f ef       	ldi	r17, 0xFF	; 255
    14e6:	6c 2f       	mov	r22, r28
    14e8:	c8 01       	movw	r24, r16
    14ea:	0e 94 8d 06 	call	0xd1a	; 0xd1a <prvAddCurrentTaskToDelayedList>
    14ee:	cf 91       	pop	r28
    14f0:	1f 91       	pop	r17
    14f2:	0f 91       	pop	r16
    14f4:	08 95       	ret

000014f6 <xTaskRemoveFromEventList>:
    14f6:	0f 93       	push	r16
    14f8:	1f 93       	push	r17
    14fa:	cf 93       	push	r28
    14fc:	df 93       	push	r29
    14fe:	dc 01       	movw	r26, r24
    1500:	15 96       	adiw	r26, 0x05	; 5
    1502:	ed 91       	ld	r30, X+
    1504:	fc 91       	ld	r31, X
    1506:	16 97       	sbiw	r26, 0x06	; 6
    1508:	c6 81       	ldd	r28, Z+6	; 0x06
    150a:	d7 81       	ldd	r29, Z+7	; 0x07
    150c:	8e 01       	movw	r16, r28
    150e:	04 5f       	subi	r16, 0xF4	; 244
    1510:	1f 4f       	sbci	r17, 0xFF	; 255
    1512:	c8 01       	movw	r24, r16
    1514:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    1518:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    151c:	81 11       	cpse	r24, r1
    151e:	1c c0       	rjmp	.+56     	; 0x1558 <xTaskRemoveFromEventList+0x62>
    1520:	0a 50       	subi	r16, 0x0A	; 10
    1522:	11 09       	sbc	r17, r1
    1524:	c8 01       	movw	r24, r16
    1526:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    152a:	8e 89       	ldd	r24, Y+22	; 0x16
    152c:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <uxTopReadyPriority>
    1530:	98 17       	cp	r25, r24
    1532:	10 f4       	brcc	.+4      	; 0x1538 <xTaskRemoveFromEventList+0x42>
    1534:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <uxTopReadyPriority>
    1538:	90 e0       	ldi	r25, 0x00	; 0
    153a:	9c 01       	movw	r18, r24
    153c:	22 0f       	add	r18, r18
    153e:	33 1f       	adc	r19, r19
    1540:	22 0f       	add	r18, r18
    1542:	33 1f       	adc	r19, r19
    1544:	22 0f       	add	r18, r18
    1546:	33 1f       	adc	r19, r19
    1548:	82 0f       	add	r24, r18
    154a:	93 1f       	adc	r25, r19
    154c:	b8 01       	movw	r22, r16
    154e:	87 59       	subi	r24, 0x97	; 151
    1550:	9e 4f       	sbci	r25, 0xFE	; 254
    1552:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1556:	05 c0       	rjmp	.+10     	; 0x1562 <xTaskRemoveFromEventList+0x6c>
    1558:	b8 01       	movw	r22, r16
    155a:	8a e4       	ldi	r24, 0x4A	; 74
    155c:	91 e0       	ldi	r25, 0x01	; 1
    155e:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1562:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1566:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    156a:	9e 89       	ldd	r25, Y+22	; 0x16
    156c:	86 89       	ldd	r24, Z+22	; 0x16
    156e:	89 17       	cp	r24, r25
    1570:	20 f4       	brcc	.+8      	; 0x157a <xTaskRemoveFromEventList+0x84>
    1572:	81 e0       	ldi	r24, 0x01	; 1
    1574:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
    1578:	01 c0       	rjmp	.+2      	; 0x157c <xTaskRemoveFromEventList+0x86>
    157a:	80 e0       	ldi	r24, 0x00	; 0
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	08 95       	ret

00001586 <vTaskInternalSetTimeOutState>:
    1586:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <xNumOfOverflows>
    158a:	fc 01       	movw	r30, r24
    158c:	20 83       	st	Z, r18
    158e:	20 91 34 01 	lds	r18, 0x0134	; 0x800134 <xTickCount>
    1592:	30 91 35 01 	lds	r19, 0x0135	; 0x800135 <xTickCount+0x1>
    1596:	32 83       	std	Z+2, r19	; 0x02
    1598:	21 83       	std	Z+1, r18	; 0x01
    159a:	08 95       	ret

0000159c <xTaskCheckForTimeOut>:
    159c:	cf 93       	push	r28
    159e:	df 93       	push	r29
    15a0:	0f b6       	in	r0, 0x3f	; 63
    15a2:	f8 94       	cli
    15a4:	0f 92       	push	r0
    15a6:	20 91 34 01 	lds	r18, 0x0134	; 0x800134 <xTickCount>
    15aa:	30 91 35 01 	lds	r19, 0x0135	; 0x800135 <xTickCount+0x1>
    15ae:	db 01       	movw	r26, r22
    15b0:	4d 91       	ld	r20, X+
    15b2:	5c 91       	ld	r21, X
    15b4:	4f 3f       	cpi	r20, 0xFF	; 255
    15b6:	bf ef       	ldi	r27, 0xFF	; 255
    15b8:	5b 07       	cpc	r21, r27
    15ba:	f1 f0       	breq	.+60     	; 0x15f8 <xTaskCheckForTimeOut+0x5c>
    15bc:	ec 01       	movw	r28, r24
    15be:	e9 81       	ldd	r30, Y+1	; 0x01
    15c0:	fa 81       	ldd	r31, Y+2	; 0x02
    15c2:	a0 91 2e 01 	lds	r26, 0x012E	; 0x80012e <xNumOfOverflows>
    15c6:	b8 81       	ld	r27, Y
    15c8:	ba 17       	cp	r27, r26
    15ca:	19 f0       	breq	.+6      	; 0x15d2 <xTaskCheckForTimeOut+0x36>
    15cc:	2e 17       	cp	r18, r30
    15ce:	3f 07       	cpc	r19, r31
    15d0:	a8 f4       	brcc	.+42     	; 0x15fc <xTaskCheckForTimeOut+0x60>
    15d2:	2e 1b       	sub	r18, r30
    15d4:	3f 0b       	sbc	r19, r31
    15d6:	24 17       	cp	r18, r20
    15d8:	35 07       	cpc	r19, r21
    15da:	48 f4       	brcc	.+18     	; 0x15ee <xTaskCheckForTimeOut+0x52>
    15dc:	fb 01       	movw	r30, r22
    15de:	42 1b       	sub	r20, r18
    15e0:	53 0b       	sbc	r21, r19
    15e2:	51 83       	std	Z+1, r21	; 0x01
    15e4:	40 83       	st	Z, r20
    15e6:	0e 94 c3 0a 	call	0x1586	; 0x1586 <vTaskInternalSetTimeOutState>
    15ea:	80 e0       	ldi	r24, 0x00	; 0
    15ec:	08 c0       	rjmp	.+16     	; 0x15fe <xTaskCheckForTimeOut+0x62>
    15ee:	fb 01       	movw	r30, r22
    15f0:	11 82       	std	Z+1, r1	; 0x01
    15f2:	10 82       	st	Z, r1
    15f4:	81 e0       	ldi	r24, 0x01	; 1
    15f6:	03 c0       	rjmp	.+6      	; 0x15fe <xTaskCheckForTimeOut+0x62>
    15f8:	80 e0       	ldi	r24, 0x00	; 0
    15fa:	01 c0       	rjmp	.+2      	; 0x15fe <xTaskCheckForTimeOut+0x62>
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	0f 90       	pop	r0
    1600:	0f be       	out	0x3f, r0	; 63
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	08 95       	ret

00001608 <vTaskMissedYield>:
    1608:	81 e0       	ldi	r24, 0x01	; 1
    160a:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xYieldPending>
    160e:	08 95       	ret

00001610 <xTaskGetSchedulerState>:
    1610:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xSchedulerRunning>
    1614:	88 23       	and	r24, r24
    1616:	31 f0       	breq	.+12     	; 0x1624 <xTaskGetSchedulerState+0x14>
    1618:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxSchedulerSuspended>
    161c:	88 23       	and	r24, r24
    161e:	21 f0       	breq	.+8      	; 0x1628 <xTaskGetSchedulerState+0x18>
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	08 95       	ret
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	08 95       	ret
    1628:	82 e0       	ldi	r24, 0x02	; 2
    162a:	08 95       	ret

0000162c <xTaskPriorityInherit>:
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	fc 01       	movw	r30, r24
    1636:	89 2b       	or	r24, r25
    1638:	09 f4       	brne	.+2      	; 0x163c <xTaskPriorityInherit+0x10>
    163a:	64 c0       	rjmp	.+200    	; 0x1704 <xTaskPriorityInherit+0xd8>
    163c:	26 89       	ldd	r18, Z+22	; 0x16
    163e:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    1642:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1646:	56 96       	adiw	r26, 0x16	; 22
    1648:	8c 91       	ld	r24, X
    164a:	28 17       	cp	r18, r24
    164c:	08 f0       	brcs	.+2      	; 0x1650 <xTaskPriorityInherit+0x24>
    164e:	4e c0       	rjmp	.+156    	; 0x16ec <xTaskPriorityInherit+0xc0>
    1650:	84 85       	ldd	r24, Z+12	; 0x0c
    1652:	95 85       	ldd	r25, Z+13	; 0x0d
    1654:	99 23       	and	r25, r25
    1656:	64 f0       	brlt	.+24     	; 0x1670 <xTaskPriorityInherit+0x44>
    1658:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    165c:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1660:	56 96       	adiw	r26, 0x16	; 22
    1662:	3c 91       	ld	r19, X
    1664:	84 e0       	ldi	r24, 0x04	; 4
    1666:	90 e0       	ldi	r25, 0x00	; 0
    1668:	83 1b       	sub	r24, r19
    166a:	91 09       	sbc	r25, r1
    166c:	95 87       	std	Z+13, r25	; 0x0d
    166e:	84 87       	std	Z+12, r24	; 0x0c
    1670:	30 e0       	ldi	r19, 0x00	; 0
    1672:	c9 01       	movw	r24, r18
    1674:	88 0f       	add	r24, r24
    1676:	99 1f       	adc	r25, r25
    1678:	88 0f       	add	r24, r24
    167a:	99 1f       	adc	r25, r25
    167c:	88 0f       	add	r24, r24
    167e:	99 1f       	adc	r25, r25
    1680:	28 0f       	add	r18, r24
    1682:	39 1f       	adc	r19, r25
    1684:	27 59       	subi	r18, 0x97	; 151
    1686:	3e 4f       	sbci	r19, 0xFE	; 254
    1688:	82 85       	ldd	r24, Z+10	; 0x0a
    168a:	93 85       	ldd	r25, Z+11	; 0x0b
    168c:	82 17       	cp	r24, r18
    168e:	93 07       	cpc	r25, r19
    1690:	21 f5       	brne	.+72     	; 0x16da <xTaskPriorityInherit+0xae>
    1692:	8f 01       	movw	r16, r30
    1694:	ef 01       	movw	r28, r30
    1696:	22 96       	adiw	r28, 0x02	; 2
    1698:	ce 01       	movw	r24, r28
    169a:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    169e:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    16a2:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    16a6:	86 89       	ldd	r24, Z+22	; 0x16
    16a8:	f8 01       	movw	r30, r16
    16aa:	86 8b       	std	Z+22, r24	; 0x16
    16ac:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <uxTopReadyPriority>
    16b0:	98 17       	cp	r25, r24
    16b2:	10 f4       	brcc	.+4      	; 0x16b8 <xTaskPriorityInherit+0x8c>
    16b4:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <uxTopReadyPriority>
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	9c 01       	movw	r18, r24
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	22 0f       	add	r18, r18
    16c2:	33 1f       	adc	r19, r19
    16c4:	22 0f       	add	r18, r18
    16c6:	33 1f       	adc	r19, r19
    16c8:	82 0f       	add	r24, r18
    16ca:	93 1f       	adc	r25, r19
    16cc:	be 01       	movw	r22, r28
    16ce:	87 59       	subi	r24, 0x97	; 151
    16d0:	9e 4f       	sbci	r25, 0xFE	; 254
    16d2:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	16 c0       	rjmp	.+44     	; 0x1706 <xTaskPriorityInherit+0xda>
    16da:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    16de:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    16e2:	56 96       	adiw	r26, 0x16	; 22
    16e4:	8c 91       	ld	r24, X
    16e6:	86 8b       	std	Z+22, r24	; 0x16
    16e8:	81 e0       	ldi	r24, 0x01	; 1
    16ea:	0d c0       	rjmp	.+26     	; 0x1706 <xTaskPriorityInherit+0xda>
    16ec:	a0 91 8d 01 	lds	r26, 0x018D	; 0x80018d <pxCurrentTCB>
    16f0:	b0 91 8e 01 	lds	r27, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    16f4:	81 e0       	ldi	r24, 0x01	; 1
    16f6:	21 a1       	ldd	r18, Z+33	; 0x21
    16f8:	56 96       	adiw	r26, 0x16	; 22
    16fa:	9c 91       	ld	r25, X
    16fc:	29 17       	cp	r18, r25
    16fe:	18 f0       	brcs	.+6      	; 0x1706 <xTaskPriorityInherit+0xda>
    1700:	80 e0       	ldi	r24, 0x00	; 0
    1702:	01 c0       	rjmp	.+2      	; 0x1706 <xTaskPriorityInherit+0xda>
    1704:	80 e0       	ldi	r24, 0x00	; 0
    1706:	df 91       	pop	r29
    1708:	cf 91       	pop	r28
    170a:	1f 91       	pop	r17
    170c:	0f 91       	pop	r16
    170e:	08 95       	ret

00001710 <xTaskPriorityDisinherit>:
    1710:	0f 93       	push	r16
    1712:	1f 93       	push	r17
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	fc 01       	movw	r30, r24
    171a:	89 2b       	or	r24, r25
    171c:	79 f1       	breq	.+94     	; 0x177c <xTaskPriorityDisinherit+0x6c>
    171e:	82 a1       	ldd	r24, Z+34	; 0x22
    1720:	81 50       	subi	r24, 0x01	; 1
    1722:	82 a3       	std	Z+34, r24	; 0x22
    1724:	26 89       	ldd	r18, Z+22	; 0x16
    1726:	91 a1       	ldd	r25, Z+33	; 0x21
    1728:	29 17       	cp	r18, r25
    172a:	51 f1       	breq	.+84     	; 0x1780 <xTaskPriorityDisinherit+0x70>
    172c:	81 11       	cpse	r24, r1
    172e:	2a c0       	rjmp	.+84     	; 0x1784 <xTaskPriorityDisinherit+0x74>
    1730:	ef 01       	movw	r28, r30
    1732:	8f 01       	movw	r16, r30
    1734:	0e 5f       	subi	r16, 0xFE	; 254
    1736:	1f 4f       	sbci	r17, 0xFF	; 255
    1738:	c8 01       	movw	r24, r16
    173a:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    173e:	89 a1       	ldd	r24, Y+33	; 0x21
    1740:	8e 8b       	std	Y+22, r24	; 0x16
    1742:	24 e0       	ldi	r18, 0x04	; 4
    1744:	30 e0       	ldi	r19, 0x00	; 0
    1746:	28 1b       	sub	r18, r24
    1748:	31 09       	sbc	r19, r1
    174a:	3d 87       	std	Y+13, r19	; 0x0d
    174c:	2c 87       	std	Y+12, r18	; 0x0c
    174e:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <uxTopReadyPriority>
    1752:	98 17       	cp	r25, r24
    1754:	10 f4       	brcc	.+4      	; 0x175a <xTaskPriorityDisinherit+0x4a>
    1756:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <uxTopReadyPriority>
    175a:	90 e0       	ldi	r25, 0x00	; 0
    175c:	9c 01       	movw	r18, r24
    175e:	22 0f       	add	r18, r18
    1760:	33 1f       	adc	r19, r19
    1762:	22 0f       	add	r18, r18
    1764:	33 1f       	adc	r19, r19
    1766:	22 0f       	add	r18, r18
    1768:	33 1f       	adc	r19, r19
    176a:	82 0f       	add	r24, r18
    176c:	93 1f       	adc	r25, r19
    176e:	b8 01       	movw	r22, r16
    1770:	87 59       	subi	r24, 0x97	; 151
    1772:	9e 4f       	sbci	r25, 0xFE	; 254
    1774:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1778:	81 e0       	ldi	r24, 0x01	; 1
    177a:	05 c0       	rjmp	.+10     	; 0x1786 <xTaskPriorityDisinherit+0x76>
    177c:	80 e0       	ldi	r24, 0x00	; 0
    177e:	03 c0       	rjmp	.+6      	; 0x1786 <xTaskPriorityDisinherit+0x76>
    1780:	80 e0       	ldi	r24, 0x00	; 0
    1782:	01 c0       	rjmp	.+2      	; 0x1786 <xTaskPriorityDisinherit+0x76>
    1784:	80 e0       	ldi	r24, 0x00	; 0
    1786:	df 91       	pop	r29
    1788:	cf 91       	pop	r28
    178a:	1f 91       	pop	r17
    178c:	0f 91       	pop	r16
    178e:	08 95       	ret

00001790 <vTaskPriorityDisinheritAfterTimeout>:
    1790:	0f 93       	push	r16
    1792:	1f 93       	push	r17
    1794:	cf 93       	push	r28
    1796:	df 93       	push	r29
    1798:	fc 01       	movw	r30, r24
    179a:	89 2b       	or	r24, r25
    179c:	09 f4       	brne	.+2      	; 0x17a0 <vTaskPriorityDisinheritAfterTimeout+0x10>
    179e:	43 c0       	rjmp	.+134    	; 0x1826 <vTaskPriorityDisinheritAfterTimeout+0x96>
    17a0:	91 a1       	ldd	r25, Z+33	; 0x21
    17a2:	96 17       	cp	r25, r22
    17a4:	08 f4       	brcc	.+2      	; 0x17a8 <vTaskPriorityDisinheritAfterTimeout+0x18>
    17a6:	96 2f       	mov	r25, r22
    17a8:	86 89       	ldd	r24, Z+22	; 0x16
    17aa:	89 17       	cp	r24, r25
    17ac:	e1 f1       	breq	.+120    	; 0x1826 <vTaskPriorityDisinheritAfterTimeout+0x96>
    17ae:	22 a1       	ldd	r18, Z+34	; 0x22
    17b0:	21 30       	cpi	r18, 0x01	; 1
    17b2:	c9 f5       	brne	.+114    	; 0x1826 <vTaskPriorityDisinheritAfterTimeout+0x96>
    17b4:	96 8b       	std	Z+22, r25	; 0x16
    17b6:	24 85       	ldd	r18, Z+12	; 0x0c
    17b8:	35 85       	ldd	r19, Z+13	; 0x0d
    17ba:	33 23       	and	r19, r19
    17bc:	34 f0       	brlt	.+12     	; 0x17ca <vTaskPriorityDisinheritAfterTimeout+0x3a>
    17be:	24 e0       	ldi	r18, 0x04	; 4
    17c0:	30 e0       	ldi	r19, 0x00	; 0
    17c2:	29 1b       	sub	r18, r25
    17c4:	31 09       	sbc	r19, r1
    17c6:	35 87       	std	Z+13, r19	; 0x0d
    17c8:	24 87       	std	Z+12, r18	; 0x0c
    17ca:	90 e0       	ldi	r25, 0x00	; 0
    17cc:	9c 01       	movw	r18, r24
    17ce:	22 0f       	add	r18, r18
    17d0:	33 1f       	adc	r19, r19
    17d2:	22 0f       	add	r18, r18
    17d4:	33 1f       	adc	r19, r19
    17d6:	22 0f       	add	r18, r18
    17d8:	33 1f       	adc	r19, r19
    17da:	82 0f       	add	r24, r18
    17dc:	93 1f       	adc	r25, r19
    17de:	87 59       	subi	r24, 0x97	; 151
    17e0:	9e 4f       	sbci	r25, 0xFE	; 254
    17e2:	22 85       	ldd	r18, Z+10	; 0x0a
    17e4:	33 85       	ldd	r19, Z+11	; 0x0b
    17e6:	28 17       	cp	r18, r24
    17e8:	39 07       	cpc	r19, r25
    17ea:	e9 f4       	brne	.+58     	; 0x1826 <vTaskPriorityDisinheritAfterTimeout+0x96>
    17ec:	ef 01       	movw	r28, r30
    17ee:	8f 01       	movw	r16, r30
    17f0:	0e 5f       	subi	r16, 0xFE	; 254
    17f2:	1f 4f       	sbci	r17, 0xFF	; 255
    17f4:	c8 01       	movw	r24, r16
    17f6:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    17fa:	8e 89       	ldd	r24, Y+22	; 0x16
    17fc:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <uxTopReadyPriority>
    1800:	98 17       	cp	r25, r24
    1802:	10 f4       	brcc	.+4      	; 0x1808 <vTaskPriorityDisinheritAfterTimeout+0x78>
    1804:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <uxTopReadyPriority>
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	9c 01       	movw	r18, r24
    180c:	22 0f       	add	r18, r18
    180e:	33 1f       	adc	r19, r19
    1810:	22 0f       	add	r18, r18
    1812:	33 1f       	adc	r19, r19
    1814:	22 0f       	add	r18, r18
    1816:	33 1f       	adc	r19, r19
    1818:	82 0f       	add	r24, r18
    181a:	93 1f       	adc	r25, r19
    181c:	b8 01       	movw	r22, r16
    181e:	87 59       	subi	r24, 0x97	; 151
    1820:	9e 4f       	sbci	r25, 0xFE	; 254
    1822:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <vListInsertEnd>
    1826:	df 91       	pop	r29
    1828:	cf 91       	pop	r28
    182a:	1f 91       	pop	r17
    182c:	0f 91       	pop	r16
    182e:	08 95       	ret

00001830 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    1830:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
    1834:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1838:	89 2b       	or	r24, r25
    183a:	39 f0       	breq	.+14     	; 0x184a <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    183c:	e0 91 8d 01 	lds	r30, 0x018D	; 0x80018d <pxCurrentTCB>
    1840:	f0 91 8e 01 	lds	r31, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    1844:	82 a1       	ldd	r24, Z+34	; 0x22
    1846:	8f 5f       	subi	r24, 0xFF	; 255
    1848:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    184a:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <pxCurrentTCB>
    184e:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <pxCurrentTCB+0x1>
    }
    1852:	08 95       	ret

00001854 <prvInsertTimerInActiveList>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    1854:	fc 01       	movw	r30, r24
    1856:	73 83       	std	Z+3, r23	; 0x03
    1858:	62 83       	std	Z+2, r22	; 0x02
    185a:	91 87       	std	Z+9, r25	; 0x09
    185c:	80 87       	std	Z+8, r24	; 0x08
    185e:	46 17       	cp	r20, r22
    1860:	57 07       	cpc	r21, r23
    1862:	90 f0       	brcs	.+36     	; 0x1888 <prvInsertTimerInActiveList+0x34>
    1864:	42 1b       	sub	r20, r18
    1866:	53 0b       	sbc	r21, r19
    1868:	84 85       	ldd	r24, Z+12	; 0x0c
    186a:	95 85       	ldd	r25, Z+13	; 0x0d
    186c:	48 17       	cp	r20, r24
    186e:	59 07       	cpc	r21, r25
    1870:	e0 f4       	brcc	.+56     	; 0x18aa <prvInsertTimerInActiveList+0x56>
    1872:	bf 01       	movw	r22, r30
    1874:	6e 5f       	subi	r22, 0xFE	; 254
    1876:	7f 4f       	sbci	r23, 0xFF	; 255
    1878:	80 91 95 01 	lds	r24, 0x0195	; 0x800195 <pxOverflowTimerList>
    187c:	90 91 96 01 	lds	r25, 0x0196	; 0x800196 <pxOverflowTimerList+0x1>
    1880:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    1884:	80 e0       	ldi	r24, 0x00	; 0
    1886:	08 95       	ret
    1888:	42 17       	cp	r20, r18
    188a:	53 07       	cpc	r21, r19
    188c:	18 f4       	brcc	.+6      	; 0x1894 <prvInsertTimerInActiveList+0x40>
    188e:	62 17       	cp	r22, r18
    1890:	73 07       	cpc	r23, r19
    1892:	68 f4       	brcc	.+26     	; 0x18ae <prvInsertTimerInActiveList+0x5a>
    1894:	bf 01       	movw	r22, r30
    1896:	6e 5f       	subi	r22, 0xFE	; 254
    1898:	7f 4f       	sbci	r23, 0xFF	; 255
    189a:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <pxCurrentTimerList>
    189e:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <pxCurrentTimerList+0x1>
    18a2:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    18a6:	80 e0       	ldi	r24, 0x00	; 0
    18a8:	08 95       	ret
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	08 95       	ret
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	08 95       	ret

000018b2 <prvCheckForValidListAndQueue>:
    18b2:	0f b6       	in	r0, 0x3f	; 63
    18b4:	f8 94       	cli
    18b6:	0f 92       	push	r0
    18b8:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <xTimerQueue>
    18bc:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <xTimerQueue+0x1>
    18c0:	89 2b       	or	r24, r25
    18c2:	e9 f4       	brne	.+58     	; 0x18fe <prvCheckForValidListAndQueue+0x4c>
    18c4:	82 ea       	ldi	r24, 0xA2	; 162
    18c6:	91 e0       	ldi	r25, 0x01	; 1
    18c8:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
    18cc:	89 e9       	ldi	r24, 0x99	; 153
    18ce:	91 e0       	ldi	r25, 0x01	; 1
    18d0:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <vListInitialise>
    18d4:	82 ea       	ldi	r24, 0xA2	; 162
    18d6:	91 e0       	ldi	r25, 0x01	; 1
    18d8:	90 93 98 01 	sts	0x0198, r25	; 0x800198 <pxCurrentTimerList+0x1>
    18dc:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <pxCurrentTimerList>
    18e0:	89 e9       	ldi	r24, 0x99	; 153
    18e2:	91 e0       	ldi	r25, 0x01	; 1
    18e4:	90 93 96 01 	sts	0x0196, r25	; 0x800196 <pxOverflowTimerList+0x1>
    18e8:	80 93 95 01 	sts	0x0195, r24	; 0x800195 <pxOverflowTimerList>
    18ec:	40 e0       	ldi	r20, 0x00	; 0
    18ee:	65 e0       	ldi	r22, 0x05	; 5
    18f0:	8a e0       	ldi	r24, 0x0A	; 10
    18f2:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <xQueueGenericCreate>
    18f6:	90 93 94 01 	sts	0x0194, r25	; 0x800194 <xTimerQueue+0x1>
    18fa:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <xTimerQueue>
    18fe:	0f 90       	pop	r0
    1900:	0f be       	out	0x3f, r0	; 63
    1902:	08 95       	ret

00001904 <xTimerCreateTimerTask>:
    1904:	ef 92       	push	r14
    1906:	ff 92       	push	r15
    1908:	0f 93       	push	r16
    190a:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <prvCheckForValidListAndQueue>
    190e:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <xTimerQueue>
    1912:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <xTimerQueue+0x1>
    1916:	89 2b       	or	r24, r25
    1918:	91 f0       	breq	.+36     	; 0x193e <xTimerCreateTimerTask+0x3a>
    191a:	0f 2e       	mov	r0, r31
    191c:	f1 e9       	ldi	r31, 0x91	; 145
    191e:	ef 2e       	mov	r14, r31
    1920:	f1 e0       	ldi	r31, 0x01	; 1
    1922:	ff 2e       	mov	r15, r31
    1924:	f0 2d       	mov	r31, r0
    1926:	03 e0       	ldi	r16, 0x03	; 3
    1928:	20 e0       	ldi	r18, 0x00	; 0
    192a:	30 e0       	ldi	r19, 0x00	; 0
    192c:	45 e5       	ldi	r20, 0x55	; 85
    192e:	50 e0       	ldi	r21, 0x00	; 0
    1930:	6b e1       	ldi	r22, 0x1B	; 27
    1932:	71 e0       	ldi	r23, 0x01	; 1
    1934:	8c e5       	ldi	r24, 0x5C	; 92
    1936:	9d e0       	ldi	r25, 0x0D	; 13
    1938:	0e 94 1f 07 	call	0xe3e	; 0xe3e <xTaskCreate>
    193c:	01 c0       	rjmp	.+2      	; 0x1940 <xTimerCreateTimerTask+0x3c>
    193e:	80 e0       	ldi	r24, 0x00	; 0
    1940:	0f 91       	pop	r16
    1942:	ff 90       	pop	r15
    1944:	ef 90       	pop	r14
    1946:	08 95       	ret

00001948 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1948:	0f 93       	push	r16
    194a:	1f 93       	push	r17
    194c:	cf 93       	push	r28
    194e:	df 93       	push	r29
    1950:	00 d0       	rcall	.+0      	; 0x1952 <xTimerGenericCommand+0xa>
    1952:	00 d0       	rcall	.+0      	; 0x1954 <xTimerGenericCommand+0xc>
    1954:	1f 92       	push	r1
    1956:	cd b7       	in	r28, 0x3d	; 61
    1958:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    195a:	e0 91 93 01 	lds	r30, 0x0193	; 0x800193 <xTimerQueue>
    195e:	f0 91 94 01 	lds	r31, 0x0194	; 0x800194 <xTimerQueue+0x1>
    1962:	30 97       	sbiw	r30, 0x00	; 0
    1964:	71 f1       	breq	.+92     	; 0x19c2 <xTimerGenericCommand+0x7a>
    1966:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    1968:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    196a:	5b 83       	std	Y+3, r21	; 0x03
    196c:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    196e:	9d 83       	std	Y+5, r25	; 0x05
    1970:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1972:	66 30       	cpi	r22, 0x06	; 6
    1974:	ec f4       	brge	.+58     	; 0x19b0 <xTimerGenericCommand+0x68>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1976:	0e 94 08 0b 	call	0x1610	; 0x1610 <xTaskGetSchedulerState>
    197a:	82 30       	cpi	r24, 0x02	; 2
    197c:	61 f4       	brne	.+24     	; 0x1996 <xTimerGenericCommand+0x4e>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    197e:	20 e0       	ldi	r18, 0x00	; 0
    1980:	a8 01       	movw	r20, r16
    1982:	be 01       	movw	r22, r28
    1984:	6f 5f       	subi	r22, 0xFF	; 255
    1986:	7f 4f       	sbci	r23, 0xFF	; 255
    1988:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <xTimerQueue>
    198c:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <xTimerQueue+0x1>
    1990:	0e 94 0e 04 	call	0x81c	; 0x81c <xQueueGenericSend>
    1994:	17 c0       	rjmp	.+46     	; 0x19c4 <xTimerGenericCommand+0x7c>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1996:	20 e0       	ldi	r18, 0x00	; 0
    1998:	40 e0       	ldi	r20, 0x00	; 0
    199a:	50 e0       	ldi	r21, 0x00	; 0
    199c:	be 01       	movw	r22, r28
    199e:	6f 5f       	subi	r22, 0xFF	; 255
    19a0:	7f 4f       	sbci	r23, 0xFF	; 255
    19a2:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <xTimerQueue>
    19a6:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <xTimerQueue+0x1>
    19aa:	0e 94 0e 04 	call	0x81c	; 0x81c <xQueueGenericSend>
    19ae:	0a c0       	rjmp	.+20     	; 0x19c4 <xTimerGenericCommand+0x7c>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    19b0:	20 e0       	ldi	r18, 0x00	; 0
    19b2:	ad 01       	movw	r20, r26
    19b4:	be 01       	movw	r22, r28
    19b6:	6f 5f       	subi	r22, 0xFF	; 255
    19b8:	7f 4f       	sbci	r23, 0xFF	; 255
    19ba:	cf 01       	movw	r24, r30
    19bc:	0e 94 af 04 	call	0x95e	; 0x95e <xQueueGenericSendFromISR>
    19c0:	01 c0       	rjmp	.+2      	; 0x19c4 <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    19c2:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    19c4:	0f 90       	pop	r0
    19c6:	0f 90       	pop	r0
    19c8:	0f 90       	pop	r0
    19ca:	0f 90       	pop	r0
    19cc:	0f 90       	pop	r0
    19ce:	df 91       	pop	r29
    19d0:	cf 91       	pop	r28
    19d2:	1f 91       	pop	r17
    19d4:	0f 91       	pop	r16
    19d6:	08 95       	ret

000019d8 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    19d8:	af 92       	push	r10
    19da:	bf 92       	push	r11
    19dc:	cf 92       	push	r12
    19de:	df 92       	push	r13
    19e0:	ef 92       	push	r14
    19e2:	ff 92       	push	r15
    19e4:	0f 93       	push	r16
    19e6:	1f 93       	push	r17
    19e8:	cf 93       	push	r28
    19ea:	df 93       	push	r29
    19ec:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    19ee:	0e 94 6f 08 	call	0x10de	; 0x10de <xTaskGetTickCount>
    19f2:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    19f4:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <xLastTime.2416>
    19f8:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <xLastTime.2416+0x1>
    19fc:	e8 16       	cp	r14, r24
    19fe:	f9 06       	cpc	r15, r25
    1a00:	08 f0       	brcs	.+2      	; 0x1a04 <prvSampleTimeNow+0x2c>
    1a02:	48 c0       	rjmp	.+144    	; 0x1a94 <prvSampleTimeNow+0xbc>
    1a04:	30 c0       	rjmp	.+96     	; 0x1a66 <prvSampleTimeNow+0x8e>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1a06:	05 80       	ldd	r0, Z+5	; 0x05
    1a08:	f6 81       	ldd	r31, Z+6	; 0x06
    1a0a:	e0 2d       	mov	r30, r0
    1a0c:	a0 80       	ld	r10, Z
    1a0e:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1a10:	c6 81       	ldd	r28, Z+6	; 0x06
    1a12:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1a14:	8e 01       	movw	r16, r28
    1a16:	0e 5f       	subi	r16, 0xFE	; 254
    1a18:	1f 4f       	sbci	r17, 0xFF	; 255
    1a1a:	c8 01       	movw	r24, r16
    1a1c:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1a20:	e8 89       	ldd	r30, Y+16	; 0x10
    1a22:	f9 89       	ldd	r31, Y+17	; 0x11
    1a24:	ce 01       	movw	r24, r28
    1a26:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1a28:	8a 89       	ldd	r24, Y+18	; 0x12
    1a2a:	82 ff       	sbrs	r24, 2
    1a2c:	1c c0       	rjmp	.+56     	; 0x1a66 <prvSampleTimeNow+0x8e>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1a2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a30:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a32:	8a 0d       	add	r24, r10
    1a34:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    1a36:	a8 16       	cp	r10, r24
    1a38:	b9 06       	cpc	r11, r25
    1a3a:	60 f4       	brcc	.+24     	; 0x1a54 <prvSampleTimeNow+0x7c>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1a3c:	9b 83       	std	Y+3, r25	; 0x03
    1a3e:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1a40:	d9 87       	std	Y+9, r29	; 0x09
    1a42:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1a44:	b8 01       	movw	r22, r16
    1a46:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <pxCurrentTimerList>
    1a4a:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <pxCurrentTimerList+0x1>
    1a4e:	0e 94 05 01 	call	0x20a	; 0x20a <vListInsert>
    1a52:	09 c0       	rjmp	.+18     	; 0x1a66 <prvSampleTimeNow+0x8e>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1a54:	00 e0       	ldi	r16, 0x00	; 0
    1a56:	10 e0       	ldi	r17, 0x00	; 0
    1a58:	20 e0       	ldi	r18, 0x00	; 0
    1a5a:	30 e0       	ldi	r19, 0x00	; 0
    1a5c:	a5 01       	movw	r20, r10
    1a5e:	60 e0       	ldi	r22, 0x00	; 0
    1a60:	ce 01       	movw	r24, r28
    1a62:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1a66:	e0 91 97 01 	lds	r30, 0x0197	; 0x800197 <pxCurrentTimerList>
    1a6a:	f0 91 98 01 	lds	r31, 0x0198	; 0x800198 <pxCurrentTimerList+0x1>
    1a6e:	80 81       	ld	r24, Z
    1a70:	81 11       	cpse	r24, r1
    1a72:	c9 cf       	rjmp	.-110    	; 0x1a06 <prvSampleTimeNow+0x2e>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    1a74:	80 91 95 01 	lds	r24, 0x0195	; 0x800195 <pxOverflowTimerList>
    1a78:	90 91 96 01 	lds	r25, 0x0196	; 0x800196 <pxOverflowTimerList+0x1>
    1a7c:	90 93 98 01 	sts	0x0198, r25	; 0x800198 <pxCurrentTimerList+0x1>
    1a80:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    1a84:	f0 93 96 01 	sts	0x0196, r31	; 0x800196 <pxOverflowTimerList+0x1>
    1a88:	e0 93 95 01 	sts	0x0195, r30	; 0x800195 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    1a8c:	81 e0       	ldi	r24, 0x01	; 1
    1a8e:	f6 01       	movw	r30, r12
    1a90:	80 83       	st	Z, r24
    1a92:	02 c0       	rjmp	.+4      	; 0x1a98 <prvSampleTimeNow+0xc0>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    1a94:	f6 01       	movw	r30, r12
    1a96:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    1a98:	f0 92 90 01 	sts	0x0190, r15	; 0x800190 <xLastTime.2416+0x1>
    1a9c:	e0 92 8f 01 	sts	0x018F, r14	; 0x80018f <xLastTime.2416>

    return xTimeNow;
}
    1aa0:	c7 01       	movw	r24, r14
    1aa2:	df 91       	pop	r29
    1aa4:	cf 91       	pop	r28
    1aa6:	1f 91       	pop	r17
    1aa8:	0f 91       	pop	r16
    1aaa:	ff 90       	pop	r15
    1aac:	ef 90       	pop	r14
    1aae:	df 90       	pop	r13
    1ab0:	cf 90       	pop	r12
    1ab2:	bf 90       	pop	r11
    1ab4:	af 90       	pop	r10
    1ab6:	08 95       	ret

00001ab8 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    1ab8:	cf 93       	push	r28
    1aba:	df 93       	push	r29
    1abc:	00 d0       	rcall	.+0      	; 0x1abe <prvTimerTask+0x6>
    1abe:	00 d0       	rcall	.+0      	; 0x1ac0 <prvTimerTask+0x8>
    1ac0:	00 d0       	rcall	.+0      	; 0x1ac2 <prvTimerTask+0xa>
    1ac2:	cd b7       	in	r28, 0x3d	; 61
    1ac4:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1ac6:	ce 01       	movw	r24, r28
    1ac8:	01 96       	adiw	r24, 0x01	; 1
    1aca:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1acc:	44 24       	eor	r4, r4
    1ace:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    1ad0:	e1 2c       	mov	r14, r1
    1ad2:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1ad4:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1ad6:	c8 2e       	mov	r12, r24
    1ad8:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1ada:	e0 91 97 01 	lds	r30, 0x0197	; 0x800197 <pxCurrentTimerList>
    1ade:	f0 91 98 01 	lds	r31, 0x0198	; 0x800198 <pxCurrentTimerList+0x1>
    1ae2:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    1ae4:	88 23       	and	r24, r24
    1ae6:	09 f4       	brne	.+2      	; 0x1aea <prvTimerTask+0x32>
    1ae8:	dc c0       	rjmp	.+440    	; 0x1ca2 <prvTimerTask+0x1ea>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1aea:	05 80       	ldd	r0, Z+5	; 0x05
    1aec:	f6 81       	ldd	r31, Z+6	; 0x06
    1aee:	e0 2d       	mov	r30, r0
    1af0:	a0 80       	ld	r10, Z
    1af2:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    1af4:	0e 94 69 08 	call	0x10d2	; 0x10d2 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1af8:	c4 01       	movw	r24, r8
    1afa:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <prvSampleTimeNow>
    1afe:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    1b00:	89 81       	ldd	r24, Y+1	; 0x01
    1b02:	81 11       	cpse	r24, r1
    1b04:	4b c0       	rjmp	.+150    	; 0x1b9c <prvTimerTask+0xe4>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1b06:	0a 15       	cp	r16, r10
    1b08:	1b 05       	cpc	r17, r11
    1b0a:	b8 f1       	brcs	.+110    	; 0x1b7a <prvTimerTask+0xc2>
            {
                ( void ) xTaskResumeAll();
    1b0c:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1b10:	e0 91 97 01 	lds	r30, 0x0197	; 0x800197 <pxCurrentTimerList>
    1b14:	f0 91 98 01 	lds	r31, 0x0198	; 0x800198 <pxCurrentTimerList+0x1>
    1b18:	05 80       	ldd	r0, Z+5	; 0x05
    1b1a:	f6 81       	ldd	r31, Z+6	; 0x06
    1b1c:	e0 2d       	mov	r30, r0
    1b1e:	66 80       	ldd	r6, Z+6	; 0x06
    1b20:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1b22:	c3 01       	movw	r24, r6
    1b24:	02 96       	adiw	r24, 0x02	; 2
    1b26:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto-reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1b2a:	d3 01       	movw	r26, r6
    1b2c:	52 96       	adiw	r26, 0x12	; 18
    1b2e:	8c 91       	ld	r24, X
    1b30:	52 97       	sbiw	r26, 0x12	; 18
    1b32:	82 ff       	sbrs	r24, 2
    1b34:	17 c0       	rjmp	.+46     	; 0x1b64 <prvTimerTask+0xac>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1b36:	1c 96       	adiw	r26, 0x0c	; 12
    1b38:	6d 91       	ld	r22, X+
    1b3a:	7c 91       	ld	r23, X
    1b3c:	1d 97       	sbiw	r26, 0x0d	; 13
    1b3e:	6a 0d       	add	r22, r10
    1b40:	7b 1d       	adc	r23, r11
    1b42:	95 01       	movw	r18, r10
    1b44:	a8 01       	movw	r20, r16
    1b46:	c3 01       	movw	r24, r6
    1b48:	0e 94 2a 0c 	call	0x1854	; 0x1854 <prvInsertTimerInActiveList>
    1b4c:	88 23       	and	r24, r24
    1b4e:	69 f0       	breq	.+26     	; 0x1b6a <prvTimerTask+0xb2>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1b50:	0e 2d       	mov	r16, r14
    1b52:	1f 2d       	mov	r17, r15
    1b54:	2e 2d       	mov	r18, r14
    1b56:	3f 2d       	mov	r19, r15
    1b58:	a5 01       	movw	r20, r10
    1b5a:	65 2d       	mov	r22, r5
    1b5c:	c3 01       	movw	r24, r6
    1b5e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTimerGenericCommand>
    1b62:	03 c0       	rjmp	.+6      	; 0x1b6a <prvTimerTask+0xb2>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1b64:	8e 7f       	andi	r24, 0xFE	; 254
    1b66:	f3 01       	movw	r30, r6
    1b68:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1b6a:	d3 01       	movw	r26, r6
    1b6c:	50 96       	adiw	r26, 0x10	; 16
    1b6e:	ed 91       	ld	r30, X+
    1b70:	fc 91       	ld	r31, X
    1b72:	51 97       	sbiw	r26, 0x11	; 17
    1b74:	c3 01       	movw	r24, r6
    1b76:	09 95       	icall
    1b78:	87 c0       	rjmp	.+270    	; 0x1c88 <prvTimerTask+0x1d0>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1b7a:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1b7c:	b5 01       	movw	r22, r10
    1b7e:	60 1b       	sub	r22, r16
    1b80:	71 0b       	sbc	r23, r17
    1b82:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <xTimerQueue>
    1b86:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <xTimerQueue+0x1>
    1b8a:	0e 94 51 06 	call	0xca2	; 0xca2 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    1b8e:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
    1b92:	81 11       	cpse	r24, r1
    1b94:	79 c0       	rjmp	.+242    	; 0x1c88 <prvTimerTask+0x1d0>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    1b96:	0e 94 1b 02 	call	0x436	; 0x436 <vPortYield>
    1b9a:	76 c0       	rjmp	.+236    	; 0x1c88 <prvTimerTask+0x1d0>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    1b9c:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskResumeAll>
    1ba0:	73 c0       	rjmp	.+230    	; 0x1c88 <prvTimerTask+0x1d0>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
    1ba4:	88 23       	and	r24, r24
    1ba6:	0c f4       	brge	.+2      	; 0x1baa <prvTimerTask+0xf2>
    1ba8:	6f c0       	rjmp	.+222    	; 0x1c88 <prvTimerTask+0x1d0>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1baa:	ac 80       	ldd	r10, Y+4	; 0x04
    1bac:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    1bae:	f5 01       	movw	r30, r10
    1bb0:	82 85       	ldd	r24, Z+10	; 0x0a
    1bb2:	93 85       	ldd	r25, Z+11	; 0x0b
    1bb4:	89 2b       	or	r24, r25
    1bb6:	21 f0       	breq	.+8      	; 0x1bc0 <prvTimerTask+0x108>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1bb8:	c5 01       	movw	r24, r10
    1bba:	02 96       	adiw	r24, 0x02	; 2
    1bbc:	0e 94 36 01 	call	0x26c	; 0x26c <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1bc0:	ce 01       	movw	r24, r28
    1bc2:	06 96       	adiw	r24, 0x06	; 6
    1bc4:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <prvSampleTimeNow>

            switch( xMessage.xMessageID )
    1bc8:	e9 81       	ldd	r30, Y+1	; 0x01
    1bca:	0e 2e       	mov	r0, r30
    1bcc:	00 0c       	add	r0, r0
    1bce:	ff 0b       	sbc	r31, r31
    1bd0:	ea 30       	cpi	r30, 0x0A	; 10
    1bd2:	f1 05       	cpc	r31, r1
    1bd4:	08 f0       	brcs	.+2      	; 0x1bd8 <prvTimerTask+0x120>
    1bd6:	58 c0       	rjmp	.+176    	; 0x1c88 <prvTimerTask+0x1d0>
    1bd8:	ea 5a       	subi	r30, 0xAA	; 170
    1bda:	ff 4f       	sbci	r31, 0xFF	; 255
    1bdc:	0c 94 65 0e 	jmp	0x1cca	; 0x1cca <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    1be0:	d5 01       	movw	r26, r10
    1be2:	52 96       	adiw	r26, 0x12	; 18
    1be4:	2c 91       	ld	r18, X
    1be6:	52 97       	sbiw	r26, 0x12	; 18
    1be8:	21 60       	ori	r18, 0x01	; 1
    1bea:	52 96       	adiw	r26, 0x12	; 18
    1bec:	2c 93       	st	X, r18
    1bee:	52 97       	sbiw	r26, 0x12	; 18
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1bf0:	2a 81       	ldd	r18, Y+2	; 0x02
    1bf2:	3b 81       	ldd	r19, Y+3	; 0x03
    1bf4:	1c 96       	adiw	r26, 0x0c	; 12
    1bf6:	6d 91       	ld	r22, X+
    1bf8:	7c 91       	ld	r23, X
    1bfa:	1d 97       	sbiw	r26, 0x0d	; 13
    1bfc:	62 0f       	add	r22, r18
    1bfe:	73 1f       	adc	r23, r19
    1c00:	ac 01       	movw	r20, r24
    1c02:	c5 01       	movw	r24, r10
    1c04:	0e 94 2a 0c 	call	0x1854	; 0x1854 <prvInsertTimerInActiveList>
    1c08:	88 23       	and	r24, r24
    1c0a:	f1 f1       	breq	.+124    	; 0x1c88 <prvTimerTask+0x1d0>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1c0c:	d5 01       	movw	r26, r10
    1c0e:	50 96       	adiw	r26, 0x10	; 16
    1c10:	ed 91       	ld	r30, X+
    1c12:	fc 91       	ld	r31, X
    1c14:	51 97       	sbiw	r26, 0x11	; 17
    1c16:	c5 01       	movw	r24, r10
    1c18:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1c1a:	f5 01       	movw	r30, r10
    1c1c:	82 89       	ldd	r24, Z+18	; 0x12
    1c1e:	82 ff       	sbrs	r24, 2
    1c20:	33 c0       	rjmp	.+102    	; 0x1c88 <prvTimerTask+0x1d0>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1c22:	4a 81       	ldd	r20, Y+2	; 0x02
    1c24:	5b 81       	ldd	r21, Y+3	; 0x03
    1c26:	84 85       	ldd	r24, Z+12	; 0x0c
    1c28:	95 85       	ldd	r25, Z+13	; 0x0d
    1c2a:	48 0f       	add	r20, r24
    1c2c:	59 1f       	adc	r21, r25
    1c2e:	0e 2d       	mov	r16, r14
    1c30:	1f 2d       	mov	r17, r15
    1c32:	2e 2d       	mov	r18, r14
    1c34:	3f 2d       	mov	r19, r15
    1c36:	65 2d       	mov	r22, r5
    1c38:	c5 01       	movw	r24, r10
    1c3a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTimerGenericCommand>
    1c3e:	24 c0       	rjmp	.+72     	; 0x1c88 <prvTimerTask+0x1d0>
                    break;

                case tmrCOMMAND_STOP :
                case tmrCOMMAND_STOP_FROM_ISR :
                    /* The timer has already been removed from the active list. */
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1c40:	d5 01       	movw	r26, r10
    1c42:	52 96       	adiw	r26, 0x12	; 18
    1c44:	8c 91       	ld	r24, X
    1c46:	52 97       	sbiw	r26, 0x12	; 18
    1c48:	8e 7f       	andi	r24, 0xFE	; 254
    1c4a:	52 96       	adiw	r26, 0x12	; 18
    1c4c:	8c 93       	st	X, r24
    1c4e:	1c c0       	rjmp	.+56     	; 0x1c88 <prvTimerTask+0x1d0>
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    1c50:	f5 01       	movw	r30, r10
    1c52:	22 89       	ldd	r18, Z+18	; 0x12
    1c54:	21 60       	ori	r18, 0x01	; 1
    1c56:	22 8b       	std	Z+18, r18	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1c58:	6a 81       	ldd	r22, Y+2	; 0x02
    1c5a:	7b 81       	ldd	r23, Y+3	; 0x03
    1c5c:	75 87       	std	Z+13, r23	; 0x0d
    1c5e:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1c60:	68 0f       	add	r22, r24
    1c62:	79 1f       	adc	r23, r25
    1c64:	9c 01       	movw	r18, r24
    1c66:	ac 01       	movw	r20, r24
    1c68:	c5 01       	movw	r24, r10
    1c6a:	0e 94 2a 0c 	call	0x1854	; 0x1854 <prvInsertTimerInActiveList>
    1c6e:	0c c0       	rjmp	.+24     	; 0x1c88 <prvTimerTask+0x1d0>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    1c70:	d5 01       	movw	r26, r10
    1c72:	52 96       	adiw	r26, 0x12	; 18
    1c74:	8c 91       	ld	r24, X
    1c76:	81 fd       	sbrc	r24, 1
    1c78:	04 c0       	rjmp	.+8      	; 0x1c82 <prvTimerTask+0x1ca>
                        {
                            vPortFree( pxTimer );
    1c7a:	c5 01       	movw	r24, r10
    1c7c:	0e 94 92 00 	call	0x124	; 0x124 <vPortFree>
    1c80:	03 c0       	rjmp	.+6      	; 0x1c88 <prvTimerTask+0x1d0>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1c82:	8e 7f       	andi	r24, 0xFE	; 254
    1c84:	f5 01       	movw	r30, r10
    1c86:	82 8b       	std	Z+18, r24	; 0x12
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1c88:	4e 2d       	mov	r20, r14
    1c8a:	5f 2d       	mov	r21, r15
    1c8c:	6c 2d       	mov	r22, r12
    1c8e:	7d 2d       	mov	r23, r13
    1c90:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <xTimerQueue>
    1c94:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <xTimerQueue+0x1>
    1c98:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <xQueueReceive>
    1c9c:	81 11       	cpse	r24, r1
    1c9e:	81 cf       	rjmp	.-254    	; 0x1ba2 <prvTimerTask+0xea>
    1ca0:	1c cf       	rjmp	.-456    	; 0x1ada <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    1ca2:	0e 94 69 08 	call	0x10d2	; 0x10d2 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1ca6:	c4 01       	movw	r24, r8
    1ca8:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <prvSampleTimeNow>
    1cac:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    1cae:	89 81       	ldd	r24, Y+1	; 0x01
    1cb0:	81 11       	cpse	r24, r1
    1cb2:	74 cf       	rjmp	.-280    	; 0x1b9c <prvTimerTask+0xe4>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1cb4:	e0 91 95 01 	lds	r30, 0x0195	; 0x800195 <pxOverflowTimerList>
    1cb8:	f0 91 96 01 	lds	r31, 0x0196	; 0x800196 <pxOverflowTimerList+0x1>
    1cbc:	80 81       	ld	r24, Z
    1cbe:	44 2d       	mov	r20, r4
    1cc0:	81 11       	cpse	r24, r1
    1cc2:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    1cc4:	ae 2c       	mov	r10, r14
    1cc6:	bf 2c       	mov	r11, r15
    1cc8:	59 cf       	rjmp	.-334    	; 0x1b7c <prvTimerTask+0xc4>

00001cca <__tablejump2__>:
    1cca:	ee 0f       	add	r30, r30
    1ccc:	ff 1f       	adc	r31, r31
    1cce:	05 90       	lpm	r0, Z+
    1cd0:	f4 91       	lpm	r31, Z
    1cd2:	e0 2d       	mov	r30, r0
    1cd4:	09 94       	ijmp

00001cd6 <malloc>:
    1cd6:	0f 93       	push	r16
    1cd8:	1f 93       	push	r17
    1cda:	cf 93       	push	r28
    1cdc:	df 93       	push	r29
    1cde:	82 30       	cpi	r24, 0x02	; 2
    1ce0:	91 05       	cpc	r25, r1
    1ce2:	10 f4       	brcc	.+4      	; 0x1ce8 <malloc+0x12>
    1ce4:	82 e0       	ldi	r24, 0x02	; 2
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	e0 91 af 01 	lds	r30, 0x01AF	; 0x8001af <__flp>
    1cec:	f0 91 b0 01 	lds	r31, 0x01B0	; 0x8001b0 <__flp+0x1>
    1cf0:	20 e0       	ldi	r18, 0x00	; 0
    1cf2:	30 e0       	ldi	r19, 0x00	; 0
    1cf4:	a0 e0       	ldi	r26, 0x00	; 0
    1cf6:	b0 e0       	ldi	r27, 0x00	; 0
    1cf8:	30 97       	sbiw	r30, 0x00	; 0
    1cfa:	19 f1       	breq	.+70     	; 0x1d42 <malloc+0x6c>
    1cfc:	40 81       	ld	r20, Z
    1cfe:	51 81       	ldd	r21, Z+1	; 0x01
    1d00:	02 81       	ldd	r16, Z+2	; 0x02
    1d02:	13 81       	ldd	r17, Z+3	; 0x03
    1d04:	48 17       	cp	r20, r24
    1d06:	59 07       	cpc	r21, r25
    1d08:	c8 f0       	brcs	.+50     	; 0x1d3c <malloc+0x66>
    1d0a:	84 17       	cp	r24, r20
    1d0c:	95 07       	cpc	r25, r21
    1d0e:	69 f4       	brne	.+26     	; 0x1d2a <malloc+0x54>
    1d10:	10 97       	sbiw	r26, 0x00	; 0
    1d12:	31 f0       	breq	.+12     	; 0x1d20 <malloc+0x4a>
    1d14:	12 96       	adiw	r26, 0x02	; 2
    1d16:	0c 93       	st	X, r16
    1d18:	12 97       	sbiw	r26, 0x02	; 2
    1d1a:	13 96       	adiw	r26, 0x03	; 3
    1d1c:	1c 93       	st	X, r17
    1d1e:	27 c0       	rjmp	.+78     	; 0x1d6e <malloc+0x98>
    1d20:	00 93 af 01 	sts	0x01AF, r16	; 0x8001af <__flp>
    1d24:	10 93 b0 01 	sts	0x01B0, r17	; 0x8001b0 <__flp+0x1>
    1d28:	22 c0       	rjmp	.+68     	; 0x1d6e <malloc+0x98>
    1d2a:	21 15       	cp	r18, r1
    1d2c:	31 05       	cpc	r19, r1
    1d2e:	19 f0       	breq	.+6      	; 0x1d36 <malloc+0x60>
    1d30:	42 17       	cp	r20, r18
    1d32:	53 07       	cpc	r21, r19
    1d34:	18 f4       	brcc	.+6      	; 0x1d3c <malloc+0x66>
    1d36:	9a 01       	movw	r18, r20
    1d38:	bd 01       	movw	r22, r26
    1d3a:	ef 01       	movw	r28, r30
    1d3c:	df 01       	movw	r26, r30
    1d3e:	f8 01       	movw	r30, r16
    1d40:	db cf       	rjmp	.-74     	; 0x1cf8 <malloc+0x22>
    1d42:	21 15       	cp	r18, r1
    1d44:	31 05       	cpc	r19, r1
    1d46:	f9 f0       	breq	.+62     	; 0x1d86 <malloc+0xb0>
    1d48:	28 1b       	sub	r18, r24
    1d4a:	39 0b       	sbc	r19, r25
    1d4c:	24 30       	cpi	r18, 0x04	; 4
    1d4e:	31 05       	cpc	r19, r1
    1d50:	80 f4       	brcc	.+32     	; 0x1d72 <malloc+0x9c>
    1d52:	8a 81       	ldd	r24, Y+2	; 0x02
    1d54:	9b 81       	ldd	r25, Y+3	; 0x03
    1d56:	61 15       	cp	r22, r1
    1d58:	71 05       	cpc	r23, r1
    1d5a:	21 f0       	breq	.+8      	; 0x1d64 <malloc+0x8e>
    1d5c:	fb 01       	movw	r30, r22
    1d5e:	93 83       	std	Z+3, r25	; 0x03
    1d60:	82 83       	std	Z+2, r24	; 0x02
    1d62:	04 c0       	rjmp	.+8      	; 0x1d6c <malloc+0x96>
    1d64:	90 93 b0 01 	sts	0x01B0, r25	; 0x8001b0 <__flp+0x1>
    1d68:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <__flp>
    1d6c:	fe 01       	movw	r30, r28
    1d6e:	32 96       	adiw	r30, 0x02	; 2
    1d70:	44 c0       	rjmp	.+136    	; 0x1dfa <malloc+0x124>
    1d72:	fe 01       	movw	r30, r28
    1d74:	e2 0f       	add	r30, r18
    1d76:	f3 1f       	adc	r31, r19
    1d78:	81 93       	st	Z+, r24
    1d7a:	91 93       	st	Z+, r25
    1d7c:	22 50       	subi	r18, 0x02	; 2
    1d7e:	31 09       	sbc	r19, r1
    1d80:	39 83       	std	Y+1, r19	; 0x01
    1d82:	28 83       	st	Y, r18
    1d84:	3a c0       	rjmp	.+116    	; 0x1dfa <malloc+0x124>
    1d86:	20 91 ad 01 	lds	r18, 0x01AD	; 0x8001ad <__brkval>
    1d8a:	30 91 ae 01 	lds	r19, 0x01AE	; 0x8001ae <__brkval+0x1>
    1d8e:	23 2b       	or	r18, r19
    1d90:	41 f4       	brne	.+16     	; 0x1da2 <malloc+0xcc>
    1d92:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    1d96:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    1d9a:	30 93 ae 01 	sts	0x01AE, r19	; 0x8001ae <__brkval+0x1>
    1d9e:	20 93 ad 01 	sts	0x01AD, r18	; 0x8001ad <__brkval>
    1da2:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    1da6:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    1daa:	21 15       	cp	r18, r1
    1dac:	31 05       	cpc	r19, r1
    1dae:	41 f4       	brne	.+16     	; 0x1dc0 <malloc+0xea>
    1db0:	2d b7       	in	r18, 0x3d	; 61
    1db2:	3e b7       	in	r19, 0x3e	; 62
    1db4:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1db8:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1dbc:	24 1b       	sub	r18, r20
    1dbe:	35 0b       	sbc	r19, r21
    1dc0:	e0 91 ad 01 	lds	r30, 0x01AD	; 0x8001ad <__brkval>
    1dc4:	f0 91 ae 01 	lds	r31, 0x01AE	; 0x8001ae <__brkval+0x1>
    1dc8:	e2 17       	cp	r30, r18
    1dca:	f3 07       	cpc	r31, r19
    1dcc:	a0 f4       	brcc	.+40     	; 0x1df6 <malloc+0x120>
    1dce:	2e 1b       	sub	r18, r30
    1dd0:	3f 0b       	sbc	r19, r31
    1dd2:	28 17       	cp	r18, r24
    1dd4:	39 07       	cpc	r19, r25
    1dd6:	78 f0       	brcs	.+30     	; 0x1df6 <malloc+0x120>
    1dd8:	ac 01       	movw	r20, r24
    1dda:	4e 5f       	subi	r20, 0xFE	; 254
    1ddc:	5f 4f       	sbci	r21, 0xFF	; 255
    1dde:	24 17       	cp	r18, r20
    1de0:	35 07       	cpc	r19, r21
    1de2:	48 f0       	brcs	.+18     	; 0x1df6 <malloc+0x120>
    1de4:	4e 0f       	add	r20, r30
    1de6:	5f 1f       	adc	r21, r31
    1de8:	50 93 ae 01 	sts	0x01AE, r21	; 0x8001ae <__brkval+0x1>
    1dec:	40 93 ad 01 	sts	0x01AD, r20	; 0x8001ad <__brkval>
    1df0:	81 93       	st	Z+, r24
    1df2:	91 93       	st	Z+, r25
    1df4:	02 c0       	rjmp	.+4      	; 0x1dfa <malloc+0x124>
    1df6:	e0 e0       	ldi	r30, 0x00	; 0
    1df8:	f0 e0       	ldi	r31, 0x00	; 0
    1dfa:	cf 01       	movw	r24, r30
    1dfc:	df 91       	pop	r29
    1dfe:	cf 91       	pop	r28
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	08 95       	ret

00001e06 <free>:
    1e06:	cf 93       	push	r28
    1e08:	df 93       	push	r29
    1e0a:	00 97       	sbiw	r24, 0x00	; 0
    1e0c:	09 f4       	brne	.+2      	; 0x1e10 <free+0xa>
    1e0e:	81 c0       	rjmp	.+258    	; 0x1f12 <free+0x10c>
    1e10:	fc 01       	movw	r30, r24
    1e12:	32 97       	sbiw	r30, 0x02	; 2
    1e14:	13 82       	std	Z+3, r1	; 0x03
    1e16:	12 82       	std	Z+2, r1	; 0x02
    1e18:	a0 91 af 01 	lds	r26, 0x01AF	; 0x8001af <__flp>
    1e1c:	b0 91 b0 01 	lds	r27, 0x01B0	; 0x8001b0 <__flp+0x1>
    1e20:	10 97       	sbiw	r26, 0x00	; 0
    1e22:	81 f4       	brne	.+32     	; 0x1e44 <free+0x3e>
    1e24:	20 81       	ld	r18, Z
    1e26:	31 81       	ldd	r19, Z+1	; 0x01
    1e28:	82 0f       	add	r24, r18
    1e2a:	93 1f       	adc	r25, r19
    1e2c:	20 91 ad 01 	lds	r18, 0x01AD	; 0x8001ad <__brkval>
    1e30:	30 91 ae 01 	lds	r19, 0x01AE	; 0x8001ae <__brkval+0x1>
    1e34:	28 17       	cp	r18, r24
    1e36:	39 07       	cpc	r19, r25
    1e38:	51 f5       	brne	.+84     	; 0x1e8e <free+0x88>
    1e3a:	f0 93 ae 01 	sts	0x01AE, r31	; 0x8001ae <__brkval+0x1>
    1e3e:	e0 93 ad 01 	sts	0x01AD, r30	; 0x8001ad <__brkval>
    1e42:	67 c0       	rjmp	.+206    	; 0x1f12 <free+0x10c>
    1e44:	ed 01       	movw	r28, r26
    1e46:	20 e0       	ldi	r18, 0x00	; 0
    1e48:	30 e0       	ldi	r19, 0x00	; 0
    1e4a:	ce 17       	cp	r28, r30
    1e4c:	df 07       	cpc	r29, r31
    1e4e:	40 f4       	brcc	.+16     	; 0x1e60 <free+0x5a>
    1e50:	4a 81       	ldd	r20, Y+2	; 0x02
    1e52:	5b 81       	ldd	r21, Y+3	; 0x03
    1e54:	9e 01       	movw	r18, r28
    1e56:	41 15       	cp	r20, r1
    1e58:	51 05       	cpc	r21, r1
    1e5a:	f1 f0       	breq	.+60     	; 0x1e98 <free+0x92>
    1e5c:	ea 01       	movw	r28, r20
    1e5e:	f5 cf       	rjmp	.-22     	; 0x1e4a <free+0x44>
    1e60:	d3 83       	std	Z+3, r29	; 0x03
    1e62:	c2 83       	std	Z+2, r28	; 0x02
    1e64:	40 81       	ld	r20, Z
    1e66:	51 81       	ldd	r21, Z+1	; 0x01
    1e68:	84 0f       	add	r24, r20
    1e6a:	95 1f       	adc	r25, r21
    1e6c:	c8 17       	cp	r28, r24
    1e6e:	d9 07       	cpc	r29, r25
    1e70:	59 f4       	brne	.+22     	; 0x1e88 <free+0x82>
    1e72:	88 81       	ld	r24, Y
    1e74:	99 81       	ldd	r25, Y+1	; 0x01
    1e76:	84 0f       	add	r24, r20
    1e78:	95 1f       	adc	r25, r21
    1e7a:	02 96       	adiw	r24, 0x02	; 2
    1e7c:	91 83       	std	Z+1, r25	; 0x01
    1e7e:	80 83       	st	Z, r24
    1e80:	8a 81       	ldd	r24, Y+2	; 0x02
    1e82:	9b 81       	ldd	r25, Y+3	; 0x03
    1e84:	93 83       	std	Z+3, r25	; 0x03
    1e86:	82 83       	std	Z+2, r24	; 0x02
    1e88:	21 15       	cp	r18, r1
    1e8a:	31 05       	cpc	r19, r1
    1e8c:	29 f4       	brne	.+10     	; 0x1e98 <free+0x92>
    1e8e:	f0 93 b0 01 	sts	0x01B0, r31	; 0x8001b0 <__flp+0x1>
    1e92:	e0 93 af 01 	sts	0x01AF, r30	; 0x8001af <__flp>
    1e96:	3d c0       	rjmp	.+122    	; 0x1f12 <free+0x10c>
    1e98:	e9 01       	movw	r28, r18
    1e9a:	fb 83       	std	Y+3, r31	; 0x03
    1e9c:	ea 83       	std	Y+2, r30	; 0x02
    1e9e:	49 91       	ld	r20, Y+
    1ea0:	59 91       	ld	r21, Y+
    1ea2:	c4 0f       	add	r28, r20
    1ea4:	d5 1f       	adc	r29, r21
    1ea6:	ec 17       	cp	r30, r28
    1ea8:	fd 07       	cpc	r31, r29
    1eaa:	61 f4       	brne	.+24     	; 0x1ec4 <free+0xbe>
    1eac:	80 81       	ld	r24, Z
    1eae:	91 81       	ldd	r25, Z+1	; 0x01
    1eb0:	84 0f       	add	r24, r20
    1eb2:	95 1f       	adc	r25, r21
    1eb4:	02 96       	adiw	r24, 0x02	; 2
    1eb6:	e9 01       	movw	r28, r18
    1eb8:	99 83       	std	Y+1, r25	; 0x01
    1eba:	88 83       	st	Y, r24
    1ebc:	82 81       	ldd	r24, Z+2	; 0x02
    1ebe:	93 81       	ldd	r25, Z+3	; 0x03
    1ec0:	9b 83       	std	Y+3, r25	; 0x03
    1ec2:	8a 83       	std	Y+2, r24	; 0x02
    1ec4:	e0 e0       	ldi	r30, 0x00	; 0
    1ec6:	f0 e0       	ldi	r31, 0x00	; 0
    1ec8:	12 96       	adiw	r26, 0x02	; 2
    1eca:	8d 91       	ld	r24, X+
    1ecc:	9c 91       	ld	r25, X
    1ece:	13 97       	sbiw	r26, 0x03	; 3
    1ed0:	00 97       	sbiw	r24, 0x00	; 0
    1ed2:	19 f0       	breq	.+6      	; 0x1eda <free+0xd4>
    1ed4:	fd 01       	movw	r30, r26
    1ed6:	dc 01       	movw	r26, r24
    1ed8:	f7 cf       	rjmp	.-18     	; 0x1ec8 <free+0xc2>
    1eda:	8d 91       	ld	r24, X+
    1edc:	9c 91       	ld	r25, X
    1ede:	11 97       	sbiw	r26, 0x01	; 1
    1ee0:	9d 01       	movw	r18, r26
    1ee2:	2e 5f       	subi	r18, 0xFE	; 254
    1ee4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ee6:	82 0f       	add	r24, r18
    1ee8:	93 1f       	adc	r25, r19
    1eea:	20 91 ad 01 	lds	r18, 0x01AD	; 0x8001ad <__brkval>
    1eee:	30 91 ae 01 	lds	r19, 0x01AE	; 0x8001ae <__brkval+0x1>
    1ef2:	28 17       	cp	r18, r24
    1ef4:	39 07       	cpc	r19, r25
    1ef6:	69 f4       	brne	.+26     	; 0x1f12 <free+0x10c>
    1ef8:	30 97       	sbiw	r30, 0x00	; 0
    1efa:	29 f4       	brne	.+10     	; 0x1f06 <free+0x100>
    1efc:	10 92 b0 01 	sts	0x01B0, r1	; 0x8001b0 <__flp+0x1>
    1f00:	10 92 af 01 	sts	0x01AF, r1	; 0x8001af <__flp>
    1f04:	02 c0       	rjmp	.+4      	; 0x1f0a <free+0x104>
    1f06:	13 82       	std	Z+3, r1	; 0x03
    1f08:	12 82       	std	Z+2, r1	; 0x02
    1f0a:	b0 93 ae 01 	sts	0x01AE, r27	; 0x8001ae <__brkval+0x1>
    1f0e:	a0 93 ad 01 	sts	0x01AD, r26	; 0x8001ad <__brkval>
    1f12:	df 91       	pop	r29
    1f14:	cf 91       	pop	r28
    1f16:	08 95       	ret

00001f18 <memcpy>:
    1f18:	fb 01       	movw	r30, r22
    1f1a:	dc 01       	movw	r26, r24
    1f1c:	02 c0       	rjmp	.+4      	; 0x1f22 <memcpy+0xa>
    1f1e:	01 90       	ld	r0, Z+
    1f20:	0d 92       	st	X+, r0
    1f22:	41 50       	subi	r20, 0x01	; 1
    1f24:	50 40       	sbci	r21, 0x00	; 0
    1f26:	d8 f7       	brcc	.-10     	; 0x1f1e <memcpy+0x6>
    1f28:	08 95       	ret

00001f2a <memset>:
    1f2a:	dc 01       	movw	r26, r24
    1f2c:	01 c0       	rjmp	.+2      	; 0x1f30 <memset+0x6>
    1f2e:	6d 93       	st	X+, r22
    1f30:	41 50       	subi	r20, 0x01	; 1
    1f32:	50 40       	sbci	r21, 0x00	; 0
    1f34:	e0 f7       	brcc	.-8      	; 0x1f2e <memset+0x4>
    1f36:	08 95       	ret

00001f38 <_exit>:
    1f38:	f8 94       	cli

00001f3a <__stop_program>:
    1f3a:	ff cf       	rjmp	.-2      	; 0x1f3a <__stop_program>
